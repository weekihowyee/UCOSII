L 1 "..\..\..\..\..\uC-LIB\lib_str.c"
N/*
N*********************************************************************************************************
N*                                               uC/LIB
N*                                       CUSTOM LIBRARY MODULES
N*
N*                          (c) Copyright 2004-2008; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/LIB is provided in source form for FREE evaluation, for educational
N*               use or peaceful research.  If you plan on using uC/LIB in a commercial
N*               product you need to contact Micrium to properly license its use in your
N*               product.  We provide ALL the source code for your convenience and to
N*               help you experience uC/LIB.  The fact that the source code is provided
N*               does NOT mean that you can use it without paying a licensing fee.
N*
N*               Knowledge of the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest
N*               software available.  Your honesty is greatly appreciated.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                       ASCII STRING MANAGEMENT
N*
N* Filename      : lib_str.c
N* Version       : V1.25
N* Programmer(s) : ITJ
N*                 JDH
N*********************************************************************************************************
N* Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
N*
N*                     (a) ALL standard library functions are implemented in the custom library modules :
N*
N*                         (1) \<Custom Library Directory>\lib*.*
N*
N*                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
N*
N*                               where
N*                                       <Custom Library Directory>      directory path for custom library software
N*                                       <cpu>                           directory name for specific processor (CPU)
N*                                       <compiler>                      directory name for specific compiler
N*
N*                     (b) Product-specific library functions are implemented in individual products.
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                            INCLUDE FILES
N*********************************************************************************************************
N*/
N
N#define    LIB_STR_MODULE
N#include  <lib_str.h>
L 1 "..\..\..\..\..\uC-LIB\lib_str.h" 1
N/*
N*********************************************************************************************************
N*                                               uC/LIB
N*                                       CUSTOM LIBRARY MODULES
N*
N*                          (c) Copyright 2004-2008; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/LIB is provided in source form for FREE evaluation, for educational
N*               use or peaceful research.  If you plan on using uC/LIB in a commercial
N*               product you need to contact Micrium to properly license its use in your
N*               product.  We provide ALL the source code for your convenience and to
N*               help you experience uC/LIB.  The fact that the source code is provided
N*               does NOT mean that you can use it without paying a licensing fee.
N*
N*               Knowledge of the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest
N*               software available.  Your honesty is greatly appreciated.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                       ASCII STRING MANAGEMENT
N*
N* Filename      : lib_str.h
N* Version       : V1.25
N* Programmer(s) : ITJ
N*                 JDH
N*********************************************************************************************************
N* Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
N*
N*                     (a) ALL standard library functions are implemented in the custom library modules :
N*
N*                         (1) \<Custom Library Directory>\lib*.*
N*
N*                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
N*
N*                               where
N*                                       <Custom Library Directory>      directory path for custom library software
N*                                       <cpu>                           directory name for specific processor (CPU)
N*                                       <compiler>                      directory name for specific compiler
N*
N*                     (b) Product-specific library functions are implemented in individual products.
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_STR_MODULE_PRESENT
N#define  LIB_STR_MODULE_PRESENT
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            INCLUDE FILES
N*
N* Note(s) : (1) The following common software files are located in the following directories :
N*
N*               (a) \<Custom Library Directory>\lib*.*
N*
N*               (b) (1) \<CPU-Compiler Directory>\cpu_def.h
N*
N*                   (2) \<CPU-Compiler Directory>\<cpu>\<compiler>\cpu*.*
N*
N*                           where
N*                                   <Custom Library Directory>      directory path for custom   library      software
N*                                   <CPU-Compiler Directory>        directory path for common   CPU-compiler software
N*                                   <cpu>                           directory name for specific processor (CPU)
N*                                   <compiler>                      directory name for specific compiler
N*
N*           (2) Compiler MUST be configured to include the '\<Custom Library Directory>\uC-LIB\',
N*               '\<CPU-Compiler Directory>\' directory, & the specific CPU-compiler directory as
N*               additional include path directories.
N*
N*           (3) NO compiler-supplied standard library functions SHOULD be used.
N*
N*               #### The reference to standard library header files SHOULD be removed once all custom 
N*               library functions are implemented WITHOUT reference to ANY standard library function(s).
N*
N*               See also 'STANDARD LIBRARY MACRO'S  Note #1'.
N*********************************************************************************************************
N*/
N
N#include  <cpu.h>
L 1 "..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView\cpu.h" 1
N/*
N*********************************************************************************************************
N*                                               uC/CPU
N*                                    CPU CONFIGURATION & PORT LAYER
N*
N*                          (c) Copyright 2004-2008; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/CPU is provided in source form for FREE evaluation, for educational
N*               use or peaceful research.  If you plan on using uC/CPU in a commercial
N*               product you need to contact Micrium to properly license its use in your
N*               product.  We provide ALL the source code for your convenience and to
N*               help you experience uC/CPU.  The fact that the source code is provided
N*               does NOT mean that you can use it without paying a licensing fee.
N*
N*               Knowledge of the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest
N*               software available.  Your honesty is greatly appreciated.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                            CPU PORT FILE
N*
N*                                            ARM-Cortex-M3
N*                                      RealView Development Suite
N*                            RealView Microcontroller Development Kit (MDK)
N*                                       ARM Developer Suite (ADS)
N*                                            Keil uVision
N*
N* Filename      : cpu.h
N* Version       : V1.19
N* Programmer(s) : JJL
N*                 BAN
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*********************************************************************************************************
N*/
N
N#ifndef  CPU_CFG_MODULE_PRESENT
N#define  CPU_CFG_MODULE_PRESENT
N
N
N/*
N*********************************************************************************************************
N*                                          CPU INCLUDE FILES
N*
N* Note(s) : (1) The following CPU files are located in the following directories :
N*
N*               (a) \<CPU-Compiler Directory>\cpu_def.h
N*
N*               (b) \<CPU-Compiler Directory>\<cpu>\<compiler>\cpu*.*
N*
N*                       where
N*                               <CPU-Compiler Directory>    directory path for common   CPU-compiler software
N*                               <cpu>                       directory name for specific CPU
N*                               <compiler>                  directory name for specific compiler
N*
N*           (2) Compiler MUST be configured to include the '\<CPU-Compiler Directory>\' directory & the
N*               specific CPU-compiler directory as additional include path directories.
N*********************************************************************************************************
N*/
N
N#include  <cpu_def.h>
L 1 "..\..\..\..\..\uC-CPU\cpu_def.h" 1
N/*
N*********************************************************************************************************
N*                                               uC/CPU
N*                                    CPU CONFIGURATION & PORT LAYER
N*
N*                          (c) Copyright 2004-2008; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/CPU is provided in source form for FREE evaluation, for educational
N*               use or peaceful research.  If you plan on using uC/CPU in a commercial
N*               product you need to contact Micrium to properly license its use in your
N*               product.  We provide ALL the source code for your convenience and to
N*               help you experience uC/CPU.  The fact that the source code is provided
N*               does NOT mean that you can use it without paying a licensing fee.
N*
N*               Knowledge of the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest
N*               software available.  Your honesty is greatly appreciated.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                      CPU CONFIGURATION DEFINES
N*
N* Filename      : cpu_def.h
N* Version       : V1.19
N* Programmer(s) : ITJ
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                       CPU WORD CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_ADDR_SIZE & CPU_CFG_DATA_SIZE in 'cpu.h' with CPU's word sizes :
N*
N*                   CPU_WORD_SIZE_08             8-bit word size
N*                   CPU_WORD_SIZE_16            16-bit word size
N*                   CPU_WORD_SIZE_32            32-bit word size
N*                   CPU_WORD_SIZE_64            64-bit word size            See Note #1a
N*
N*               (a) 64-bit word size NOT currently supported.
N*
N*               (b) Ideally, CPU_WORD_SIZE #define's would be calculated at compile-time through use of
N*                   the sizeof() operator.  However, some compilers do NOT allow pre-processor directives
N*                   to include run-time macro's -- e.g. 'sizeof()'.
N*
N*           (2) Configure CPU_CFG_ENDIAN_TYPE in 'cpu.h' with CPU's data-word-memory order :
N*
N*                   CPU_ENDIAN_TYPE_BIG         Big-   endian word order (CPU words' most  significant
N*                                                                         octet @ lowest memory address)
N*                   CPU_ENDIAN_TYPE_LITTLE      Little-endian word order (CPU words' least significant
N*                                                                         octet @ lowest memory address)
N*********************************************************************************************************
N*/
N
N                                                        /* ----------------------- CPU WORD SIZE ---------------------- */
N#define  CPU_WORD_SIZE_08                          1    /*  8-bit word size = sizeof(CPU_INT08x).                       */
N#define  CPU_WORD_SIZE_16                          2    /* 16-bit word size = sizeof(CPU_INT16x).                       */
N#define  CPU_WORD_SIZE_32                          4    /* 32-bit word size = sizeof(CPU_INT32x).                       */
N#define  CPU_WORD_SIZE_64                          8    /* 64-bit word size = sizeof(CPU_INT64x) [see Note #1a].        */
N
N
N                                                        /* ------------------- CPU WORD-ENDIAN ORDER ------------------ */
N#define  CPU_ENDIAN_TYPE_NONE                      0    /*                                                              */
N#define  CPU_ENDIAN_TYPE_BIG                       1    /* Big-   endian word order (CPU words' most  significant ...   */
N                                                        /*                           ... octet @ lowest mem addr).      */
N#define  CPU_ENDIAN_TYPE_LITTLE                    2    /* Little-endian word order (CPU words' least significant ...   */
N                                                        /*                           ... octet @ lowest mem addr).      */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                   CRITICAL SECTION CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_CRITICAL_METHOD with CPU's/compiler's critical section method :
N*
N*                                                       Enter/Exit critical sections by ...
N*
N*                   CPU_CRITICAL_METHOD_INT_DIS_EN      Disable/Enable interrupts
N*                   CPU_CRITICAL_METHOD_STATUS_STK      Push/Pop       interrupt status onto stack
N*                   CPU_CRITICAL_METHOD_STATUS_LOCAL    Save/Restore   interrupt status to local variable
N*
N*               (a) CPU_CRITICAL_METHOD_INT_DIS_EN  is NOT a preferred method since it does NOT support
N*                   multiple levels of interrupts.  However, with some CPUs/compilers, this is the only
N*                   available method.
N*
N*               (b) CPU_CRITICAL_METHOD_STATUS_STK    is one preferred method since it DOES support multiple
N*                   levels of interrupts.  However, this method assumes that the compiler allows in-line
N*                   assembly AND will correctly modify the local stack pointer when interrupt status is
N*                   pushed/popped onto the stack.
N*
N*               (c) CPU_CRITICAL_METHOD_STATUS_LOCAL  is one preferred method since it DOES support multiple
N*                   levels of interrupts.  However, this method assumes that the compiler provides C-level
N*                   &/or assembly-level functionality for the following :
N*
N*                     ENTER CRITICAL SECTION :
N*                       (a) Save    interrupt status into a local variable
N*                       (b) Disable interrupts
N*
N*                     EXIT  CRITICAL SECTION :
N*                       (c) Restore interrupt status from a local variable
N*
N*           (2) Critical section macro's most likely require inline assembly.  If the compiler does NOT
N*               allow inline assembly in C source files, critical section macro's MUST call an assembly
N*               subroutine defined in a 'cpu_a.asm' file located in the following software directory :
N*
N*                   \<CPU-Compiler Directory>\<cpu>\<compiler>\
N*
X
N*                       where
N*                               <CPU-Compiler Directory>    directory path for common   CPU-compiler software
N*                               <cpu>                       directory name for specific CPU
N*                               <compiler>                  directory name for specific compiler
N*
N*           (3) To save/restore interrupt status, a local variable 'cpu_sr' of type 'CPU_SR' MAY need to
N*               be declared (e.g. if 'CPU_CRITICAL_METHOD_STATUS_LOCAL' method is configured).  Configure
N*               'CPU_SR' data type in 'cpu.h' with the appropriate-sized CPU data type large enough to
N*               completely store the CPU's/compiler's status word.
N*********************************************************************************************************
N*/
N
N                                                        /* --------------- CPU CRITICAL SECTION METHODS --------------- */
N#define  CPU_CRITICAL_METHOD_NONE                  0    /*                                                              */
N#define  CPU_CRITICAL_METHOD_INT_DIS_EN            1    /* DIS/EN       ints.                                           */
N#define  CPU_CRITICAL_METHOD_STATUS_STK            2    /* Push/Pop     int status onto stk.                            */
N#define  CPU_CRITICAL_METHOD_STATUS_LOCAL          3    /* Save/Restore int status to local var.                        */
N
L 74 "..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView\cpu.h" 2
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                    CONFIGURE STANDARD DATA TYPES
N*
N* Note(s) : (1) Configure standard data types according to CPU-/compiler-specifications.
N*
N*           (2) (a) (1) 'CPU_FNCT_VOID' data type defined to replace the commonly-used function pointer
N*                       data type of a pointer to a function which returns void & has no arguments.
N*
N*                   (2) Example function pointer usage :
N*
N*                           CPU_FNCT_VOID  FnctName;
N*
N*                           FnctName();
N*
N*               (b) (1) 'CPU_FNCT_PTR'  data type defined to replace the commonly-used function pointer
N*                       data type of a pointer to a function which returns void & has a single void
N*                       pointer argument.
N*
N*                   (2) Example function pointer usage :
N*
N*                           CPU_FNCT_PTR   FnctName;
N*                           void          *pobj
N*
N*                           FnctName(pobj);
N*********************************************************************************************************
N*/
N
Ntypedef            void       CPU_VOID;
Ntypedef  unsigned  char       CPU_CHAR;                         /*  8-bit character                                     */
Ntypedef  unsigned  char       CPU_BOOLEAN;                      /*  8-bit boolean or logical                            */
Ntypedef  unsigned  char       CPU_INT08U;                       /*  8-bit unsigned integer                              */
Ntypedef    signed  char       CPU_INT08S;                       /*  8-bit   signed integer                              */
Ntypedef  unsigned  short      CPU_INT16U;                       /* 16-bit unsigned integer                              */
Ntypedef    signed  short      CPU_INT16S;                       /* 16-bit   signed integer                              */
Ntypedef  unsigned  int        CPU_INT32U;                       /* 32-bit unsigned integer                              */
Ntypedef    signed  int        CPU_INT32S;                       /* 32-bit   signed integer                              */
Ntypedef  unsigned  long long  CPU_INT64U;                       /* 64-bit unsigned integer                              */
Ntypedef    signed  long long  CPU_INT64S;                       /* 64-bit   signed integer                              */
N
Ntypedef            float      CPU_FP32;                         /* 32-bit floating point                                */
Ntypedef            double     CPU_FP64;                         /* 64-bit floating point                                */
N
N
Ntypedef            void     (*CPU_FNCT_VOID)(void);             /* See Note #2a.                                        */
Ntypedef            void     (*CPU_FNCT_PTR )(void *);           /* See Note #2b.                                        */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                       CPU WORD CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_ADDR_SIZE & CPU_CFG_DATA_SIZE with CPU's word sizes :
N*
N*                   CPU_WORD_SIZE_08             8-bit word size
N*                   CPU_WORD_SIZE_16            16-bit word size
N*                   CPU_WORD_SIZE_32            32-bit word size
N*                   CPU_WORD_SIZE_64            64-bit word size            See Note #1a
N*
N*               (a) 64-bit word size NOT currently supported.
N*
N*           (2) Configure CPU_CFG_ENDIAN_TYPE with CPU's data-word-memory order :
N*
N*                   CPU_ENDIAN_TYPE_BIG         Big-   endian word order (CPU words' most  significant
N*                                                                         octet @ lowest memory address)
N*                   CPU_ENDIAN_TYPE_LITTLE      Little-endian word order (CPU words' least significant
N*                                                                         octet @ lowest memory address)
N*********************************************************************************************************
N*/
N
N                                                                /* Define  CPU         word sizes (see Note #1) :       */
N#define  CPU_CFG_ADDR_SIZE              CPU_WORD_SIZE_32        /* Defines CPU address word size.                       */
N
N#define  CPU_CFG_DATA_SIZE              CPU_WORD_SIZE_32        /* Defines CPU data    word size.                       */
N#define  CPU_CFG_ENDIAN_TYPE            CPU_ENDIAN_TYPE_LITTLE  /* Defines CPU data    word-memory order.               */
N
N
N/*
N*********************************************************************************************************
N*                                 CONFIGURE CPU ADDRESS & DATA TYPES
N*********************************************************************************************************
N*/
N
N                                                                /* CPU address type based on address bus size.          */
N#if     (CPU_CFG_ADDR_SIZE == CPU_WORD_SIZE_32)
X#if     (4 == 4)
Ntypedef  CPU_INT32U  CPU_ADDR;
N#elif   (CPU_CFG_ADDR_SIZE == CPU_WORD_SIZE_16)
Stypedef  CPU_INT16U  CPU_ADDR;
S#else
Stypedef  CPU_INT08U  CPU_ADDR;
N#endif
N
N                                                                /* CPU data    type based on data    bus size.          */
N#if     (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_32)
X#if     (4 == 4)
Ntypedef  CPU_INT32U  CPU_DATA;
N#elif   (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_16)
Stypedef  CPU_INT16U  CPU_DATA;
S#else
Stypedef  CPU_INT08U  CPU_DATA;
N#endif
N
N
Ntypedef  CPU_DATA    CPU_ALIGN;                                 /* Defines CPU data-word-alignment size.                */
Ntypedef  CPU_DATA    CPU_SIZE_T;                                /* Defines CPU standard 'size_t'   size.                */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                   CRITICAL SECTION CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_CRITICAL_METHOD with CPU's/compiler's critical section method :
N*
N*                                                       Enter/Exit critical sections by ...
N*
N*                   CPU_CRITICAL_METHOD_INT_DIS_EN      Disable/Enable interrupts
N*                   CPU_CRITICAL_METHOD_STATUS_STK      Push/Pop       interrupt status onto stack
N*                   CPU_CRITICAL_METHOD_STATUS_LOCAL    Save/Restore   interrupt status to local variable
N*
N*               (a) CPU_CRITICAL_METHOD_INT_DIS_EN  is NOT a preferred method since it does NOT support
N*                   multiple levels of interrupts.  However, with some CPUs/compilers, this is the only
N*                   available method.
N*
N*               (b) CPU_CRITICAL_METHOD_STATUS_STK    is one preferred method since it DOES support multiple
N*                   levels of interrupts.  However, this method assumes that the compiler allows in-line
N*                   assembly AND will correctly modify the local stack pointer when interrupt status is
N*                   pushed/popped onto the stack.
N*
N*               (c) CPU_CRITICAL_METHOD_STATUS_LOCAL  is one preferred method since it DOES support multiple
N*                   levels of interrupts.  However, this method assumes that the compiler provides C-level
N*                   &/or assembly-level functionality for the following :
N*
N*                     ENTER CRITICAL SECTION :
N*                       (a) Save    interrupt status into a local variable
N*                       (b) Disable interrupts
N*
N*                     EXIT  CRITICAL SECTION :
N*                       (c) Restore interrupt status from a local variable
N*
N*           (2) Critical section macro's most likely require inline assembly.  If the compiler does NOT
N*               allow inline assembly in C source files, critical section macro's MUST call an assembly
N*               subroutine defined in a 'cpu_a.asm' file located in the following software directory :
N*
N*                   \<CPU-Compiler Directory>\<cpu>\<compiler>\
N*
X
N*                       where
N*                               <CPU-Compiler Directory>    directory path for common   CPU-compiler software
N*                               <cpu>                       directory name for specific CPU
N*                               <compiler>                  directory name for specific compiler
N*
N*           (3) To save/restore interrupt status, a local variable 'cpu_sr' of type 'CPU_SR' MAY need to
N*               be declared (e.g. if 'CPU_CRITICAL_METHOD_STATUS_LOCAL' method is configured).  Configure
N*               'CPU_SR' data type with the appropriate-sized CPU data type large enough to completely
N*               store the CPU's/compiler's status word.
N*********************************************************************************************************
N*/
N
Ntypedef  CPU_INT32U  CPU_SR;                                    /* Defines   CPU status register size (see Note #3).    */
N
N                                                                /* Configure CPU critical method      (see Note #1) :   */
N#define  CPU_CFG_CRITICAL_METHOD        CPU_CRITICAL_METHOD_STATUS_LOCAL
N
N#define  CPU_CRITICAL_ENTER()           { cpu_sr = CPU_SR_Save(); }
N#define  CPU_CRITICAL_EXIT()            { CPU_SR_Restore(cpu_sr); }
N
N
N/*
N*********************************************************************************************************
N*                                         FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
Nvoid        CPU_IntDis       (void);
Nvoid        CPU_IntEn        (void);
N
Nvoid        CPU_IntSrcDis    (CPU_INT08U  pos);
Nvoid        CPU_IntSrcEn     (CPU_INT08U  pos);
NCPU_INT16S  CPU_IntSrcPrioGet(CPU_INT08U  pos);
Nvoid        CPU_IntSrcPrioSet(CPU_INT08U  pos,
N                              CPU_INT08U  prio);
N
NCPU_SR      CPU_SR_Save      (void);
Nvoid        CPU_SR_Restore   (CPU_SR      cpu_sr);
N
NCPU_INT32U  CPU_CntLeadZeros (CPU_INT32U  val);
NCPU_INT32U  CPU_RevBits      (CPU_INT32U  val);
N
Nvoid        CPU_WaitForInt   (void);
Nvoid        CPU_WaitForExcept(void);
N
Nvoid        CPU_BitBandClr   (CPU_ADDR    addr,
N                              CPU_INT08U  bit_nbr);
Nvoid        CPU_BitBandSet   (CPU_ADDR    addr,
N                              CPU_INT08U  bit_nbr);
N
N/*
N*********************************************************************************************************
N*                                           INTERRUPT SOURCES
N*********************************************************************************************************
N*/
N
N#define  CPU_INT_STK_PTR                                   0
N#define  CPU_INT_RESET                                     1
N#define  CPU_INT_NMI                                       2
N#define  CPU_INT_HFAULT                                    3
N#define  CPU_INT_MEM                                       4
N#define  CPU_INT_BUSFAULT                                  5
N#define  CPU_INT_USAGEFAULT                                6
N#define  CPU_INT_RSVD_07                                   7
N#define  CPU_INT_RSVD_08                                   8
N#define  CPU_INT_RSVD_09                                   9
N#define  CPU_INT_RSVD_10                                  10
N#define  CPU_INT_SVCALL                                   11
N#define  CPU_INT_DBGMON                                   12
N#define  CPU_INT_RSVD_13                                  13
N#define  CPU_INT_PENDSV                                   14
N#define  CPU_INT_SYSTICK                                  15
N
N
N/*
N*********************************************************************************************************
N*                                             CPU REGISTERS
N*********************************************************************************************************
N*/
N
N#define  CPU_REG_NVIC_NVIC              (*((volatile CPU_INT32U *)(0xE000E004))) /* Int Ctrl'er Type Reg.               */
N#define  CPU_REG_NVIC_ST_CTRL           (*((volatile CPU_INT32U *)(0xE000E010))) /* SysTick Ctrl & Status Reg.          */
N#define  CPU_REG_NVIC_ST_RELOAD         (*((volatile CPU_INT32U *)(0xE000E014))) /* SysTick Reload      Value Reg.      */
N#define  CPU_REG_NVIC_ST_CURRENT        (*((volatile CPU_INT32U *)(0xE000E018))) /* SysTick Current     Value Reg.      */
N#define  CPU_REG_NVIC_ST_CAL            (*((volatile CPU_INT32U *)(0xE000E01C))) /* SysTick Calibration Value Reg.      */
N                                                                                 /* IRQ Set En Reg.                     */
N#define  CPU_REG_NVIC_SETEN(n)          (*((volatile CPU_INT32U *)(0xE000E100 + (n) * 4)))
N                                                                                 /* IRQ Clr En Reg.                     */
N#define  CPU_REG_NVIC_CLREN(n)          (*((volatile CPU_INT32U *)(0xE000E180 + (n) * 4)))
N                                                                                 /* IRQ Set Pending Reg.                */
N#define  CPU_REG_NVIC_SETPEND(n)        (*((volatile CPU_INT32U *)(0xE000E200 + (n) * 4)))
N                                                                                 /* IRQ Clr Pending Reg.                */
N#define  CPU_REG_NVIC_CLRPEND(n)        (*((volatile CPU_INT32U *)(0xE000E280 + (n) * 4)))
N                                                                                 /* IRQ Active Reg.                     */
N#define  CPU_REG_NVIC_ACTIVE(n)         (*((volatile CPU_INT32U *)(0xE000E300 + (n) * 4)))
N                                                                                 /* IRQ Prio Reg.                       */
N#define  CPU_REG_NVIC_PRIO(n)           (*((volatile CPU_INT32U *)(0xE000E400 + (n) * 4)))
N
N#define  CPU_REG_NVIC_CPUID             (*((volatile CPU_INT32U *)(0xE000ED00))) /* CPUID Base Reg.                     */
N#define  CPU_REG_NVIC_ICSR              (*((volatile CPU_INT32U *)(0xE000ED04))) /* Int Ctrl State  Reg.                */
N#define  CPU_REG_NVIC_VTOR              (*((volatile CPU_INT32U *)(0xE000ED08))) /* Vect Tbl Offset Reg.                */
N#define  CPU_REG_NVIC_AIRCR             (*((volatile CPU_INT32U *)(0xE000ED0C))) /* App Int/Reset Ctrl Reg.             */
N#define  CPU_REG_NVIC_SCR               (*((volatile CPU_INT32U *)(0xE000ED10))) /* System Ctrl Reg.                    */
N#define  CPU_REG_NVIC_CCR               (*((volatile CPU_INT32U *)(0xE000ED14))) /* Cfg    Ctrl Reg.                    */
N#define  CPU_REG_NVIC_SHPRI1            (*((volatile CPU_INT32U *)(0xE000ED18))) /* System Handlers  4 to  7 Prio.      */
N#define  CPU_REG_NVIC_SHPRI2            (*((volatile CPU_INT32U *)(0xE000ED1C))) /* System Handlers  8 to 11 Prio.      */
N#define  CPU_REG_NVIC_SHPRI3            (*((volatile CPU_INT32U *)(0xE000ED20))) /* System Handlers 12 to 15 Prio.      */
N#define  CPU_REG_NVIC_SHCSR             (*((volatile CPU_INT32U *)(0xE000ED24))) /* System Handler Ctrl & State Reg.    */
N#define  CPU_REG_NVIC_CFSR              (*((volatile CPU_INT32U *)(0xE000ED28))) /* Configurable Fault Status Reg.      */
N#define  CPU_REG_NVIC_HFSR              (*((volatile CPU_INT32U *)(0xE000ED2C))) /* Hard  Fault Status Reg.             */
N#define  CPU_REG_NVIC_DFSR              (*((volatile CPU_INT32U *)(0xE000ED30))) /* Debug Fault Status Reg.             */
N#define  CPU_REG_NVIC_MMFAR             (*((volatile CPU_INT32U *)(0xE000ED34))) /* Mem Manage Addr Reg.                */
N#define  CPU_REG_NVIC_BFAR              (*((volatile CPU_INT32U *)(0xE000ED38))) /* Bus Fault  Addr Reg.                */
N#define  CPU_REG_NVIC_AFSR              (*((volatile CPU_INT32U *)(0xE000ED3C))) /* Aux Fault Status Reg.               */
N
N#define  CPU_REG_NVIC_PFR0              (*((volatile CPU_INT32U *)(0xE000ED40))) /* Processor Feature Reg 0.            */
N#define  CPU_REG_NVIC_PFR1              (*((volatile CPU_INT32U *)(0xE000ED44))) /* Processor Feature Reg 1.            */
N#define  CPU_REG_NVIC_DFR0              (*((volatile CPU_INT32U *)(0xE000ED48))) /* Debug     Feature Reg 0.            */
N#define  CPU_REG_NVIC_AFR0              (*((volatile CPU_INT32U *)(0xE000ED4C))) /* Aux       Feature Reg 0.            */
N#define  CPU_REG_NVIC_MMFR0             (*((volatile CPU_INT32U *)(0xE000ED50))) /* Memory Model Feature Reg 0.         */
N#define  CPU_REG_NVIC_MMFR1             (*((volatile CPU_INT32U *)(0xE000ED54))) /* Memory Model Feature Reg 1.         */
N#define  CPU_REG_NVIC_MMFR2             (*((volatile CPU_INT32U *)(0xE000ED58))) /* Memory Model Feature Reg 2.         */
N#define  CPU_REG_NVIC_MMFR3             (*((volatile CPU_INT32U *)(0xE000ED5C))) /* Memory Model Feature Reg 3.         */
N#define  CPU_REG_NVIC_ISAFR0            (*((volatile CPU_INT32U *)(0xE000ED60))) /* ISA Feature Reg 0.                  */
N#define  CPU_REG_NVIC_ISAFR1            (*((volatile CPU_INT32U *)(0xE000ED64))) /* ISA Feature Reg 1.                  */
N#define  CPU_REG_NVIC_ISAFR2            (*((volatile CPU_INT32U *)(0xE000ED68))) /* ISA Feature Reg 2.                  */
N#define  CPU_REG_NVIC_ISAFR3            (*((volatile CPU_INT32U *)(0xE000ED6C))) /* ISA Feature Reg 3.                  */
N#define  CPU_REG_NVIC_ISAFR4            (*((volatile CPU_INT32U *)(0xE000ED70))) /* ISA Feature Reg 4.                  */
N#define  CPU_REG_NVIC_SW_TRIG           (*((volatile CPU_INT32U *)(0xE000EF00))) /* Software Trigger Int Reg.           */
N
N#define  CPU_REG_MPU_TYPE               (*((volatile CPU_INT32U *)(0xE000ED90))) /* MPU Type Reg.                       */
N#define  CPU_REG_MPU_CTRL               (*((volatile CPU_INT32U *)(0xE000ED94))) /* MPU Ctrl Reg.                       */
N#define  CPU_REG_MPU_REG_NBR            (*((volatile CPU_INT32U *)(0xE000ED98))) /* MPU Region Nbr Reg.                 */
N#define  CPU_REG_MPU_REG_BASE           (*((volatile CPU_INT32U *)(0xE000ED9C))) /* MPU Region Base Addr Reg.           */
N#define  CPU_REG_MPU_REG_ATTR           (*((volatile CPU_INT32U *)(0xE000EDA0))) /* MPU Region Attrib & Size Reg.       */
N
N#define  CPU_REG_DBG_CTRL               (*((volatile CPU_INT32U *)(0xE000EDF0))) /* Debug Halting Ctrl & Status Reg.    */
N#define  CPU_REG_DBG_SELECT             (*((volatile CPU_INT32U *)(0xE000EDF4))) /* Debug Core Reg Selector Reg.        */
N#define  CPU_REG_DBG_DATA               (*((volatile CPU_INT32U *)(0xE000EDF8))) /* Debug Core Reg Data     Reg.        */
N#define  CPU_REG_DBG_INT                (*((volatile CPU_INT32U *)(0xE000EDFC))) /* Debug Except & Monitor Ctrl Reg.    */
N
N/*
N*********************************************************************************************************
N*                                          CPU REGISTER BITS
N*********************************************************************************************************
N*/
N
N                                                                /* ---------- SYSTICK CTRL & STATUS REG BITS ---------- */
N#define  CPU_REG_NVIC_ST_CTRL_COUNTFLAG         DEF_BIT_16
N#define  CPU_REG_NVIC_ST_CTRL_CLKSOURCE         DEF_BIT_02
N#define  CPU_REG_NVIC_ST_CTRL_TICKINT           DEF_BIT_01
N#define  CPU_REG_NVIC_ST_CTRL_ENABLE            DEF_BIT_00
N
N
N                                                                /* -------- SYSTICK CALIBRATION VALUE REG BITS -------- */
N#define  CPU_REG_NVIC_ST_CAL_NOREF              DEF_BIT_31
N#define  CPU_REG_NVIC_ST_CAL_SKEW               DEF_BIT_30
N
N                                                                /* -------------- INT CTRL STATE REG BITS ------------- */
N#define  CPU_REG_NVIC_ICSR_NMIPENDSET           DEF_BIT_31
N#define  CPU_REG_NVIC_ICSR_PENDSVSET            DEF_BIT_28
N#define  CPU_REG_NVIC_ICSR_PENDSVCLR            DEF_BIT_27
N#define  CPU_REG_NVIC_ICSR_PENDSTSET            DEF_BIT_26
N#define  CPU_REG_NVIC_ICSR_PENDSTCLR            DEF_BIT_25
N#define  CPU_REG_NVIC_ICSR_ISRPREEMPT           DEF_BIT_23
N#define  CPU_REG_NVIC_ICSR_ISRPENDING           DEF_BIT_22
N#define  CPU_REG_NVIC_ICSR_RETTOBASE            DEF_BIT_11
N
N                                                                /* ------------- VECT TBL OFFSET REG BITS ------------- */
N#define  CPU_REG_NVIC_VTOR_TBLBASE              DEF_BIT_29
N
N                                                                /* ------------ APP INT/RESET CTRL REG BITS ----------- */
N#define  CPU_REG_NVIC_AIRCR_ENDIANNESS          DEF_BIT_15
N#define  CPU_REG_NVIC_AIRCR_SYSRESETREQ         DEF_BIT_02
N#define  CPU_REG_NVIC_AIRCR_VECTCLRACTIVE       DEF_BIT_01
N#define  CPU_REG_NVIC_AIRCR_VECTRESET           DEF_BIT_00
N
N                                                                /* --------------- SYSTEM CTRL REG BITS --------------- */
N#define  CPU_REG_NVIC_SCR_SEVONPEND             DEF_BIT_04
N#define  CPU_REG_NVIC_SCR_SLEEPDEEP             DEF_BIT_02
N#define  CPU_REG_NVIC_SCR_SLEEPONEXIT           DEF_BIT_01
N
N                                                                /* ----------------- CFG CTRL REG BITS ---------------- */
N#define  CPU_REG_NVIC_CCR_STKALIGN              DEF_BIT_09
N#define  CPU_REG_NVIC_CCR_BFHFNMIGN             DEF_BIT_08
N#define  CPU_REG_NVIC_CCR_DIV_0_TRP             DEF_BIT_04
N#define  CPU_REG_NVIC_CCR_UNALIGN_TRP           DEF_BIT_03
N#define  CPU_REG_NVIC_CCR_USERSETMPEND          DEF_BIT_01
N#define  CPU_REG_NVIC_CCR_NONBASETHRDENA        DEF_BIT_00
N
N                                                                /* ------- SYSTEM HANDLER CTRL & STATE REG BITS ------- */
N#define  CPU_REG_NVIC_SHCSR_USGFAULTENA         DEF_BIT_18
N#define  CPU_REG_NVIC_SHCSR_BUSFAULTENA         DEF_BIT_17
N#define  CPU_REG_NVIC_SHCSR_MEMFAULTENA         DEF_BIT_16
N#define  CPU_REG_NVIC_SHCSR_SVCALLPENDED        DEF_BIT_15
N#define  CPU_REG_NVIC_SHCSR_BUSFAULTPENDED      DEF_BIT_14
N#define  CPU_REG_NVIC_SHCSR_MEMFAULTPENDED      DEF_BIT_13
N#define  CPU_REG_NVIC_SHCSR_USGFAULTPENDED      DEF_BIT_12
N#define  CPU_REG_NVIC_SHCSR_SYSTICKACT          DEF_BIT_11
N#define  CPU_REG_NVIC_SHCSR_PENDSVACT           DEF_BIT_10
N#define  CPU_REG_NVIC_SHCSR_MONITORACT          DEF_BIT_08
N#define  CPU_REG_NVIC_SHCSR_SVCALLACT           DEF_BIT_07
N#define  CPU_REG_NVIC_SHCSR_USGFAULTACT         DEF_BIT_03
N#define  CPU_REG_NVIC_SHCSR_BUSFAULTACT         DEF_BIT_01
N#define  CPU_REG_NVIC_SHCSR_MEMFAULTACT         DEF_BIT_00
N
N                                                                /* -------- CONFIGURABLE FAULT STATUS REG BITS -------- */
N#define  CPU_REG_NVIC_CFSR_DIVBYZERO            DEF_BIT_25
N#define  CPU_REG_NVIC_CFSR_UNALIGNED            DEF_BIT_24
N#define  CPU_REG_NVIC_CFSR_NOCP                 DEF_BIT_19
N#define  CPU_REG_NVIC_CFSR_INVPC                DEF_BIT_18
N#define  CPU_REG_NVIC_CFSR_INVSTATE             DEF_BIT_17
N#define  CPU_REG_NVIC_CFSR_UNDEFINSTR           DEF_BIT_16
N#define  CPU_REG_NVIC_CFSR_BFARVALID            DEF_BIT_15
N#define  CPU_REG_NVIC_CFSR_STKERR               DEF_BIT_12
N#define  CPU_REG_NVIC_CFSR_UNSTKERR             DEF_BIT_11
N#define  CPU_REG_NVIC_CFSR_IMPRECISERR          DEF_BIT_10
N#define  CPU_REG_NVIC_CFSR_PRECISERR            DEF_BIT_09
N#define  CPU_REG_NVIC_CFSR_IBUSERR              DEF_BIT_08
N#define  CPU_REG_NVIC_CFSR_MMARVALID            DEF_BIT_07
N#define  CPU_REG_NVIC_CFSR_MSTKERR              DEF_BIT_04
N#define  CPU_REG_NVIC_CFSR_MUNSTKERR            DEF_BIT_03
N#define  CPU_REG_NVIC_CFSR_DACCVIOL             DEF_BIT_01
N#define  CPU_REG_NVIC_CFSR_IACCVIOL             DEF_BIT_00
N
N                                                                /* ------------ HARD FAULT STATUS REG BITS ------------ */
N#define  CPU_REG_NVIC_HFSR_DEBUGEVT             DEF_BIT_31
N#define  CPU_REG_NVIC_HFSR_FORCED               DEF_BIT_30
N#define  CPU_REG_NVIC_HFSR_VECTTBL              DEF_BIT_01
N
N                                                                /* ------------ DEBUG FAULT STATUS REG BITS ----------- */
N#define  CPU_REG_NVIC_DFSR_EXTERNAL             DEF_BIT_04
N#define  CPU_REG_NVIC_DFSR_VCATCH               DEF_BIT_03
N#define  CPU_REG_NVIC_DFSR_DWTTRAP              DEF_BIT_02
N#define  CPU_REG_NVIC_DFSR_BKPT                 DEF_BIT_01
N#define  CPU_REG_NVIC_DFSR_HALTED               DEF_BIT_00
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N#ifndef   CPU_CFG_ADDR_SIZE
S#error   "CPU_CFG_ADDR_SIZE              not #define'd in 'cpu.h'               "
S#error   "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error   "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error   "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
S
S#elif   ((CPU_CFG_ADDR_SIZE != CPU_WORD_SIZE_08) && \
S         (CPU_CFG_ADDR_SIZE != CPU_WORD_SIZE_16) && \
S         (CPU_CFG_ADDR_SIZE != CPU_WORD_SIZE_32))
X#elif   ((4 != 1) &&          (4 != 2) &&          (4 != 4))
S#error   "CPU_CFG_ADDR_SIZE        illegally #define'd in 'cpu.h'               "
S#error   "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error   "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error   "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
N#endif
N
N
N#ifndef   CPU_CFG_DATA_SIZE
S#error   "CPU_CFG_DATA_SIZE              not #define'd in 'cpu.h'               "
S#error   "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error   "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error   "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
S
S#elif   ((CPU_CFG_DATA_SIZE != CPU_WORD_SIZE_08) && \
S         (CPU_CFG_DATA_SIZE != CPU_WORD_SIZE_16) && \
S         (CPU_CFG_DATA_SIZE != CPU_WORD_SIZE_32))
X#elif   ((4 != 1) &&          (4 != 2) &&          (4 != 4))
S#error   "CPU_CFG_DATA_SIZE        illegally #define'd in 'cpu.h'               "
S#error   "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error   "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error   "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
N#endif
N
N
N
N#ifndef   CPU_CFG_ENDIAN_TYPE
S#error   "CPU_CFG_ENDIAN_TYPE            not #define'd in 'cpu.h'   "
S#error   "                         [MUST be  CPU_ENDIAN_TYPE_BIG   ]"
S#error   "                         [     ||  CPU_ENDIAN_TYPE_LITTLE]"
S
S#elif   ((CPU_CFG_ENDIAN_TYPE != CPU_ENDIAN_TYPE_BIG   ) && \
S         (CPU_CFG_ENDIAN_TYPE != CPU_ENDIAN_TYPE_LITTLE))
X#elif   ((2 != 1   ) &&          (2 != 2))
S#error   "CPU_CFG_ENDIAN_TYPE      illegally #define'd in 'cpu.h'   "
S#error   "                         [MUST be  CPU_ENDIAN_TYPE_BIG   ]"
S#error   "                         [     ||  CPU_ENDIAN_TYPE_LITTLE]"
N#endif
N
N
N
N
N#ifndef   CPU_CFG_CRITICAL_METHOD
S#error   "CPU_CFG_CRITICAL_METHOD        not #define'd in 'cpu.h'             "
S#error   "                         [MUST be  CPU_CRITICAL_METHOD_INT_DIS_EN  ]"
S#error   "                         [     ||  CPU_CRITICAL_METHOD_STATUS_STK  ]"
S#error   "                         [     ||  CPU_CRITICAL_METHOD_STATUS_LOCAL]"
S
S#elif   ((CPU_CFG_CRITICAL_METHOD != CPU_CRITICAL_METHOD_INT_DIS_EN  ) && \
S         (CPU_CFG_CRITICAL_METHOD != CPU_CRITICAL_METHOD_STATUS_STK  ) && \
S         (CPU_CFG_CRITICAL_METHOD != CPU_CRITICAL_METHOD_STATUS_LOCAL))
X#elif   ((3 != 1  ) &&          (3 != 2  ) &&          (3 != 3))
S#error   "CPU_CFG_CRITICAL_METHOD  illegally #define'd in 'cpu.h'             "
S#error   "                         [MUST be  CPU_CRITICAL_METHOD_INT_DIS_EN  ]"
S#error   "                         [     ||  CPU_CRITICAL_METHOD_STATUS_STK  ]"
S#error   "                         [     ||  CPU_CRITICAL_METHOD_STATUS_LOCAL]"
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of CPU cfg module inclusion.                     */
L 95 "..\..\..\..\..\uC-LIB\lib_str.h" 2
N#include  <lib_def.h>
L 1 "..\..\..\..\..\uC-LIB\lib_def.h" 1
N/*
N*********************************************************************************************************
N*                                               uC/LIB
N*                                       CUSTOM LIBRARY MODULES
N*
N*                          (c) Copyright 2004-2008; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/LIB is provided in source form for FREE evaluation, for educational
N*               use or peaceful research.  If you plan on using uC/LIB in a commercial
N*               product you need to contact Micrium to properly license its use in your
N*               product.  We provide ALL the source code for your convenience and to
N*               help you experience uC/LIB.  The fact that the source code is provided
N*               does NOT mean that you can use it without paying a licensing fee.
N*
N*               Knowledge of the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest
N*               software available.  Your honesty is greatly appreciated.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                     CORE CUSTOM LIBRARY MODULE
N*
N* Filename      : lib_def.h
N* Version       : V1.25
N* Programmer(s) : ITJ
N*********************************************************************************************************
N* Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
N*
N*                     (a) ALL standard library functions are implemented in the custom library modules :
N*
N*                         (1) \<Custom Library Directory>\lib*.*
N*
N*                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
N*
N*                               where
N*                                       <Custom Library Directory>      directory path for custom library software
N*                                       <cpu>                           directory name for specific processor (CPU)
N*                                       <compiler>                      directory name for specific compiler
N*
N*                     (b) Product-specific library functions are implemented in individual products.
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_DEF_MODULE_PRESENT
N#define  LIB_DEF_MODULE_PRESENT
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                CUSTOM LIBRARY MODULE VERSION NUMBER
N*
N* Note(s) : (1) (a) The custom library module software version is denoted as follows :
N*
N*                       Vx.yy
N*
N*                           where
N*                                   V               denotes 'Version' label
N*                                   x               denotes major software version revision number
N*                                   yy              denotes minor software version revision number
N*
N*               (b) The software version label #define is formatted as follows :
N*
N*                       ver = x.yy * 100
N*
N*                           where
N*                                   ver             denotes software version number scaled as an integer value
N*                                   x.yy            denotes software version number
N*********************************************************************************************************
N*/
N
N#define  LIB_VERSION                                     124u   /* See Note #1.                                         */
N
N
N/*
N*********************************************************************************************************
N*                                            INCLUDE FILES
N*
N* Note(s) : (1) The following common software files are located in the following directories :
N*
N*               (a) \<Custom Library Directory>\lib*.*
N*
N*               (b) (1) \<CPU-Compiler Directory>\cpu_def.h
N*
N*                   (2) \<CPU-Compiler Directory>\<cpu>\<compiler>\cpu*.*
N*
N*                           where
N*                                   <Custom Library Directory>      directory path for custom   library      software
N*                                   <CPU-Compiler Directory>        directory path for common   CPU-compiler software
N*                                   <cpu>                           directory name for specific processor (CPU)
N*                                   <compiler>                      directory name for specific compiler
N*
N*           (2) Compiler MUST be configured to include the '\<Custom Library Directory>\uC-LIB\',
N*               '\<CPU-Compiler Directory>\' directory, & the specific CPU-compiler directory as 
N*               additional include path directories.
N*********************************************************************************************************
N*/
N
N#include  <cpu.h>
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          STANDARD DEFINES
N*********************************************************************************************************
N*/
N
N
N#define  DEF_DISABLED                                      0
N#define  DEF_ENABLED                                       1
N
N#define  DEF_FALSE                                         0
N#define  DEF_TRUE                                          1
N
N#define  DEF_NO                                            0
N#define  DEF_YES                                           1
N
N#define  DEF_OFF                                           0
N#define  DEF_ON                                            1
N
N#define  DEF_CLR                                           0
N#define  DEF_SET                                           1
N
N#define  DEF_ACTIVE                                        0
N#define  DEF_INACTIVE                                      1
N
N#define  DEF_FAIL                                          0
N#define  DEF_OK                                            1
N
N
N                                                                /* -------------------- BIT DEFINES ------------------- */
N#define  DEF_BIT_NONE                                   0x00
N
N#define  DEF_BIT_00                                     0x01
N#define  DEF_BIT_01                                     0x02
N#define  DEF_BIT_02                                     0x04
N#define  DEF_BIT_03                                     0x08
N#define  DEF_BIT_04                                     0x10
N#define  DEF_BIT_05                                     0x20
N#define  DEF_BIT_06                                     0x40
N#define  DEF_BIT_07                                     0x80
N
N#define  DEF_BIT_08                                   0x0100
N#define  DEF_BIT_09                                   0x0200
N#define  DEF_BIT_10                                   0x0400
N#define  DEF_BIT_11                                   0x0800
N#define  DEF_BIT_12                                   0x1000
N#define  DEF_BIT_13                                   0x2000
N#define  DEF_BIT_14                                   0x4000
N#define  DEF_BIT_15                                   0x8000
N
N#define  DEF_BIT_16                               0x00010000
N#define  DEF_BIT_17                               0x00020000
N#define  DEF_BIT_18                               0x00040000
N#define  DEF_BIT_19                               0x00080000
N#define  DEF_BIT_20                               0x00100000
N#define  DEF_BIT_21                               0x00200000
N#define  DEF_BIT_22                               0x00400000
N#define  DEF_BIT_23                               0x00800000
N
N#define  DEF_BIT_24                               0x01000000
N#define  DEF_BIT_25                               0x02000000
N#define  DEF_BIT_26                               0x04000000
N#define  DEF_BIT_27                               0x08000000
N#define  DEF_BIT_28                               0x10000000
N#define  DEF_BIT_29                               0x20000000
N#define  DEF_BIT_30                               0x40000000
N#define  DEF_BIT_31                               0x80000000
N
N                                                                /* ------------------- OCTET DEFINES ------------------ */
N#define  DEF_OCTET_NBR_BITS                                8
N#define  DEF_OCTET_MASK                                 0xFF
N
N#define  DEF_NIBBLE_NBR_BITS                               4
N#define  DEF_NIBBLE_MASK                                0x0F
N
N
N/*$PAGE*/
N                                                                /* ------------------ INTEGER DEFINES ----------------- */
N#define  DEF_INT_08_NBR_BITS                               8
N#define  DEF_INT_08_MASK                                0xFF
N                                                            
N#define  DEF_INT_08U_MIN_VAL                               0u
N#define  DEF_INT_08U_MAX_VAL                             255u
N
N#define  DEF_INT_08S_MIN_VAL                            -128
N#define  DEF_INT_08S_MAX_VAL                             127
N
N#define  DEF_INT_08S_MIN_VAL_ONES_CPL                   -127
N#define  DEF_INT_08S_MAX_VAL_ONES_CPL                    127
N
N
N#define  DEF_INT_16_NBR_BITS                              16
N#define  DEF_INT_16_MASK                              0xFFFF
N                                                            
N#define  DEF_INT_16U_MIN_VAL                               0u
N#define  DEF_INT_16U_MAX_VAL                           65535u
N
N#define  DEF_INT_16S_MIN_VAL                          -32768
N#define  DEF_INT_16S_MAX_VAL                           32767
N
N#define  DEF_INT_16S_MIN_VAL_ONES_CPL                 -32767
N#define  DEF_INT_16S_MAX_VAL_ONES_CPL                  32767
N
N
N#define  DEF_INT_32_NBR_BITS                              32
N#define  DEF_INT_32_MASK                          0xFFFFFFFF
N                                                            
N#define  DEF_INT_32U_MIN_VAL                               0u
N#define  DEF_INT_32U_MAX_VAL                      4294967295u
N
N#define  DEF_INT_32S_MIN_VAL                     -2147483648
N#define  DEF_INT_32S_MAX_VAL                      2147483647
N
N#define  DEF_INT_32S_MIN_VAL_ONES_CPL            -2147483647
N#define  DEF_INT_32S_MAX_VAL_ONES_CPL             2147483647
N
N
N#define  DEF_INT_64_NBR_BITS                              64
N#define  DEF_INT_64_MASK                  0xFFFFFFFFFFFFFFFF
N                                                            
N#define  DEF_INT_64U_MIN_VAL                               0u
N#define  DEF_INT_64U_MAX_VAL            18446744073709551615u
N
N#define  DEF_INT_64S_MIN_VAL            -9223372036854775808
N#define  DEF_INT_64S_MAX_VAL             9223372036854775807
N
N#define  DEF_INT_64S_MIN_VAL_ONES_CPL   -9223372036854775807
N#define  DEF_INT_64S_MAX_VAL_ONES_CPL    9223372036854775807
N
N
N/*$PAGE*/
N                                                                /* ---------------- CPU INTEGER DEFINES --------------- */
N#define  DEF_INT_CPU_NBR_BITS                           (CPU_CFG_DATA_SIZE * DEF_OCTET_NBR_BITS)
N
N
N#if     (DEF_INT_CPU_NBR_BITS == DEF_INT_08_NBR_BITS)
X#if     ((4 * 8) == 8)
S
S#define  DEF_INT_CPU_MASK                                DEF_INT_08_MASK
S                                                                   
S#define  DEF_INT_CPU_U_MIN_VAL                           DEF_INT_08U_MIN_VAL
S#define  DEF_INT_CPU_U_MAX_VAL                           DEF_INT_08U_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL                           DEF_INT_08S_MIN_VAL
S#define  DEF_INT_CPU_S_MAX_VAL                           DEF_INT_08S_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL_ONES_CPL                  DEF_INT_08S_MIN_VAL_ONES_CPL
S#define  DEF_INT_CPU_S_MAX_VAL_ONES_CPL                  DEF_INT_08S_MAX_VAL_ONES_CPL
S
S
S#elif   (DEF_INT_CPU_NBR_BITS == DEF_INT_16_NBR_BITS)
X#elif   ((4 * 8) == 16)
S
S#define  DEF_INT_CPU_MASK                                DEF_INT_16_MASK
S                                                                   
S#define  DEF_INT_CPU_U_MIN_VAL                           DEF_INT_16U_MIN_VAL
S#define  DEF_INT_CPU_U_MAX_VAL                           DEF_INT_16U_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL                           DEF_INT_16S_MIN_VAL
S#define  DEF_INT_CPU_S_MAX_VAL                           DEF_INT_16S_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL_ONES_CPL                  DEF_INT_16S_MIN_VAL_ONES_CPL
S#define  DEF_INT_CPU_S_MAX_VAL_ONES_CPL                  DEF_INT_16S_MAX_VAL_ONES_CPL
S
S
N#elif   (DEF_INT_CPU_NBR_BITS == DEF_INT_32_NBR_BITS)
X#elif   ((4 * 8) == 32)
N
N#define  DEF_INT_CPU_MASK                                DEF_INT_32_MASK
N                                                    
N#define  DEF_INT_CPU_U_MIN_VAL                           DEF_INT_32U_MIN_VAL
N#define  DEF_INT_CPU_U_MAX_VAL                           DEF_INT_32U_MAX_VAL
N
N#define  DEF_INT_CPU_S_MIN_VAL                           DEF_INT_32S_MIN_VAL
N#define  DEF_INT_CPU_S_MAX_VAL                           DEF_INT_32S_MAX_VAL
N
N#define  DEF_INT_CPU_S_MIN_VAL_ONES_CPL                  DEF_INT_32S_MIN_VAL_ONES_CPL
N#define  DEF_INT_CPU_S_MAX_VAL_ONES_CPL                  DEF_INT_32S_MAX_VAL_ONES_CPL
N
N
N#elif   (DEF_INT_CPU_NBR_BITS == DEF_INT_64_NBR_BITS)
S
S#define  DEF_INT_CPU_MASK                                DEF_INT_64_MASK
S                                                                   
S#define  DEF_INT_CPU_U_MIN_VAL                           DEF_INT_64U_MIN_VAL
S#define  DEF_INT_CPU_U_MAX_VAL                           DEF_INT_64U_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL                           DEF_INT_64S_MIN_VAL
S#define  DEF_INT_CPU_S_MAX_VAL                           DEF_INT_64S_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL_ONES_CPL                  DEF_INT_64S_MIN_VAL_ONES_CPL
S#define  DEF_INT_CPU_S_MAX_VAL_ONES_CPL                  DEF_INT_64S_MAX_VAL_ONES_CPL
S                                                      
S
S#else
S
S#error  "CPU_CFG_DATA_SIZE  illegally #defined in 'cpu.h'      "
S#error  "                   [See 'cpu.h  CONFIGURATION ERRORS']"
S
N#endif
N
N
N/*$PAGE*/
N                                                                /* ------------------- TIME DEFINES ------------------- */
N#define  DEF_TIME_NBR_HR_PER_DAY                          24uL
N
N#define  DEF_TIME_NBR_MIN_PER_HR                          60uL
N#define  DEF_TIME_NBR_MIN_PER_DAY                       (DEF_TIME_NBR_MIN_PER_HR  * DEF_TIME_NBR_HR_PER_DAY)
N
N#define  DEF_TIME_NBR_SEC_PER_MIN                         60uL
N#define  DEF_TIME_NBR_SEC_PER_HR                        (DEF_TIME_NBR_SEC_PER_MIN * DEF_TIME_NBR_MIN_PER_HR)
N#define  DEF_TIME_NBR_SEC_PER_DAY                       (DEF_TIME_NBR_SEC_PER_HR  * DEF_TIME_NBR_HR_PER_DAY)
N
N#define  DEF_TIME_NBR_mS_PER_SEC                        1000uL
N#define  DEF_TIME_NBR_uS_PER_SEC                     1000000uL
N#define  DEF_TIME_NBR_nS_PER_SEC                  1000000000uL
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             ERROR CODES
N*
N* Note(s) : (1) All generic library error codes are #define'd in 'lib_def.h';
N*               Any module-specific error codes are #define'd in library module header files.
N*********************************************************************************************************
N*/
N
N#define  LIB_ERR_NONE                                      0
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             DATA TYPES
N*********************************************************************************************************
N*/
N
Ntypedef  CPU_INT16U  LIB_ERR;
N
N
N/*
N*********************************************************************************************************
N*                                          GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             BIT MACRO'S
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                              DEF_BIT()
N*
N* Description : Create bit mask with single, specified bit set.
N*
N* Argument(s) : bit         Bit number of bit to set.
N*
N* Return(s)   : Bit mask with single, specified bit set.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'bit' values that overflow the target CPU &/or compiler environment (e.g. negative
N*                   or greater-than-CPU-data-size values) MAY generate compiler warnings &/or errors.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT(bit)                            (1u << (bit))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                           DEF_BIT_MASK()
N*
N* Description : Shift a bit mask.
N*
N* Argument(s) : bit_mask    Bit mask to shift.
N*
N*               bit_shift   Number of bit positions to left-shift bit mask.
N*
N* Return(s)   : Shifted bit mask.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'bit_shift' values that overflow the target CPU &/or compiler environment (e.g. negative
N*                   or greater-than-CPU-data-size values) MAY generate compiler warnings &/or errors.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_MASK(bit_mask, bit_shift)             ((bit_mask)       << (bit_shift))
N
N
N/*
N*********************************************************************************************************
N*                                           DEF_BIT_FIELD()
N*
N* Description : Create & shift a contiguous bit field.
N*
N* Argument(s) : bit_field   Number of contiguous bits to set in the bit field.
N*
N*               bit_shift   Number of bit positions   to left-shift bit field.
N*
N* Return(s)   : Shifted bit field.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'bit_field'/'bit_shift' values that overflow the target CPU &/or compiler environment 
N*                   (e.g. negative or greater-than-CPU-data-size values) MAY generate compiler warnings
N*                   &/or errors.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_FIELD(bit_field, bit_shift)         ((((bit_field) >= DEF_INT_CPU_NBR_BITS) ? (DEF_INT_CPU_U_MAX_VAL)   \
N                                                                                             : (DEF_BIT(bit_field) - 1)) \
N                                                                                                    << (bit_shift))
X#define  DEF_BIT_FIELD(bit_field, bit_shift)         ((((bit_field) >= DEF_INT_CPU_NBR_BITS) ? (DEF_INT_CPU_U_MAX_VAL)                                                                                                : (DEF_BIT(bit_field) - 1))                                                                                                     << (bit_shift))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            DEF_BIT_SET()
N*
N* Description : Set specified bit(s) in a value.
N*
N* Argument(s) : val         Value to modify by setting specified bit(s).
N*
N*               mask        Mask of bits to set.
N*
N* Return(s)   : Modified value with specified bit(s) set.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_SET(val, mask)                       { (val) |=  (mask); }
N
N
N/*
N*********************************************************************************************************
N*                                            DEF_BIT_CLR()
N*
N* Description : Clear specified bit(s) in a value.
N*
N* Argument(s) : val         Value to modify by clearing specified bit(s).
N*
N*               mask        Mask of bits to clear.
N*
N* Return(s)   : Modified value with specified bit(s) clear.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_CLR(val, mask)                       { (val) &= ~(mask); }
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          DEF_BIT_IS_SET()
N*
N* Description : Determine if specified bit(s) in a value are set.
N*
N* Argument(s) : val         Value to check for specified bit(s) set.
N*
N*               mask        Mask of bits to check if set.
N*
N* Return(s)   : DEF_YES, if ALL specified bit(s) are     set in value.
N*     
N*               DEF_NO,	 if ALL specified bit(s) are NOT set in value.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_IS_SET(val, mask)                   ((((val) & (mask)) == (mask)) ? (DEF_YES) : (DEF_NO ))
N
N
N/*
N*********************************************************************************************************
N*                                          DEF_BIT_IS_CLR()
N*
N* Description : Determine if specified bit(s) in a value are clear.
N*
N* Argument(s) : val         Value to check for specified bit(s) clear.
N*
N*               mask        Mask of bits to check if clear.
N*
N* Return(s)   : DEF_YES, if ALL specified bit(s) are     clear in value.
N*     
N*               DEF_NO,	 if ALL specified bit(s) are NOT clear in value.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_IS_CLR(val, mask)                    (((val) & (mask))            ? (DEF_NO ) : (DEF_YES))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        DEF_BIT_IS_SET_ANY()
N*
N* Description : Determine if any specified bit(s) in a value are set.
N*
N* Argument(s) : val         Value to check for specified bit(s) set.
N*
N*               mask        Mask of bits to check if set.
N*
N* Return(s)   : DEF_YES, if ANY specified bit(s) are     set in value.
N*     
N*               DEF_NO,	 if ALL specified bit(s) are NOT set in value.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_IS_SET_ANY(val, mask)                (((val) & (mask))            ? (DEF_YES) : (DEF_NO ))
N
N
N/*
N*********************************************************************************************************
N*                                        DEF_BIT_IS_CLR_ANY()
N*
N* Description : Determine if any specified bit(s) in a value are clear.
N*
N* Argument(s) : val         Value to check for specified bit(s) clear.
N*
N*               mask        Mask of bits to check if clear.
N*
N* Return(s)   : DEF_YES, if ANY specified bit(s) are     clear in value.
N*     
N*               DEF_NO,	 if ALL specified bit(s) are NOT clear in value.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_IS_CLR_ANY(val, mask)               ((((val) & (mask)) != (mask)) ? (DEF_YES) : (DEF_NO ))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            MATH MACRO'S
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                              DEF_MIN()
N*
N* Description : Determine the minimum of two values.
N*
N* Argument(s) : a           First  value.
N*
N*               b           Second value.
N*
N* Return(s)   : Minimum of the two values.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_MIN(a, b)                                  (((a) < (b)) ? (a) : (b))
N
N
N/*
N*********************************************************************************************************
N*                                              DEF_MAX()
N*
N* Description : Determine the maximum of two values.
N*
N* Argument(s) : a           First  value.
N*
N*               b           Second value.
N*
N* Return(s)   : Maximum of the two values.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_MAX(a, b)                                  (((a) > (b)) ? (a) : (b))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                              DEF_ABS()
N*
N* Description : Determine the absolute value of a value.
N*
N* Argument(s) : a           Value to calculate absolute value.
N*
N* Return(s)   : Absolute value of the value.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_ABS(a)                                     (((a) < 0) ? (-(a)) : (a))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                        CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of lib def module include.                       */
N
L 96 "..\..\..\..\..\uC-LIB\lib_str.h" 2
N#include  <app_cfg.h>
L 1 ".\app_cfg.h" 1
N/*
N*********************************************************************************************************
N*                                              EXAMPLE CODE
N*
N*                          (c) Copyright 2003-2006; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*               Knowledge of the source code may NOT be used to develop a similar product.
N*               Please help us continue to provide the Embedded community with the finest
N*               software available.  Your honesty is greatly appreciated.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                      APPLICATION CONFIGURATION
N*
N*                                     ST Microelectronics STM32
N*                                              with the
N*                                   STM3210B-LK1 Evaluation Board
N*
N* Filename      : app_cfg.h
N* Version       : V1.10
N* Programmer(s) : BH3NVN
N*********************************************************************************************************
N*/
N
N#ifndef  __APP_CFG_H__
N#define  __APP_CFG_H__
N
N/*
N*********************************************************************************************************
N*                                       MODULE ENABLE / DISABLE
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                              TASKS NAMES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                            TASK PRIORITIES
N*********************************************************************************************************
N*/
N
N#define  APP_TASK_START_PRIO                               2
N#define  APP_TASK_UART_PRIO                                7
N#define  APP_TASK_KBD_PRIO                                 4
N#define  APP_TASK_KEY_PRIO                                 5
N#define  APP_TASK_LED_PRIO                                 6
N
N
N
N/*
N*********************************************************************************************************
N*                                            TASK STACK SIZES
N*                             Size of the task stacks (# of OS_STK entries)
N*********************************************************************************************************
N*/
N
N#define  APP_TASK_START_STK_SIZE                         128
N#define  APP_TASK_KBD_STK_SIZE                           128
N#define  APP_TASK_KEY_STK_SIZE                           128
N#define  APP_TASK_LED_STK_SIZE                           128
N#define  APP_TASK_UART_STK_SIZE                         128
N
N/*
N*********************************************************************************************************
N*                                                  LIB
N*********************************************************************************************************
N*/
N
N#define  uC_CFG_OPTIMIZE_ASM_EN                 DEF_ENABLED
N#define  LIB_STR_CFG_FP_EN                      DEF_DISABLED
N
N#endif
L 97 "..\..\..\..\..\uC-LIB\lib_str.h" 2
N
N                                                                /* See Note #3.                                         */
N#include  <stdlib.h>
L 1 "E:\Keil\ARM\ARMCC\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.            */
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __pure
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X    #if 0L || (1L && 199901L <= 199409L)
S      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32)
X   #if 0L
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Ntypedef struct lldiv_t { __int64 quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI __int64 atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) __int64 atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __int64 strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) __int64 strtoll(const char * __restrict  ,
N                               char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __int64 strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned __int64 strtoull(const char * __restrict  ,
N                                         char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __pure int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __pure div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __pure long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __pure ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI_PURE __int64 llabs(__int64 /*j*/);
Xextern __declspec(__nothrow) __pure __int64 llabs(__int64  );
N   /*
N    * computes the absolute value of a __int64 integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __int64 abs(__int64 x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__int64 /*numer*/, __int64 /*denom*/);
Xextern __declspec(__nothrow) __pure lldiv_t lldiv(__int64  , __int64  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__int64 __numer, __int64 __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __pure __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __pure __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __pure __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N/* end of stdlib.h */
N
L 100 "..\..\..\..\..\uC-LIB\lib_str.h" 2
N#include  <ctype.h>
L 1 "E:\Keil\ARM\ARMCC\include\ctype.h" 1
N/* ctype.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.3 */
N/* Copyright (C) Codemist Ltd. 1988-1993.                       */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.        */
N/* version 0.03 */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N
N/*
N * ctype.h declares several functions useful for testing and mapping
N * characters. In all cases the argument is an int, the value of which shall
N * be representable as an unsigned char or shall equal the value of the
N * macro EOF. If the argument has any other value, the behaviour is undefined.
N */
N
N#ifndef __ctype_h
N#define __ctype_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __pure
N
N#ifdef __cplusplus
S#define _ARMABI_INLINE_DEF inline
S#elif defined(__GNUC__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#elif 0L || (1L && 199901L <= 199409L)
S#define _ARMABI_INLINE_DEF static inline
N#else
N#define _ARMABI_INLINE_DEF __inline
N#endif
N
N  #ifndef __CTYPE_DECLS
N  #define __CTYPE_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/* AEABI portable ctype flag bits */
N#define _ABI_A    1       /* alphabetic        */
N#define _ABI_X    2       /* A-F, a-f and 0-9  */
N#define _ABI_P    4       /* punctuation       */
N#define _ABI_B    8       /* blank             */
N#define _ABI_S   16       /* white space       */
N#define _ABI_L   32       /* lower case letter */
N#define _ABI_U   64       /* upper case letter */
N#define _ABI_C  128       /* control chars     */
N
N/* ARM internal ctype flag bits */
N/* N.B. - keep in step with <ctype.c> */
N
N/*
N * __ARM_CT_A (alphabetic) is required because characters in some locales
N * (e.g. Japanese) can be alphabetic but neither uppercase nor
N * lowercase. Unfortunately there wasn't a bit free for this, so
N * instead we've defined __ARM_CT_A as __ARM_CT_N+__ARM_CT_X (on the grounds that this
N * was a previously unused combination). Hence some of the ctype
N * predicates below are slightly less than obvious in
N * implementation.
N */
N#define __ARM_CT_S 1            /* whitespace           */
N#define __ARM_CT_P 2            /* punctuation          */
N#define __ARM_CT_B 4            /* blank                */
N#define __ARM_CT_L 8            /* lower case letter    */
N#define __ARM_CT_U 16           /* upper case letter    */
N#define __ARM_CT_N 32           /* (decimal) digit      */
N#define __ARM_CT_C 64           /* control chars        */
N#define __ARM_CT_X 128          /* A-F and a-f          */
N#define __ARM_CT_A (__ARM_CT_N+__ARM_CT_X)    /* alphabetic           */
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S
Sextern int (isalnum)(int /*c*/);
Sextern int (isalpha)(int /*c*/);
Sextern int (isblank)(int /*c*/);
Sextern int (iscntrl)(int /*c*/);
Sextern int (isdigit)(int /*c*/);
Sextern int (isgraph)(int /*c*/);
Sextern int (islower)(int /*c*/);
Sextern int (isprint)(int /*c*/);
Sextern int (ispunct)(int /*c*/);
Sextern int (isspace)(int /*c*/);
Sextern int (isupper)(int /*c*/);
Sextern int (isxdigit)(int /*c*/);
S
S/* Mandatory character attribute arrays indexed from 0 to 256 */
Sextern unsigned char const __aeabi_ctype_table_C[257];  /* "C" locale */
Sextern unsigned char const __aeabi_ctype_table_[257];   /* default locale */
S         /* The default locale might be the C locale */
S/* Optional character attribute arrays indexed from 0 to 256.        */
S/* These do not have to be provided by every execution environment   */
S/* but, if provided, shall be provided with these names and meaning. */
Sextern unsigned char const __aeabi_ctype_table_ISO8859_1[257];
Sextern unsigned char const __aeabi_ctype_table_SJIS[257];
Sextern unsigned char const __aeabi_ctype_table_BIG5[257];
Sextern unsigned char const __aeabi_ctype_table_UTF8[257];
S#ifdef _AEABI_LC_CTYPE
S# define _AEABI_CTYPE_TABLE(_X) __aeabi_ctype_table_ ## _X
S# define _AEABI_CTYPE(_X) _AEABI_CTYPE_TABLE(_X)
S# define __aeabi_ctype_table _AEABI_CTYPE(_AEABI_LC_CTYPE)
S#else
S# define __aeabi_ctype_table __aeabi_ctype_table_
S#endif
S
S#define isspace(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_S)
S#define isalpha(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_A)
S#define isalnum(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 30) /* test for _ABI_A and _ABI_X */
S#define isprint(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 28) /* test for _ABI_A, _ABI_X, _ABI_P and _ABI_B */
S#define isupper(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_U)
S#define islower(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_L)
S#define isxdigit(x) ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_X)
S#define isgraph(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 29) /* test for _ABI_A, _ABI_X and _ABI_P */
S#define iscntrl(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_C)
S#define ispunct(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_P)
S#define isdigit(c)  (((unsigned)(c) - '0') < 10)
S
N#else /* __AEABI_PORTABILITY_LEVEL */
N
Nextern _ARMABI_PURE unsigned char **__rt_ctype_table(void);
Xextern __declspec(__nothrow) __pure unsigned char **__rt_ctype_table(void);
N
N#define __arm_ctype (*__CLIBNS __rt_ctype_table())
N
N#ifdef __cplusplus
S    inline int isalnum(int __c) { return (__arm_ctype[__c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_N)); }
N#else
N    #define isalnum(c) (__arm_ctype[c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_N))
N    extern int (isalnum)(int /*c*/);
N#endif
N    /* non-0 iff c is alphabetic or numeric */
N
N#ifdef __cplusplus
S    inline int isalpha(int __c) { return (__arm_ctype[__c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_X)); }
N#else
N    #define isalpha(c) (__arm_ctype[c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_X))
N    extern int (isalpha)(int /*c*/);
N#endif
N    /* non-0 iff c is alphabetic */
N
N#ifdef __cplusplus
S    inline int iscntrl(int __c) { return (__arm_ctype[__c] & __ARM_CT_C); }
N#else
N    #define iscntrl(c) (__arm_ctype[c] & __ARM_CT_C)
N    extern int (iscntrl)(int /*c*/);
N#endif
N    /* non-0 iff c is a control character - in the "C" locale */
N    /*       this means (c < ' ') || (c > '~')                */
N
N/* isdigit must test for the presence of _only_ __ARM_CT_N, not just __ARM_CT_N at all. */
N#ifdef __cplusplus
S    inline int isdigit(int __c) { return (__arm_ctype[__c] == __ARM_CT_N); }
N#else
N    #define isdigit(c) (__arm_ctype[c] == __ARM_CT_N)
N    extern int (isdigit)(int /*c*/);
N#endif
N    /* non-0 iff c is a decimal digit */
N
N    extern int (isblank)(int /*c*/);
N    /* non-0 iff c is ' ', '\t' or some other locale-specific, */
N    /* word-separating character (there are no others in "C"   */
N    /* locale) */
N
N#ifdef __cplusplus
S    inline int isgraph(int __c) {return(__arm_ctype[__c] & (__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_X+__ARM_CT_P));}
N#else
N    #define isgraph(c) (__arm_ctype[c]&(__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_X+__ARM_CT_P))
N    extern int (isgraph)(int /*c*/);
N#endif
N    /* non-0 iff c is any printing character other than ' ' */
N
N#ifdef __cplusplus
S    inline int islower(int __c) { return (__arm_ctype[__c] & __ARM_CT_L); }
N#else
N    #define islower(c) (__arm_ctype[c] & __ARM_CT_L)
N    extern int (islower)(int /*c*/);
N#endif
N    /* non-0 iff c is a lower-case letter */
N
N#ifdef __cplusplus
S    inline int isprint(int __c) { return (__arm_ctype[__c] & (__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_P+__ARM_CT_B)); }
N#else
N    #define isprint(c) (__arm_ctype[c] & (__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_P+__ARM_CT_B))
N    extern int (isprint)(int /*c*/);
N#endif
N    /* non-0 iff c is a printing character - in the "C" locale */
N    /*       this means 0x20 (space) -> 0x7E (tilde)           */
N
N#ifdef __cplusplus
S    inline int ispunct(int __c) { return (__arm_ctype[__c] & __ARM_CT_P); }
N#else
N    #define ispunct(c) (__arm_ctype[c] & __ARM_CT_P)
N    extern int (ispunct)(int /*c*/);
N#endif
N    /* non-0 iff c is a non-space, non-alpha-numeric, printing character */
N
N#ifdef __cplusplus
S    inline int isspace(int __c) { return (__arm_ctype[__c] & __ARM_CT_S); }
N#else
N    #define isspace(c) (__arm_ctype[c] & __ARM_CT_S)
N    extern int (isspace)(int /*c*/);
N#endif
N    /* non-0 iff c is a white-space char: ' ', '\f', '\n', '\r', '\t', '\v'. */
N
N#ifdef __cplusplus
S    inline int isupper(int __c) { return (__arm_ctype[__c] & __ARM_CT_U); }
N#else
N    #define isupper(c) (__arm_ctype[c] & __ARM_CT_U)
N    extern int (isupper)(int /*c*/);
N#endif
N    /* non-0 iff c is an upper-case letter */
N
N/* isxdigit must test for the presence of __ARM_CT_N or __ARM_CT_X but not both. */
N/* This helper function avoids needing to evaluate c twice. */
N
N_ARMABI_INLINE_DEF int __isxdigit_helper(int __t) { return (__t ^ (__t << 2)); }
X__inline int __isxdigit_helper(int __t) { return (__t ^ (__t << 2)); }
N#ifdef __cplusplus
S    inline int isxdigit(int __c){return __isxdigit_helper(__arm_ctype[__c]) & __ARM_CT_X;}
N#else
N    #define isxdigit(c) (__isxdigit_helper(__arm_ctype[c]) & __ARM_CT_X)
N    extern int (isxdigit)(int /*c*/);
N#endif
N    /* non-0 iff c is a digit, in 'a'..'f', or in 'A'..'F' */
N
N#endif /* __AEABI_PORTABILITY_LEVEL */
N
Nextern int tolower(int /*c*/);
N    /* if c is an upper-case letter then return the corresponding */
N    /* lower-case letter, otherwise return c.                     */
N
Nextern int toupper(int /*c*/);
N    /* if c is an lower-case letter then return the corresponding */
N    /* upper-case letter, otherwise return c.                     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __CTYPE_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __CTYPE_NO_EXPORTS
S      using ::std::isalnum;
S      using ::std::isalpha;
S      using ::std::iscntrl;
S      using ::std::isdigit;
S      using ::std::isblank;
S      using ::std::isgraph;
S      using ::std::islower;
S      using ::std::isprint;
S      using ::std::ispunct;
S      using ::std::isspace;
S      using ::std::isupper;
S      using ::std::isxdigit;
S      using ::std::tolower;
S      using ::std::toupper;
S    #endif /* __CTYPE_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of ctype.h */
N
L 101 "..\..\..\..\..\uC-LIB\lib_str.h" 2
N#include  <errno.h>
L 1 "E:\Keil\ARM\ARMCC\include\errno.h" 1
N/* errno.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.3 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 1 */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: drodgman $
N */
N
N#ifndef __errno_h
N#define __errno_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI_PURE __declspec(__nothrow) __pure
N
N  #ifndef __ERRNO_DECLS
N  #define __ERRNO_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
Nextern _ARMABI_PURE volatile int *__aeabi_errno_addr(void);
Xextern __declspec(__nothrow) __pure volatile int *__aeabi_errno_addr(void);
N
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __ERRNO_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __ERRNO_NO_EXPORTS
S      using ::std::__aeabi_errno_addr;
S    #endif /* __ERRNO_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#define errno (*__CLIBNS __aeabi_errno_addr())
N/*
N * expands to a modifiable lvalue that has type volatile int, the value of
N * which is set to a positive error code by several library functions. It is
N * initialised to zero at program startup, but is never set to zero by any
N * library function. The value of errno may be set to nonzero by a library
N * function call whether or not there is an error, provided the use of errno
N * is not documented in the description of the function in the Standard.
N */
N
N
N/*
N * Error numbers defined in the C standard need the ABI portability
N * mechanism.
N */
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N/* The ABI-defined signal numbers (EDOM, ERANGE and EILSEQ) are
N * defined differently depending on ABI conformance level. */
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
Sextern const int __aeabi_EDOM;
Sextern const int __aeabi_ERANGE;
Sextern const int __aeabi_EILSEQ;
S#define EDOM (__aeabi_EDOM)
S#define ERANGE (__aeabi_ERANGE)
S#define EILSEQ (__aeabi_EILSEQ)
N#else
N
N#define EDOM    1
N/*
N * If a mathematical function suffers a domain error (an input
N * argument is outside the domain over which the mathematical
N * function is defined, e.g. log of a negative number) the integer
N * expression errno acquires the value of the macro EDOM.
N *
N * EDOM is also returned by ftell, fgetpos and fsetpos when they
N * fail.
N */
N
N#define ERANGE 2
N/*
N * If a mathematical function suffers a range error (the result of
N * the function is too large or too small to be accurately
N * represented in the output floating-point format), the integer
N * expression errno acquires the value of the macro ERANGE.
N *
N * ERANGE is used by functions in math.h and complex.h, and also by
N * the strto* and wcsto* family of decimal-to-binary conversion
N * functions (both floating and integer) and by floating-point
N * conversions in scanf.
N */
N
N#define EILSEQ  4
N/*
N * EILSEQ is generated by the restartable multi-byte character
N * processing routines to indicate an encoding error: that is, it is
N * generated by mbrtowc, wcrtomb, mbsrtowcs and wcsrtombs, but not
N * by mbtowc, wctomb, mbstowcs or wcsrtombs.
N *
N * It is also generated by the wide-character stdio functions:
N * fputwc, putwc, putwchar, fputws, fgetwc, getwc, getwchar, fgetws.
N */
N
N#endif /* end of conditional definition of ABI-defined signals */
N
N#define ESIGNUM 3
N/*
N * ESIGNUM is generated by signal() if the user attempts to change
N * the handling of a nonexistent signal. ESIGNUM is not part of the
N * ANSI C standard.
N */
N
N#define EINVAL  5
N#define ENOMEM  6
N/*
N * EINVAL and ENOMEM can be generated by posix_memalign().
N */
N
N#endif
N
N/* end of errno.h */
N
L 102 "..\..\..\..\..\uC-LIB\lib_str.h" 2
N#include  <limits.h>
L 1 "E:\Keil\ARM\ARMCC\include\limits.h" 1
N/* limits.h: ANSI 'C' (X3J11 Oct 88) library header, section 2.2.4.2 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991-1997 ARM Limited. All rights reserved         */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: drodgman $
N */
N
N#ifndef __limits_h
N#define __limits_h
N#define __ARMCLIB_VERSION 5030076
N
N#define CHAR_BIT 8
N    /* max number of bits for smallest object that is not a bit-field (byte) */
N#define SCHAR_MIN (-128)
N    /* mimimum value for an object of type signed char */
N#define SCHAR_MAX 127
N    /* maximum value for an object of type signed char */
N#define UCHAR_MAX 255
N    /* maximum value for an object of type unsigned char */
N#ifdef __FEATURE_SIGNED_CHAR
S  #define CHAR_MIN (-128)
S      /* minimum value for an object of type char */
S  #define CHAR_MAX 127
S      /* maximum value for an object of type char */
N#else
N  #define CHAR_MIN 0
N      /* minimum value for an object of type char */
N  #define CHAR_MAX 255
N      /* maximum value for an object of type char */
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
Sextern const int __aeabi_MB_LEN_MAX;
S#define MB_LEN_MAX (__aeabi_MB_LEN_MAX)
N#else
N#define MB_LEN_MAX 6
N#endif
N    /* maximum number of bytes in a multibyte character, */
N    /* for any supported locale */
N
N#define SHRT_MIN  (-0x8000)
N    /* minimum value for an object of type short int */
N#define SHRT_MAX  0x7fff
N    /* maximum value for an object of type short int */
N#define USHRT_MAX 65535
N    /* maximum value for an object of type unsigned short int */
N#define INT_MIN   (~0x7fffffff)  /* -2147483648 and 0x80000000 are unsigned */
N    /* minimum value for an object of type int */
N#define INT_MAX   0x7fffffff
N    /* maximum value for an object of type int */
N#define UINT_MAX  0xffffffffU
N    /* maximum value for an object of type unsigned int */
N#define LONG_MIN  (~0x7fffffffL)
N    /* minimum value for an object of type long int */
N#define LONG_MAX  0x7fffffffL
N    /* maximum value for an object of type long int */
N#define ULONG_MAX 0xffffffffUL
N    /* maximum value for an object of type unsigned long int */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N  #define LLONG_MIN  (~0x7fffffffffffffffLL)
N      /* minimum value for an object of type long long int */
N  #define LLONG_MAX    0x7fffffffffffffffLL
N      /* maximum value for an object of type long long int */
N  #define ULLONG_MAX   0xffffffffffffffffULL
N      /* maximum value for an object of type unsigned long int */
N#endif
N
N#endif
N
N/* end of limits.h */
N
L 103 "..\..\..\..\..\uC-LIB\lib_str.h" 2
N#include  <stdio.h>
L 1 "E:\Keil\ARM\ARMCC\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5030076
N
N
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;   /* see <stddef.h> */
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined)
X#if 0L || !0L || !0L
N/* always defined in C++ and non-strict C for consistency of debug info */
N  typedef struct __va_list __va_list;
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 104 "..\..\..\..\..\uC-LIB\lib_str.h" 2
N
N
N/*
N*********************************************************************************************************
N*                                               EXTERNS
N*********************************************************************************************************
N*/
N
N#ifdef   LIB_STR_MODULE
N#define  LIB_STR_EXT
N#else
S#define  LIB_STR_EXT  extern
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        DEFAULT CONFIGURATION
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                      MEMORY POOL CONFIGURATION
N*
N* Note(s) : (1) Configure LIB_STR_CFG_FP_EN to enable/disable floating point string function(s).
N*********************************************************************************************************
N*/
N                                                                /* Configure floating point feature(s) [see Note #1] :  */
N#ifndef  LIB_STR_CFG_FP_EN
S#define  LIB_STR_CFG_FP_EN                      DEF_DISABLED
S                                                                /*   DEF_DISABLED     Floating point functions DISABLED */
S                                                                /*   DEF_ENABLED      Floating point functions ENABLED  */
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                               DEFINES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                             DATA TYPES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                          GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                              MACRO'S
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                      STANDARD LIBRARY MACRO'S
N*
N* Note(s) : (1) NO compiler-supplied standard library functions SHOULD be used.
N*
N*               #### The reference to standard memory functions SHOULD be removed once all custom library 
N*               functions are implemented WITHOUT reference to ANY standard library function(s).
N*
N*               See also 'INCLUDE FILES  Note #3'.
N*********************************************************************************************************
N*/
N
N                                                                /* See Note #1.                                         */
N#define  Str_IsPrint(a)                 isprint(a)
N
N#define  Str_ToLong(a, b, c)            strtol((char *)a, (char **)b, c)
N#define  Str_FmtPrint                   snprintf
N#define  Str_FmtScan                    sscanf
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
NCPU_SIZE_T   Str_Len      (CPU_CHAR     *pstr);
N
N
N
NCPU_CHAR    *Str_Copy     (CPU_CHAR     *pdest,
N                           CPU_CHAR     *psrc);
N
NCPU_CHAR    *Str_Copy_N   (CPU_CHAR     *pdest,
N                           CPU_CHAR     *psrc,
N                           CPU_SIZE_T    len_max);
N
N
NCPU_CHAR    *Str_Cat      (CPU_CHAR     *pdest,
N                           CPU_CHAR     *pstr_cat);
N
NCPU_CHAR    *Str_Cat_N    (CPU_CHAR     *pdest,
N                           CPU_CHAR     *pstr_cat,
N                           CPU_SIZE_T    len_max);
N
N
N
NCPU_INT16S   Str_Cmp      (CPU_CHAR     *p1_str,
N                           CPU_CHAR     *p2_str);
N
NCPU_INT16S   Str_Cmp_N    (CPU_CHAR     *p1_str,
N                           CPU_CHAR     *p2_str,
N                           CPU_SIZE_T    len_max);
N
N
NCPU_CHAR    *Str_Char     (CPU_CHAR     *pstr,
N                           CPU_CHAR      srch_char);
N
NCPU_CHAR    *Str_Char_N   (CPU_CHAR     *pstr,
N                           CPU_SIZE_T    len_max,
N                           CPU_CHAR      srch_char);
N
NCPU_CHAR    *Str_Char_Last(CPU_CHAR     *pstr,
N                           CPU_CHAR      srch_char);
N
N
NCPU_CHAR    *Str_Str      (CPU_CHAR     *pstr,
N                           CPU_CHAR     *srch_str);
N
N
N
N#if (LIB_STR_CFG_FP_EN  == DEF_ENABLED)
X#if (0  == 1)
SCPU_CHAR    *Str_FmtNbr_32(CPU_FP32      nbr,
S                           CPU_INT08U    nbr_dig,
S                           CPU_INT08U    nbr_dp,
S                           CPU_BOOLEAN   lead_zeros,
S                           CPU_BOOLEAN   nul,
S                           CPU_CHAR     *pstr_fmt);
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_STR_CFG_FP_EN
S#error  "LIB_STR_CFG_FP_EN        not #define'd in 'app_cfg.h'"
S#error  "                   [MUST be  DEF_DISABLED]           "
S#error  "                   [     ||  DEF_ENABLED ]           "
S
S#elif  ((LIB_STR_CFG_FP_EN != DEF_DISABLED) && \
S        (LIB_STR_CFG_FP_EN != DEF_ENABLED ))
X#elif  ((0 != 0) &&         (0 != 1 ))
S#error  "LIB_STR_CFG_FP_EN  illegally #define'd in 'app_cfg.h'"
S#error  "                   [MUST be  DEF_DISABLED]           "
S#error  "                   [     ||  DEF_ENABLED ]           "
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of lib str module include.                       */
N
L 60 "..\..\..\..\..\uC-LIB\lib_str.c" 2
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            LOCAL DEFINES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                           LOCAL CONSTANTS
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                          LOCAL DATA TYPES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                            LOCAL TABLES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                       LOCAL GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                      LOCAL FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                     LOCAL CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                              Str_Len()
N*
N* Description : Calculate length of a string.
N*
N* Argument(s) : pstr        Pointer to string (see Note #1).
N*
N* Return(s)   : Length of string; number of characters in string before terminating NULL character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) String buffer NOT modified.
N*
N*               (2) String length calculation terminates when :
N*
N*                   (a) String pointer points to NULL.
N*                       (1) String buffer overlaps with NULL address.
N*                       (2) String length calculated for string up to but NOT beyond or including
N*                           the NULL address.
N*
N*                   (b) Terminating NULL character found.
N*                       (1) String length calculated for string up to but NOT           including
N*                           the NULL character.
N*********************************************************************************************************
N*/
N
NCPU_SIZE_T  Str_Len (CPU_CHAR  *pstr)
N{
N    CPU_SIZE_T  len;
N
N
N    len = 0;
N    while (( pstr != (CPU_CHAR *)0) &&                          /* Calc str len until NULL ptr (see Note #2a) ...       */
N           (*pstr != (CPU_CHAR  )0)) {                          /* ... or NULL char found      (see Note #2b).          */
N        len++;
N        pstr++;
N    }
N
N    return (len);
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             Str_Copy()
N*
N* Description : Copy source string to destination string buffer.
N*
N* Argument(s) : pdest       Pointer to destination string buffer to receive source string copy (see Note #1).
N*
N*               psrc        Pointer to source      string to copy into destination string buffer.
N*
N* Return(s)   : Pointer to destination string, if NO errors (see Note #2).
N*
N*               Pointer to NULL,               otherwise.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
N*
N*                   (a) Destination buffer size MUST be large enough to accommodate the entire source 
N*                       string size including the terminating NULL character.
N*
N*               (2) String copy terminates when :
N*
N*                   (a) Destination/Source string pointer(s) are passed NULL pointers.
N*                       (1) No string copy performed; NULL pointer returned.
N*
N*                   (b) Destination/Source string pointer(s) points to NULL.
N*                       (1) String buffer(s) overlap with NULL address.
N*                       (2) Source string copied into destination string buffer up to but NOT beyond or
N*                           including the NULL address; destination string buffer properly terminated
N*                           with NULL character.
N*
N*                   (c) Source string's terminating NULL character found.
N*                       (1) Entire source string copied into destination string buffer.
N*********************************************************************************************************
N*/
N
NCPU_CHAR  *Str_Copy (CPU_CHAR  *pdest,
N                     CPU_CHAR  *psrc)
N{
N    CPU_CHAR  *pstr;
N    CPU_CHAR  *pstr_next;
N
N                                                                /* Rtn NULL if str ptr(s) NULL (see Note #2a).          */
N    if (pdest == (CPU_CHAR *)0) {
N        return  ((CPU_CHAR *)0);
N    }
N    if (psrc  == (CPU_CHAR *)0) {
N        return  ((CPU_CHAR *)0);
N    }
N
N
N    pstr      = pdest;
N    pstr_next = pstr;
N    pstr_next++;
N    while (( pstr_next != (CPU_CHAR *)0) &&                     /* Copy str until NULL ptr(s) (see Note #2b) ...        */
N           ( psrc      != (CPU_CHAR *)0) &&
N           (*psrc      != (CPU_CHAR  )0)) {                     /* ... or NULL char found     (see Note #2c).           */
N       *pstr = *psrc;
N        pstr++;
N        pstr_next++;
N        psrc++;
N    }
N
N   *pstr = (CPU_CHAR)0;                                         /* Append NULL char (see Note #2b2).                    */
N
N
N    return (pdest);
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            Str_Copy_N()
N*
N* Description : Copy source string to destination string buffer, up to a maximum number of characters.
N*
N* Argument(s) : pdest       Pointer to destination string buffer to receive source string copy (see Note #1).
N*
N*               psrc        Pointer to source      string to copy into destination string buffer.
N*
N*               len_max     Maximum number of characters to copy (see Note #2d).
N*
N* Return(s)   : Pointer to destination string, if NO errors (see Note #2).
N*
N*               Pointer to NULL,               otherwise.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
N*
N*                   (a) Destination buffer size MUST be large enough to accommodate the entire source 
N*                       string size including the terminating NULL character.
N*
N*               (2) String copy terminates when :
N*
N*                   (a) Destination/Source string pointer(s) are passed NULL pointers.
N*                       (1) No string copy performed; NULL pointer returned.
N*
N*                   (b) Destination/Source string pointer(s) points to NULL.
N*                       (1) String buffer(s) overlap with NULL address.
N*                       (2) Source string copied into destination string buffer up to but NOT beyond or
N*                           including the NULL address; destination string buffer properly terminated
N*                           with NULL character.
N*
N*                   (c) Source string's terminating NULL character found.
N*                       (1) Entire source string copied into destination string buffer.
N*
N*                   (d) 'len_max' number of characters copied.
N*                       (1) 'len_max' number of characters does NOT include the terminating NULL character.
N*
N*                           See also Note #1a.
N*********************************************************************************************************
N*/
N
NCPU_CHAR  *Str_Copy_N (CPU_CHAR    *pdest,
N                       CPU_CHAR    *psrc,
N                       CPU_SIZE_T   len_max)
N{
N    CPU_CHAR    *pstr;
N    CPU_CHAR    *pstr_next;
N    CPU_SIZE_T   len_copy;
N
N                                                                /* Rtn NULL if str ptr(s) NULL      (see Note #2a).     */
N    if (pdest == (CPU_CHAR *)0) {
N        return  ((CPU_CHAR *)0);
N    }
N    if (psrc  == (CPU_CHAR *)0) {
N        return  ((CPU_CHAR *)0);
N    }
N
N    if (len_max == (CPU_SIZE_T)0) {                             /* Rtn NULL if copy len equals zero (see Note #2d).     */
N        return  ((CPU_CHAR *)0);
N    }
N
N
N    pstr      = pdest;
N    pstr_next = pstr;
N    pstr_next++;
N    len_copy  = 0;
N
N    while (( pstr_next != (CPU_CHAR *)0) &&                     /* Copy str until NULL ptr(s)  (see Note #2b)  ...      */
N           ( psrc      != (CPU_CHAR *)0) &&
N           (*psrc      != (CPU_CHAR  )0) &&                     /* ... or NULL char found      (see Note #2c); ...      */
N           ( len_copy  <  (CPU_SIZE_T)len_max)) {               /* ... or max nbr chars copied (see Note #2d).          */
N       *pstr = *psrc;
N        pstr++;
N        pstr_next++;
N        psrc++;
N        len_copy++;
N    }
N
N   *pstr = (CPU_CHAR)0;                                         /* Append NULL char (see Note #2b2).                    */
N
N
N    return (pdest);
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                              Str_Cat()
N*
N* Description : Append concatenation string to destination string.
N*
N* Argument(s) : pdest       Pointer to destination   string to append concatenation  string (see Note #1).
N*
N*               pstr_cat    Pointer to concatenation string to append to destination string.
N*
N* Return(s)   : Pointer to destination string, if NO errors (see Note #2).
N*
N*               Pointer to NULL,               otherwise.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) Destination string buffer size NOT validated; buffer overruns MUST be prevented by caller.
N*
N*                   (a) Destination buffer size MUST be large enough to accommodate the entire concatenated
N*                       string size including the terminating NULL character.
N*
N*               (2) String concatenation terminates when :
N*
N*                   (a) Destination/Concatenation string pointer(s) are passed NULL pointers.
N*                       (1) No string concatenation performed; NULL pointer returned.
N*
N*                   (b) Destination string overlaps with NULL address.
N*                       (1) No string concatenation performed; NULL pointer returned.
N*
N*                   (c) Destination/Concatenation string pointer(s) points to NULL.
N*                       (1) String buffer(s) overlap with NULL address.
N*                       (2) Concatenation string appended into destination string buffer up to but NOT
N*                           beyond or including the NULL address; destination string buffer properly
N*                           terminated with NULL character.
N*
N*                   (d) Concatenation string's terminating NULL character found.
N*                       (1) Entire concatenation string appended to destination string.
N*********************************************************************************************************
N*/
N
NCPU_CHAR  *Str_Cat (CPU_CHAR  *pdest,
N                    CPU_CHAR  *pstr_cat)
N{
N    CPU_CHAR  *pstr;
N    CPU_CHAR  *pstr_next;
N
N                                                                /* Rtn NULL if str ptr(s) NULL (see Note #2a).          */
N    if (pdest == (CPU_CHAR *)0) {
N        return  ((CPU_CHAR *)0);
N    }
N    if (pstr_cat == (CPU_CHAR *)0) {
N        return  ((CPU_CHAR *)0);
N    }
N
N
N    pstr = pdest;
N    while (( pstr != (CPU_CHAR *)0) &&                          /* Adv to end of cur dest str until NULL ptr ...        */
N           (*pstr != (CPU_CHAR  )0)) {                          /* ... or NULL char found..                             */
N        pstr++;
N    }
N    if (pstr == (CPU_CHAR *)0) {                                /* If NULL str overrun, rtn NULL (see Note #2b).        */
N        return ((CPU_CHAR *)0);
N    }
N
N    pstr_next = pstr;
N    pstr_next++;
N    while (( pstr_next != (CPU_CHAR *)0) &&                     /* Cat str until NULL ptr(s) (see Note #2c) ...         */
N           ( pstr_cat  != (CPU_CHAR *)0) &&
N           (*pstr_cat  != (CPU_CHAR  )0)) {                     /* ... or NULL char found    (see Note #2d).            */
N       *pstr = *pstr_cat;
N        pstr++;
N        pstr_next++;
N        pstr_cat++;
N    }
N
N   *pstr = (CPU_CHAR)0;                                         /* Append NULL char (see Note #2c2).                    */
N
N
N    return (pdest);
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             Str_Cat_N()
N*
N* Description : Append concatenation string to destination string, up to a maximum number of characters.
N*
N* Argument(s) : pdest       Pointer to destination   string to append concatenation  string (see Note #1).
N*
N*               pstr_cat    Pointer to concatenation string to append to destination string.
N*
N*               len_max     Maximum number of characters to concatenate (see Note #2e).
N*
N* Return(s)   : Pointer to destination string, if NO errors (see Note #2).
N*
N*               Pointer to NULL,               otherwise.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) Destination string buffer size NOT validated; buffer overruns MUST be prevented by caller.
N*
N*                   (a) Destination buffer size MUST be large enough to accommodate the entire concatenated
N*                       string size including the terminating NULL character.
N*
N*               (2) String concatenation terminates when :
N*
N*                   (a) Destination/Concatenation string pointer(s) are passed NULL pointers.
N*                       (1) No string concatenation performed; NULL pointer returned.
N*
N*                   (b) Destination string overlaps with NULL address.
N*                       (1) No string concatenation performed; NULL pointer returned.
N*
N*                   (c) Destination/Concatenation string pointer(s) points to NULL.
N*                       (1) String buffer(s) overlap with NULL address.
N*                       (2) Concatenation string appended into destination string buffer up to but NOT
N*                           beyond or including the NULL address; destination string buffer properly
N*                           terminated with NULL character.
N*
N*                   (d) Concatenation string's terminating NULL character found.
N*                       (1) Entire concatenation string appended to destination string.
N*
N*                   (e) 'len_max' number of characters concatenated.
N*                       (1) 'len_max' number of characters does NOT include the terminating NULL character.
N*
N*                           See also Note #1a.
N*********************************************************************************************************
N*/
N/*$PAGE*/
NCPU_CHAR  *Str_Cat_N (CPU_CHAR    *pdest,
N                      CPU_CHAR    *pstr_cat,
N                      CPU_SIZE_T   len_max)
N{
N    CPU_CHAR    *pstr;
N    CPU_CHAR    *pstr_next;
N    CPU_SIZE_T   len_cat;
N
N                                                                /* Rtn NULL if str ptr(s) NULL     (see Note #2a).      */
N    if (pdest == (CPU_CHAR *)0) {
N        return  ((CPU_CHAR *)0);
N    }
N    if (pstr_cat == (CPU_CHAR *)0) {
N        return  ((CPU_CHAR *)0);
N    }
N
N    if (len_max == (CPU_SIZE_T)0) {                             /* Rtn NULL if cat len equals zero (see Note #2e).      */
N        return  ((CPU_CHAR *)0);
N    }
N
N
N    pstr = pdest;
N    while (( pstr != (CPU_CHAR *)0) &&                          /* Adv to end of cur dest str until NULL ptr ...        */
N           (*pstr != (CPU_CHAR  )0)) {                          /* ... or NULL char found..                             */
N        pstr++;
N    }
N    if (pstr == (CPU_CHAR *)0) {                                /* If NULL str overrun, rtn NULL (see Note #2b).        */
N        return ((CPU_CHAR *)0);
N    }
N
N    pstr_next = pstr;
N    pstr_next++;
N    len_cat   = 0;
N
N    while (( pstr_next != (CPU_CHAR *)0) &&                     /* Cat str until NULL ptr(s)  (see Note #2c)  ...       */
N           ( pstr_cat  != (CPU_CHAR *)0) &&
N           (*pstr_cat  != (CPU_CHAR  )0) &&                     /* ... or NULL char found     (see Note #2d); ...       */
N           ( len_cat   <  (CPU_SIZE_T)len_max)) {               /* ... or max nbr chars cat'd (see Note #2d).           */
N       *pstr = *pstr_cat;
N        pstr++;
N        pstr_next++;
N        pstr_cat++;
N        len_cat++;
N    }
N
N   *pstr = (CPU_CHAR)0;                                         /* Append NULL char (see Note #2c2).                    */
N
N
N    return (pdest);
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                              Str_Cmp()
N*
N* Description : Determine if two strings are identical.
N*
N* Argument(s) : p1_str      Pointer to first  string (see Note #1).
N*
N*               p2_str      Pointer to second string (see Note #1).
N*
N* Return(s)   : 0,              if strings are identical             (see Notes #2a, #2e, & #2f).
N*
N*               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #2b, #2g, & #2d).
N*
N*               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #2c, #2h, & #2d).
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) String buffers NOT modified.
N*
N*               (2) String comparison terminates when :
N*
N*                   (a) BOTH string pointer(s) are passed NULL pointers.
N*                       (1) NULL strings identical; return 0.
N*
N*                   (b) 'p1_str' passed a NULL pointer.
N*                       (1) Return negative value of character pointed to by 'p2_str'.
N*
N*                   (c) 'p2_str' passed a NULL pointer.
N*                       (1) Return positive value of character pointed to by 'p1_str'.
N*
N*                   (d) Non-matching characters found.
N*                       (1) Return signed-integer difference of the character pointed to by 'p2_str'
N*                           from the character pointed to by 'p1_str'.
N*
N*                   (e) Terminating NULL character found in both strings.
N*                       (1) Strings identical; return 0.
N*                       (2) Only one NULL character test required in conditional since previous condition
N*                           tested character equality.
N*
N*                   (f) BOTH strings point to NULL.
N*                       (1) Strings overlap with NULL address.
N*                       (2) Strings identical up to but NOT beyond or including the NULL address; return 0.
N*
N*                   (g) 'p1_str_next' points to NULL.
N*                       (1) 'p1_str' overlaps with NULL address.
N*                       (2) Strings compared up to but NOT beyond or including the NULL address.
N*                       (3) Return  negative value of character pointed to by 'p2_str_next'.
N*
N*                   (h) 'p2_str_next' points to NULL.
N*                       (1) 'p2_str' overlaps with NULL address.
N*                       (2) Strings compared up to but NOT beyond or including the NULL address.
N*                       (3) Return  positive value of character pointed to by 'p1_str_next'.
N*
N*               (3) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
N*                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
N*********************************************************************************************************
N*/
N/*$PAGE*/
NCPU_INT16S  Str_Cmp (CPU_CHAR  *p1_str,
N                     CPU_CHAR  *p2_str)
N{
N    CPU_CHAR    *p1_str_next;
N    CPU_CHAR    *p2_str_next;
N    CPU_INT16S   cmp_val;
N
N
N    if (p1_str == (CPU_CHAR *)0) {
N        if (p2_str == (CPU_CHAR *)0) {
N            return ((CPU_INT16S)0);                             /* If BOTH str ptrs NULL, rtn 0 (see Note #2a).         */
N        }
N        cmp_val = (CPU_INT16S)0 - (CPU_INT16S)(*p2_str);
N        return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #2b).   */
N    }
N    if (p2_str == (CPU_CHAR *)0) {
N        cmp_val = (CPU_INT16S)(*p1_str);
N        return (cmp_val);                                       /* If p2_str NULL, rtn pos p1_str val (see Note #2c).   */
N    }
N
N
N    p1_str_next = p1_str;
N    p2_str_next = p2_str;
N    p1_str_next++;
N    p2_str_next++;
N    while ((*p1_str      == *p2_str)       &&                   /* Cmp strs until non-matching char (see Note #2d) ..   */
N           (*p1_str      != (CPU_CHAR  )0) &&                   /* .. or NULL char(s)               (see Note #2e) ..   */
N           ( p1_str_next != (CPU_CHAR *)0) &&                   /* .. or NULL ptr(s) found (see Notes #2f, #2g, & #2h). */
N           ( p2_str_next != (CPU_CHAR *)0)) {
N        p1_str_next++;
N        p2_str_next++;
N        p1_str++;
N        p2_str++;
N    }
N
N
N    if (*p1_str != *p2_str) {                                           /* If strs NOT identical, ...                   */
N         cmp_val = (CPU_INT16S)(*p1_str) - (CPU_INT16S)(*p2_str);       /* ... calc & rtn char diff  (see Note #2d1).   */
N
N    } else if (*p1_str == (CPU_CHAR)0) {                                /* If NULL char(s) found, ...                   */
N         cmp_val = 0;                                                   /* ... strs identical; rtn 0 (see Note #2e).    */
N
N    } else {
N        if (p1_str_next == (CPU_CHAR *)0) {
N            if (p2_str_next == (CPU_CHAR *)0) {                         /* If BOTH next str ptrs NULL, ...              */
N                cmp_val = (CPU_INT16S)0;                                /* ... rtn 0                   (see Note #2f).  */
N            } else {                                                    /* If p1_str_next NULL, ...                     */
N                cmp_val = (CPU_INT16S)0 - (CPU_INT16S)(*p2_str_next);   /* ... rtn neg p2_str_next val (see Note #2g).  */
N            }
N        } else {                                                        /* If p2_str_next NULL, ...                     */
N            cmp_val = (CPU_INT16S)(*p1_str_next);                       /* ... rtn pos p1_str_next val (see Note #2h).  */
N        }
N    }
N
N
N    return (cmp_val);
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             Str_Cmp_N()
N*
N* Description : Determine if two strings are identical for up to a maximum number of characters.
N*
N* Argument(s) : p1_str      Pointer to first  string (see Note #1).
N*
N*               p2_str      Pointer to second string (see Note #1).
N*
N*               len_max     Maximum number of characters to compare  (see Notes #2i & #2j).
N*
N* Return(s)   : 0,              if strings are identical             (see Notes #2a, #2e, #2f, #2i, & #2j).
N*
N*               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #2b, #2g, & #2d).
N*
N*               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #2c, #2h, & #2d).
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) String buffers NOT modified.
N*
N*               (2) String comparison terminates when :
N*
N*                   (a) BOTH string pointer(s) are passed NULL pointers.
N*                       (1) NULL strings identical; return 0.
N*
N*                   (b) 'p1_str' passed a NULL pointer.
N*                       (1) Return negative value of character pointed to by 'p2_str'.
N*
N*                   (c) 'p2_str' passed a NULL pointer.
N*                       (1) Return positive value of character pointed to by 'p1_str'.
N*
N*                   (d) Non-matching characters found.
N*                       (1) Return signed-integer difference of the character pointed to by 'p2_str'
N*                           from the character pointed to by 'p1_str'.
N*
N*                   (e) Terminating NULL character found in both strings.
N*                       (1) Strings identical; return 0.
N*                       (2) Only one NULL character test required in conditional since previous condition
N*                           tested character equality.
N*
N*                   (f) BOTH strings point to NULL.
N*                       (1) Strings overlap with NULL address.
N*                       (2) Strings identical up to but NOT beyond or including the NULL address; return 0.
N*
N*                   (g) 'p1_str_next' points to NULL.
N*                       (1) 'p1_str' overlaps with NULL address.
N*                       (2) Strings compared up to but NOT beyond or including the NULL address.
N*                       (3) Return  negative value of character pointed to by 'p2_str_next'.
N*
N*                   (h) 'p2_str_next' points to NULL.
N*                       (1) 'p2_str' overlaps with NULL address.
N*                       (2) Strings compared up to but NOT beyond or including the NULL address.
N*                       (3) Return  positive value of character pointed to by 'p1_str_next'.
N*
N*                   (i) 'len_max' passed a zero length.
N*                       (1) Zero-length strings identical; return 0.
N*
N*                   (j) First 'len_max' number of characters identical.
N*                       (1) Strings identical; return 0.
N*
N*               (3) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
N*                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
N*********************************************************************************************************
N*/
N/*$PAGE*/
NCPU_INT16S  Str_Cmp_N (CPU_CHAR    *p1_str,
N                       CPU_CHAR    *p2_str,
N                       CPU_SIZE_T   len_max)
N{
N    CPU_CHAR    *p1_str_next;
N    CPU_CHAR    *p2_str_next;
N    CPU_INT16S   cmp_val;
N    CPU_SIZE_T   cmp_len;
N
N
N    if (len_max == 0) {                                         /* If cmp len equals zero, rtn 0      (see Note #2i).   */
N        return ((CPU_INT16S)0);
N    }
N
N    if (p1_str == (CPU_CHAR *)0) {
N        if (p2_str == (CPU_CHAR *)0) {
N            return ((CPU_INT16S)0);                             /* If BOTH str ptrs NULL,  rtn 0      (see Note #2a).   */
N        }
N        cmp_val = (CPU_INT16S)0 - (CPU_INT16S)(*p2_str);
N        return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #2b).   */
N    }
N    if (p2_str == (CPU_CHAR *)0) {
N        cmp_val = (CPU_INT16S)(*p1_str);
N        return (cmp_val);                                       /* If p2_str NULL, rtn pos p1_str val (see Note #2c).   */
N    }
N
N
N    p1_str_next = p1_str;
N    p2_str_next = p2_str;
N    p1_str_next++;
N    p2_str_next++;
N    cmp_len     = 0;
N    while ((*p1_str      == *p2_str)       &&                   /* Cmp strs until non-matching char (see Note #2d) ..   */
N           (*p1_str      != (CPU_CHAR  )0) &&                   /* .. or NULL char(s)               (see Note #2e) ..   */
N           ( p1_str_next != (CPU_CHAR *)0) &&                   /* .. or NULL ptr(s) found (see Notes #2f, #2g, & #2h); */
N           ( p2_str_next != (CPU_CHAR *)0) &&
N           ( cmp_len     <  (CPU_SIZE_T)len_max)) {             /* .. or len nbr chars cmp'd        (see Note #2j).     */
N        p1_str_next++;
N        p2_str_next++;
N        p1_str++;
N        p2_str++;
N        cmp_len++;
N    }
N
N
N    if (cmp_len == len_max) {                                           /* If strs     identical for len nbr of chars,  */
N        return ((CPU_INT16S)0);                                         /* ... rtn 0 (see Note #2j).                    */
N    }
N
N    if (*p1_str != *p2_str) {                                           /* If strs NOT identical, ...                   */
N         cmp_val = (CPU_INT16S)(*p1_str) - (CPU_INT16S)(*p2_str);       /* ... calc & rtn char diff  (see Note #2d1).   */
N
N    } else if (*p1_str == (CPU_CHAR)0) {                                /* If NULL char(s) found, ...                   */
N         cmp_val = 0;                                                   /* ... strs identical; rtn 0 (see Note #2e).    */
N
N    } else {
N        if (p1_str_next == (CPU_CHAR *)0) {
N            if (p2_str_next == (CPU_CHAR *)0) {                         /* If BOTH next str ptrs NULL, ...              */
N                cmp_val = (CPU_INT16S)0;                                /* ... rtn 0                   (see Note #2f).  */
N            } else {                                                    /* If p1_str_next NULL, ...                     */
N                cmp_val = (CPU_INT16S)0 - (CPU_INT16S)(*p2_str_next);   /* ... rtn neg p2_str_next val (see Note #2g).  */
N            }
N        } else {                                                        /* If p2_str_next NULL, ...                     */
N            cmp_val = (CPU_INT16S)(*p1_str_next);                       /* ... rtn pos p1_str_next val (see Note #2h).  */
N        }
N    }
N
N
N    return (cmp_val);
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             Str_Char()
N*
N* Description : Search string for first occurrence of specific character.
N*
N* Argument(s) : pstr            Pointer to string (see Note #1).
N*
N*               srch_char       Search character.
N*
N* Return(s)   : Pointer to first occurrence of search character in string, if any.
N*
N*               Pointer to NULL,                                           otherwise.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) String buffer NOT modified.
N*
N*               (2) String search terminates when :
N*
N*                   (a) String pointer passed a NULL pointer.
N*                       (1) No string search performed; NULL pointer returned.
N*
N*                   (b) String pointer points to NULL.
N*                       (1) String overlaps with NULL address.
N*                       (2) String searched up to but NOT beyond or including the NULL address.
N*
N*                   (c) String's terminating NULL character found.
N*                       (1) Search character NOT found in search string; NULL pointer returned.
N*                       (2) Applicable ONLY IF search character is NOT the terminating NULL character.
N*
N*                   (d) Search character found.
N*                       (1) Return pointer to first occurrence of search character in search string.
N*********************************************************************************************************
N*/
N
NCPU_CHAR  *Str_Char (CPU_CHAR  *pstr,
N                     CPU_CHAR   srch_char)
N{
N    CPU_CHAR  *pstr_next;
N
N
N    if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if srch str ptr NULL (see Note #2a).        */
N        return ((CPU_CHAR *)0);
N    }
N
N
N    pstr_next = pstr;
N    pstr_next++;
N    while (( pstr_next != (CPU_CHAR *)0) &&                     /* Srch str until NULL ptr(s) (see Note #2b) ...        */
N           (*pstr      != (CPU_CHAR  )0) &&                     /* ... or NULL char           (see Note #2c) ...        */
N           (*pstr      != (CPU_CHAR  )srch_char)) {             /* ... or srch char found     (see Note #2d).           */
N        pstr++;
N        pstr_next++;
N    }
N
N
N    if (*pstr != srch_char) {                                   /* If srch char NOT found, str points to NULL; ...      */
N        return ((CPU_CHAR *)0);                                 /* ... rtn NULL (see Notes #2b & #2c).                  */
N    }
N
N    return (pstr);                                              /* Else rtn ptr to found srch char (see Note #2d).      */
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            Str_Char_N()
N*
N* Description : Search string for first occurrence of specific character, up to a maximum number of characters.
N*
N* Argument(s) : pstr            Pointer to string (see Note #1).
N*
N*               len_max         Maximum number of characters to search (see Notes #2e & #3).
N*
N*               srch_char       Search character.
N*
N* Return(s)   : Pointer to first occurrence of search character in string, if any.
N*
N*               Pointer to NULL,                                           otherwise.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) String buffer NOT modified.
N*
N*               (2) String search terminates when :
N*
N*                   (a) String pointer passed a NULL pointer.
N*                       (1) No string search performed; NULL pointer returned.
N*
N*                   (b) String pointer points to NULL.
N*                       (1) String overlaps with NULL address.
N*                       (2) String searched up to but NOT beyond or including the NULL address.
N*
N*                   (c) String's terminating NULL character found.
N*                       (1) Search character NOT found in search string; NULL pointer returned.
N*                       (2) Applicable ONLY IF search character is NOT the terminating NULL character.
N*
N*                   (d) Search character found.
N*                       (1) Return pointer to first occurrence of search character in search string.
N*
N*                   (e) 'len_max' number of characters searched.
N*                       (1) 'len_max' number of characters does NOT include terminating NULL character.
N*
N*               (3) Ideally, the 'len_max' parameter would be the last parameter in this function's
N*                   paramter list for consistency with all other custom string library functions.
N*                   However, the 'len_max' parameter is ordered to comply with the standard library
N*                   function's parameter list.
N*********************************************************************************************************
N*/
N
NCPU_CHAR  *Str_Char_N (CPU_CHAR    *pstr,
N                       CPU_SIZE_T   len_max,
N                       CPU_CHAR     srch_char)
N{
N    CPU_CHAR    *pstr_next;
N    CPU_SIZE_T   len_srch;
N
N
N    if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if srch str ptr NULL    (see Note #2a).     */
N        return ((CPU_CHAR *)0);
N    }
N
N    if (len_max == (CPU_SIZE_T)0) {                             /* Rtn NULL if srch len equals zero (see Note #2e).     */
N        return ((CPU_CHAR *)0);
N    }
N
N
N    pstr_next = pstr;
N    pstr_next++;
N    len_srch  = 0;
N    while (( pstr_next != (CPU_CHAR *)0)         &&             /* Srch str until NULL ptr(s)  (see Note #2b)  ...      */
N           (*pstr      != (CPU_CHAR  )0)         &&             /* ... or NULL char            (see Note #2c)  ...      */
N           (*pstr      != (CPU_CHAR  )srch_char) &&             /* ... or srch char found      (see Note #2d); ...      */
N           ( len_srch  <  (CPU_SIZE_T)len_max)) {               /* ... or max nbr chars srch'd (see Note #2e).          */
N        pstr++;
N        pstr_next++;
N        len_srch++;
N    }
N
N
N    if (*pstr != srch_char) {                                   /* If srch char NOT found, str points to NULL; ...      */
N        return ((CPU_CHAR *)0);                                 /* ... rtn NULL (see Notes #2b & #2c).                  */
N    }
N
N    return (pstr);                                              /* Else rtn ptr to found srch char (see Note #2d).      */
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                           Str_Char_Last()
N*
N* Description : Search string for last occurrence of specific character.
N*
N* Argument(s) : pstr            Pointer to string (see Note #1).
N*
N*               srch_char       Search character.
N*
N* Return(s)   : Pointer to last occurrence of search character in string, if any.
N*
N*               Pointer to NULL,                                          otherwise.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) String buffer NOT modified.
N*
N*               (2) String search terminates when :
N*
N*                   (a) String pointer passed a NULL pointer.
N*                       (1) No string search performed; NULL pointer returned.
N*
N*                   (b) String pointer points to NULL.
N*                       (1) String overlaps with NULL address.
N*                       (2) String searched up to but NOT beyond or including the NULL address.
N*                       (3) NULL address boundary handled in Str_Len().
N*
N*                   (c) String searched from end to beginning.
N*                       (1) Search character NOT found in search string; NULL pointer returned.
N*                       (2) Applicable ONLY IF search character is NOT the terminating NULL character.
N*
N*                   (d) Search character found.
N*                       (1) Return pointer to first occurrence of search character in search string.
N*********************************************************************************************************
N*/
N
NCPU_CHAR  *Str_Char_Last (CPU_CHAR  *pstr,
N                          CPU_CHAR   srch_char)
N{
N    CPU_CHAR    *pstr_next;
N    CPU_SIZE_T   str_len;
N
N
N    if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if srch str ptr NULL (see Note #2a).        */
N        return ((CPU_CHAR *)0);
N    }
N
N
N    pstr_next  = pstr;
N    str_len    = Str_Len(pstr);
N    pstr_next += str_len;
N    while (( pstr_next != pstr) &&                              /* Srch str from end until beg (see Note #2c) ...       */
N           (*pstr_next != srch_char)) {                         /* ... until srch char found   (see Note #2d).          */
N        pstr_next--;
N    }
N
N
N    if (*pstr_next != srch_char) {                              /* If srch char NOT found, str points to NULL; ...      */
N        return ((CPU_CHAR *)0);                                 /* ... rtn NULL (see Notes #2b & #2c).                  */
N    }
N
N    return (pstr_next);                                         /* Else rtn ptr to found srch char (see Note #2d).      */
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             Str_Str()
N*
N* Description : Search string for first occurence of a specific search string.
N*
N* Argument(s) : pstr            Pointer to        string (see Note #1).
N*
N*               psrch_str       Pointer to search string (see Note #1).
N*
N* Return(s)   : Pointer to first occurrence of search string in string, if any.
N*
N*               Pointer to NULL,                                        otherwise.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) String buffers NOT modified.
N*
N*               (2) String search terminates when :
N*
N*                   (a) String pointer passed a NULL pointer.
N*                       (1) No string search performed; NULL pointer returned.
N*
N*                   (b) Search string length greater than string length.
N*                       (1) No string search performed; NULL pointer returned.
N*
N*                   (c) Search string length equal to zero.
N*                       (1) NULL search string at end of string returned.
N*
N*                   (d) Entire string has been searched.
N*                       (1) Maximum size of the search is defined as the subtraction of the
N*                           search string length from the string length.
N*                       (2) Search string not found; NULL pointer returned.
N*
N*                   (e) Search string found.
N*                       (1) Search string found according to Str_Cmp_N() return value.
N*                       (2) Return pointer to first occurrence of search string in string.
N*********************************************************************************************************
N*/
N
NCPU_CHAR  *Str_Str (CPU_CHAR  *pstr,
N                    CPU_CHAR  *psrch_str)
N{
N    CPU_SIZE_T    str_len;
N    CPU_SIZE_T    srch_str_len;
N    CPU_SIZE_T    srch_len;
N    CPU_SIZE_T    srch_ix;
N    CPU_BOOLEAN   srch_done;
N    CPU_INT16S    srch_cmp1;
N    CPU_CHAR     *pstr_srch_ix;
N
N                                                                /* Rtn NULL if str ptr(s) NULL (see Note #2a).          */
N    if (pstr == (CPU_CHAR *)0) {
N        return ((CPU_CHAR *)0);
N    }
N    if (psrch_str == (CPU_CHAR *)0) {
N        return ((CPU_CHAR *)0);
N    }
N
N
N    str_len      = Str_Len(pstr);
N    srch_str_len = Str_Len(psrch_str);
N    if (srch_str_len > str_len) {                               /* If srch str len > str len, rtn NULL  (see Note #2b). */
N        return ((CPU_CHAR *)0);
N    }
N    if (srch_str_len == 0) {                                    /* If srch str len = 0, srch str equal NULL str; ...    */
N        pstr_srch_ix = (CPU_CHAR *)(pstr + str_len);            /* ... rtn ptr to NULL str found in str (see Note #2c). */
N        return (pstr_srch_ix);
N    }
N
N    srch_len  = str_len - srch_str_len;                         /* Determine srch len (see Note #2d1).                  */
N    srch_ix   = 0;
N    srch_done = DEF_NO;
X    srch_done = 0;
N    while ((srch_done == DEF_NO) && (srch_ix <= srch_len)) {
X    while ((srch_done == 0) && (srch_ix <= srch_len)) {
N        pstr_srch_ix = (CPU_CHAR *)(pstr + srch_ix);
N        srch_cmp1     =  Str_Cmp_N(pstr_srch_ix, psrch_str, srch_str_len);
N        srch_done    = (srch_cmp1 == 0) ? DEF_YES : DEF_NO;
X        srch_done    = (srch_cmp1 == 0) ? 1 : 0;
N        srch_ix++;
N    }
N
N
N    if (srch_cmp1 != 0) {                                        /* If srch str NOT found, rtn NULL  (see Note #2d).     */
N        return ((CPU_CHAR *)0);
N    }
N
N    return (pstr_srch_ix);                                      /* Rtn ptr to srch str found in str (see Note #2e).     */
N}
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                           Str_FmtNbr_32()
N*
N* Description : Format number into a multi-digit character string.
N*
N* Argument(s) : nbr             Number                          to format (see Note #1).
N*
N*               nbr_dig         Number of integer        digits to format (see Note #2).
N*
N*               nbr_dp          Number of decimal point  digits to format.
N*
N*               lead_zeros      Prepend leading zeros    option (DEF_YES/DEF_NO) [see Note #3].
N*
N*               nul             NULL-character terminate option (DEF_YES/DEF_NO) [see Note #4].
N*
N*               pstr_fmt        Pointer to character array to return formatted number string (see Note #5).
N*
N* Return(s)   : Pointer to formatted string, if NO errors (see Note #6).
N*
N*               Pointer to NULL,             otherwise.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) The maximum accuracy for 32-bit floating-point numbers :
N*
N*
N*                                 Maximum Accuracy            log [Internal-Base ^ (Number-Internal-Base-Digits)]
N*                           32-bit Floating-point Number  =  -----------------------------------------------------
N*                                                                             log [External-Base]
N*
N*                                                             log [2 ^ 24]
N*                                                         =  --------------
N*                                                               log [10]
N*
N*                                                         <  7.225  Base-10 Digits
N*
N*                               where
N*                                       Internal-Base                   Internal number base of floating-
N*                                                                           point numbers (i.e.  2)
N*                                       External-Base                   External number base of floating-
N*                                                                           point numbers (i.e. 10)
N*                                       Number-Internal-Base-Digits     Number of internal number base
N*                                                                           significant digits (i.e. 24)
N*
N*                   (b) Some compilers' floating-point routines MAY further reduce the maximum accuracy.
N*
N*                   (c) If the total number of digits to format ('nbr_dig + nbr_dp') is greater than the 
N*                       maximum accuracy; digits following the first, significantly-accurate digits will
N*                       be inaccurate.
N*
N*               (2) (a) If the number of digits to format ('nbr_dig') is less than the number of significant
N*                       integer digits of the number to format ('nbr'); then the most-significant digits of
N*                       the formatted number will be truncated.
N*
N*                           Example :
N*
N*                               nbr      = 23456.789
N*                               nbr_dig  = 3
N*                               nbr_dp   = 2
N*
N*                               pstr_fmt = "456.78"
N*
N*                   (b) If number to format ('nbr') is negative but the most-significant digits of the
N*                       formatted number are truncated (see Note #2a); the negative sign still prefixes
N*                       the truncated formatted number.
N*
N*                           Example :
N*
N*                               nbr      = -23456.789
N*                               nbr_dig  =  3
N*                               nbr_dp   =  2
N*
N*                               pstr_fmt = "-456.78"
N*
N*               (3) (a) Leading zeros option prepends leading '0's prior to the first non-zero digit.
N*                       The number of leading zeros is such that the total number integer digits is
N*                       equal to the requested number of integer digits to format ('nbr_dig').
N*
N*                   (b) (1) If leading zeros option DISABLED,                        ...
N*                       (2) ... number of digits to format is non-zero,              ...
N*                       (3) ... & the integer value of the number to format is zero; ...
N*                       (4) ... then one digit of '0' value is formatted.
N*
N*                           This is NOT a leading zero; but a single integer digit of '0' value.
N*
N*               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
N*                       array formatting.
N*
N*                   (b) WARNING: Unless 'pstr_fmt' character array is pre-/post-terminated, NULL-character
N*                       terminate option DISABLED will cause character string run-on.
N*$PAGE*
N*               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
N*
N*                   (b) To prevent character buffer overrun :
N*
N*                           Character array size MUST be  >=  ('nbr_dig'         +
N*                                                              'nbr_dp'          +
N*                                                              1 negative sign   +
N*                                                              1 decimal point   +
N*                                                              1 'NUL' terminator)  characters
N*
N*               (6) String format terminates when :
N*
N*                   (a) Format string pointer is passed a NULL pointer.
N*                       (1) No string format performed; NULL pointer returned.
N*
N*                   (b) Number successfully formatted into character string array.
N*********************************************************************************************************
N*/
N
N#if (LIB_STR_CFG_FP_EN == DEF_ENABLED)
X#if (0 == 1)
SCPU_CHAR  *Str_FmtNbr_32 (CPU_FP32      nbr,
S                          CPU_INT08U    nbr_dig,
S                          CPU_INT08U    nbr_dp,
S                          CPU_BOOLEAN   lead_zeros,
S                          CPU_BOOLEAN   nul,
S                          CPU_CHAR     *pstr_fmt)
S{
S    CPU_CHAR    *pstr;
S    CPU_INT08U   i;
S    CPU_INT32U   dig_nbr;
S    CPU_INT32U   dig_val;
S    CPU_FP32     dig_exp;
S    CPU_FP32     dp_exp;
S
S                                                                /* Rtn NULL if str ptr NULL (see Note #6a).             */
S    if (pstr_fmt == (CPU_CHAR *)0) {
S        return ((CPU_CHAR *)0);
S    }
S
S
S    pstr = pstr_fmt;
S
S    if (nbr < 0.0) {                                            /* If nbr neg,             ...                          */
S        if ((nbr_dig > 0) ||                                    /* ... &  at least one dig ...                          */
S            (nbr_dp  > 0)) {                                    /* ... or at least one dp; ...                          */
S             nbr     = -nbr;                                    /* ... negate nbr &        ...                          */
S            *pstr++  = '-';                                     /* ... prefix with neg sign (see Note #2b).             */
S        }
S    }
S
S    if (nbr_dig > 0) {
S        dig_exp = 1.0;
S        for (i = 1; i < nbr_dig; i++) {
S            dig_exp *= 10.0;
S        }
S        for (i = nbr_dig; i > 0; i--) {                         /* Fmt str for desired nbr digs.                        */
S            dig_nbr = (CPU_INT32U)(nbr / dig_exp);
S            if ((dig_nbr >  0) ||                               /* If dig nbr > 0,                              ...     */
S                (nbr_dig == 1) ||                               /* ... OR exactly 1 dig to fmt,                 ...     */
S                (i       == 1) ||                               /* ... OR on one's  dig to fmt,                 ...     */
S                (lead_zeros == DEF_YES)) {                      /* ... OR lead zeros opt ENABLED (see Note #3), ...     */
S                                                                /* ... calc & fmt dig val.                              */
S                 dig_val = (CPU_INT32U)(dig_nbr % 10 );
S                *pstr++  = (CPU_CHAR  )(dig_val + '0');
S            }
S            dig_exp /= 10.0;                                    /* Shift to next least-significant dig.                 */
S        }
S    }
S
S    if (nbr_dp > 0) {
S       *pstr++ = '.';                                           /* Append dp prior to dp conversion.                    */
S        dp_exp = 10.0;
S        for (i = 0; i < nbr_dp; i++) {                          /* Fmt str for desired nbr dp.                          */
S            dig_nbr  = (CPU_INT32U)(nbr * dp_exp );
S            dig_val  = (CPU_INT32U)(dig_nbr % 10 );
S           *pstr++   = (CPU_CHAR  )(dig_val + '0');
S            dp_exp  *=  10.0;                                   /* Shift to next least-significant dp.                  */
S        }
S    }
S
S    if (nul != DEF_NO) {                                        /* If NOT DISABLED, append NULL char (see Note #4).     */
S       *pstr = (CPU_CHAR)0;
S    }
S
S
S    return (pstr_fmt);
S}
N#endif
N
