L 1 "..\..\..\..\..\uC-CPU\ARM-Cortex-M3\RealView\cpu_c.c"
N/*
N*********************************************************************************************************
N*                                               uC/CPU
N*                                    CPU CONFIGURATION & PORT LAYER
N*
N*                          (c) Copyright 2004-2008; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/CPU is provided in source form for FREE evaluation, for educational
N*               use or peaceful research.  If you plan on using uC/CPU in a commercial
N*               product you need to contact Micrium to properly license its use in your
N*               product.  We provide ALL the source code for your convenience and to
N*               help you experience uC/CPU.  The fact that the source code is provided
N*               does NOT mean that you can use it without paying a licensing fee.
N*
N*               Knowledge of the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest
N*               software available.  Your honesty is greatly appreciated.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                            CPU PORT FILE
N*
N*                                            ARM-Cortex-M3
N*                                      RealView Development Suite
N*                            RealView Microcontroller Development Kit (MDK)
N*                                       ARM Developer Suite (ADS)
N*                                            Keil uVision
N*
N* Filename      : cpu_c.c
N* Version       : V1.19
N* Programmer(s) : JJL
N*                 BAN
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                              INCLUDE FILES
N*********************************************************************************************************
N*/
N
N#include  <cpu.h>
L 1 "..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView\cpu.h" 1
N/*
N*********************************************************************************************************
N*                                               uC/CPU
N*                                    CPU CONFIGURATION & PORT LAYER
N*
N*                          (c) Copyright 2004-2008; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/CPU is provided in source form for FREE evaluation, for educational
N*               use or peaceful research.  If you plan on using uC/CPU in a commercial
N*               product you need to contact Micrium to properly license its use in your
N*               product.  We provide ALL the source code for your convenience and to
N*               help you experience uC/CPU.  The fact that the source code is provided
N*               does NOT mean that you can use it without paying a licensing fee.
N*
N*               Knowledge of the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest
N*               software available.  Your honesty is greatly appreciated.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                            CPU PORT FILE
N*
N*                                            ARM-Cortex-M3
N*                                      RealView Development Suite
N*                            RealView Microcontroller Development Kit (MDK)
N*                                       ARM Developer Suite (ADS)
N*                                            Keil uVision
N*
N* Filename      : cpu.h
N* Version       : V1.19
N* Programmer(s) : JJL
N*                 BAN
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*********************************************************************************************************
N*/
N
N#ifndef  CPU_CFG_MODULE_PRESENT
N#define  CPU_CFG_MODULE_PRESENT
N
N
N/*
N*********************************************************************************************************
N*                                          CPU INCLUDE FILES
N*
N* Note(s) : (1) The following CPU files are located in the following directories :
N*
N*               (a) \<CPU-Compiler Directory>\cpu_def.h
N*
N*               (b) \<CPU-Compiler Directory>\<cpu>\<compiler>\cpu*.*
N*
N*                       where
N*                               <CPU-Compiler Directory>    directory path for common   CPU-compiler software
N*                               <cpu>                       directory name for specific CPU
N*                               <compiler>                  directory name for specific compiler
N*
N*           (2) Compiler MUST be configured to include the '\<CPU-Compiler Directory>\' directory & the
N*               specific CPU-compiler directory as additional include path directories.
N*********************************************************************************************************
N*/
N
N#include  <cpu_def.h>
L 1 "..\..\..\..\..\uC-CPU\cpu_def.h" 1
N/*
N*********************************************************************************************************
N*                                               uC/CPU
N*                                    CPU CONFIGURATION & PORT LAYER
N*
N*                          (c) Copyright 2004-2008; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/CPU is provided in source form for FREE evaluation, for educational
N*               use or peaceful research.  If you plan on using uC/CPU in a commercial
N*               product you need to contact Micrium to properly license its use in your
N*               product.  We provide ALL the source code for your convenience and to
N*               help you experience uC/CPU.  The fact that the source code is provided
N*               does NOT mean that you can use it without paying a licensing fee.
N*
N*               Knowledge of the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest
N*               software available.  Your honesty is greatly appreciated.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                      CPU CONFIGURATION DEFINES
N*
N* Filename      : cpu_def.h
N* Version       : V1.19
N* Programmer(s) : ITJ
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                       CPU WORD CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_ADDR_SIZE & CPU_CFG_DATA_SIZE in 'cpu.h' with CPU's word sizes :
N*
N*                   CPU_WORD_SIZE_08             8-bit word size
N*                   CPU_WORD_SIZE_16            16-bit word size
N*                   CPU_WORD_SIZE_32            32-bit word size
N*                   CPU_WORD_SIZE_64            64-bit word size            See Note #1a
N*
N*               (a) 64-bit word size NOT currently supported.
N*
N*               (b) Ideally, CPU_WORD_SIZE #define's would be calculated at compile-time through use of
N*                   the sizeof() operator.  However, some compilers do NOT allow pre-processor directives
N*                   to include run-time macro's -- e.g. 'sizeof()'.
N*
N*           (2) Configure CPU_CFG_ENDIAN_TYPE in 'cpu.h' with CPU's data-word-memory order :
N*
N*                   CPU_ENDIAN_TYPE_BIG         Big-   endian word order (CPU words' most  significant
N*                                                                         octet @ lowest memory address)
N*                   CPU_ENDIAN_TYPE_LITTLE      Little-endian word order (CPU words' least significant
N*                                                                         octet @ lowest memory address)
N*********************************************************************************************************
N*/
N
N                                                        /* ----------------------- CPU WORD SIZE ---------------------- */
N#define  CPU_WORD_SIZE_08                          1    /*  8-bit word size = sizeof(CPU_INT08x).                       */
N#define  CPU_WORD_SIZE_16                          2    /* 16-bit word size = sizeof(CPU_INT16x).                       */
N#define  CPU_WORD_SIZE_32                          4    /* 32-bit word size = sizeof(CPU_INT32x).                       */
N#define  CPU_WORD_SIZE_64                          8    /* 64-bit word size = sizeof(CPU_INT64x) [see Note #1a].        */
N
N
N                                                        /* ------------------- CPU WORD-ENDIAN ORDER ------------------ */
N#define  CPU_ENDIAN_TYPE_NONE                      0    /*                                                              */
N#define  CPU_ENDIAN_TYPE_BIG                       1    /* Big-   endian word order (CPU words' most  significant ...   */
N                                                        /*                           ... octet @ lowest mem addr).      */
N#define  CPU_ENDIAN_TYPE_LITTLE                    2    /* Little-endian word order (CPU words' least significant ...   */
N                                                        /*                           ... octet @ lowest mem addr).      */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                   CRITICAL SECTION CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_CRITICAL_METHOD with CPU's/compiler's critical section method :
N*
N*                                                       Enter/Exit critical sections by ...
N*
N*                   CPU_CRITICAL_METHOD_INT_DIS_EN      Disable/Enable interrupts
N*                   CPU_CRITICAL_METHOD_STATUS_STK      Push/Pop       interrupt status onto stack
N*                   CPU_CRITICAL_METHOD_STATUS_LOCAL    Save/Restore   interrupt status to local variable
N*
N*               (a) CPU_CRITICAL_METHOD_INT_DIS_EN  is NOT a preferred method since it does NOT support
N*                   multiple levels of interrupts.  However, with some CPUs/compilers, this is the only
N*                   available method.
N*
N*               (b) CPU_CRITICAL_METHOD_STATUS_STK    is one preferred method since it DOES support multiple
N*                   levels of interrupts.  However, this method assumes that the compiler allows in-line
N*                   assembly AND will correctly modify the local stack pointer when interrupt status is
N*                   pushed/popped onto the stack.
N*
N*               (c) CPU_CRITICAL_METHOD_STATUS_LOCAL  is one preferred method since it DOES support multiple
N*                   levels of interrupts.  However, this method assumes that the compiler provides C-level
N*                   &/or assembly-level functionality for the following :
N*
N*                     ENTER CRITICAL SECTION :
N*                       (a) Save    interrupt status into a local variable
N*                       (b) Disable interrupts
N*
N*                     EXIT  CRITICAL SECTION :
N*                       (c) Restore interrupt status from a local variable
N*
N*           (2) Critical section macro's most likely require inline assembly.  If the compiler does NOT
N*               allow inline assembly in C source files, critical section macro's MUST call an assembly
N*               subroutine defined in a 'cpu_a.asm' file located in the following software directory :
N*
N*                   \<CPU-Compiler Directory>\<cpu>\<compiler>\
N*
X
N*                       where
N*                               <CPU-Compiler Directory>    directory path for common   CPU-compiler software
N*                               <cpu>                       directory name for specific CPU
N*                               <compiler>                  directory name for specific compiler
N*
N*           (3) To save/restore interrupt status, a local variable 'cpu_sr' of type 'CPU_SR' MAY need to
N*               be declared (e.g. if 'CPU_CRITICAL_METHOD_STATUS_LOCAL' method is configured).  Configure
N*               'CPU_SR' data type in 'cpu.h' with the appropriate-sized CPU data type large enough to
N*               completely store the CPU's/compiler's status word.
N*********************************************************************************************************
N*/
N
N                                                        /* --------------- CPU CRITICAL SECTION METHODS --------------- */
N#define  CPU_CRITICAL_METHOD_NONE                  0    /*                                                              */
N#define  CPU_CRITICAL_METHOD_INT_DIS_EN            1    /* DIS/EN       ints.                                           */
N#define  CPU_CRITICAL_METHOD_STATUS_STK            2    /* Push/Pop     int status onto stk.                            */
N#define  CPU_CRITICAL_METHOD_STATUS_LOCAL          3    /* Save/Restore int status to local var.                        */
N
L 74 "..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView\cpu.h" 2
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                    CONFIGURE STANDARD DATA TYPES
N*
N* Note(s) : (1) Configure standard data types according to CPU-/compiler-specifications.
N*
N*           (2) (a) (1) 'CPU_FNCT_VOID' data type defined to replace the commonly-used function pointer
N*                       data type of a pointer to a function which returns void & has no arguments.
N*
N*                   (2) Example function pointer usage :
N*
N*                           CPU_FNCT_VOID  FnctName;
N*
N*                           FnctName();
N*
N*               (b) (1) 'CPU_FNCT_PTR'  data type defined to replace the commonly-used function pointer
N*                       data type of a pointer to a function which returns void & has a single void
N*                       pointer argument.
N*
N*                   (2) Example function pointer usage :
N*
N*                           CPU_FNCT_PTR   FnctName;
N*                           void          *pobj
N*
N*                           FnctName(pobj);
N*********************************************************************************************************
N*/
N
Ntypedef            void       CPU_VOID;
Ntypedef  unsigned  char       CPU_CHAR;                         /*  8-bit character                                     */
Ntypedef  unsigned  char       CPU_BOOLEAN;                      /*  8-bit boolean or logical                            */
Ntypedef  unsigned  char       CPU_INT08U;                       /*  8-bit unsigned integer                              */
Ntypedef    signed  char       CPU_INT08S;                       /*  8-bit   signed integer                              */
Ntypedef  unsigned  short      CPU_INT16U;                       /* 16-bit unsigned integer                              */
Ntypedef    signed  short      CPU_INT16S;                       /* 16-bit   signed integer                              */
Ntypedef  unsigned  int        CPU_INT32U;                       /* 32-bit unsigned integer                              */
Ntypedef    signed  int        CPU_INT32S;                       /* 32-bit   signed integer                              */
Ntypedef  unsigned  long long  CPU_INT64U;                       /* 64-bit unsigned integer                              */
Ntypedef    signed  long long  CPU_INT64S;                       /* 64-bit   signed integer                              */
N
Ntypedef            float      CPU_FP32;                         /* 32-bit floating point                                */
Ntypedef            double     CPU_FP64;                         /* 64-bit floating point                                */
N
N
Ntypedef            void     (*CPU_FNCT_VOID)(void);             /* See Note #2a.                                        */
Ntypedef            void     (*CPU_FNCT_PTR )(void *);           /* See Note #2b.                                        */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                       CPU WORD CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_ADDR_SIZE & CPU_CFG_DATA_SIZE with CPU's word sizes :
N*
N*                   CPU_WORD_SIZE_08             8-bit word size
N*                   CPU_WORD_SIZE_16            16-bit word size
N*                   CPU_WORD_SIZE_32            32-bit word size
N*                   CPU_WORD_SIZE_64            64-bit word size            See Note #1a
N*
N*               (a) 64-bit word size NOT currently supported.
N*
N*           (2) Configure CPU_CFG_ENDIAN_TYPE with CPU's data-word-memory order :
N*
N*                   CPU_ENDIAN_TYPE_BIG         Big-   endian word order (CPU words' most  significant
N*                                                                         octet @ lowest memory address)
N*                   CPU_ENDIAN_TYPE_LITTLE      Little-endian word order (CPU words' least significant
N*                                                                         octet @ lowest memory address)
N*********************************************************************************************************
N*/
N
N                                                                /* Define  CPU         word sizes (see Note #1) :       */
N#define  CPU_CFG_ADDR_SIZE              CPU_WORD_SIZE_32        /* Defines CPU address word size.                       */
N
N#define  CPU_CFG_DATA_SIZE              CPU_WORD_SIZE_32        /* Defines CPU data    word size.                       */
N#define  CPU_CFG_ENDIAN_TYPE            CPU_ENDIAN_TYPE_LITTLE  /* Defines CPU data    word-memory order.               */
N
N
N/*
N*********************************************************************************************************
N*                                 CONFIGURE CPU ADDRESS & DATA TYPES
N*********************************************************************************************************
N*/
N
N                                                                /* CPU address type based on address bus size.          */
N#if     (CPU_CFG_ADDR_SIZE == CPU_WORD_SIZE_32)
X#if     (4 == 4)
Ntypedef  CPU_INT32U  CPU_ADDR;
N#elif   (CPU_CFG_ADDR_SIZE == CPU_WORD_SIZE_16)
Stypedef  CPU_INT16U  CPU_ADDR;
S#else
Stypedef  CPU_INT08U  CPU_ADDR;
N#endif
N
N                                                                /* CPU data    type based on data    bus size.          */
N#if     (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_32)
X#if     (4 == 4)
Ntypedef  CPU_INT32U  CPU_DATA;
N#elif   (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_16)
Stypedef  CPU_INT16U  CPU_DATA;
S#else
Stypedef  CPU_INT08U  CPU_DATA;
N#endif
N
N
Ntypedef  CPU_DATA    CPU_ALIGN;                                 /* Defines CPU data-word-alignment size.                */
Ntypedef  CPU_DATA    CPU_SIZE_T;                                /* Defines CPU standard 'size_t'   size.                */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                   CRITICAL SECTION CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_CRITICAL_METHOD with CPU's/compiler's critical section method :
N*
N*                                                       Enter/Exit critical sections by ...
N*
N*                   CPU_CRITICAL_METHOD_INT_DIS_EN      Disable/Enable interrupts
N*                   CPU_CRITICAL_METHOD_STATUS_STK      Push/Pop       interrupt status onto stack
N*                   CPU_CRITICAL_METHOD_STATUS_LOCAL    Save/Restore   interrupt status to local variable
N*
N*               (a) CPU_CRITICAL_METHOD_INT_DIS_EN  is NOT a preferred method since it does NOT support
N*                   multiple levels of interrupts.  However, with some CPUs/compilers, this is the only
N*                   available method.
N*
N*               (b) CPU_CRITICAL_METHOD_STATUS_STK    is one preferred method since it DOES support multiple
N*                   levels of interrupts.  However, this method assumes that the compiler allows in-line
N*                   assembly AND will correctly modify the local stack pointer when interrupt status is
N*                   pushed/popped onto the stack.
N*
N*               (c) CPU_CRITICAL_METHOD_STATUS_LOCAL  is one preferred method since it DOES support multiple
N*                   levels of interrupts.  However, this method assumes that the compiler provides C-level
N*                   &/or assembly-level functionality for the following :
N*
N*                     ENTER CRITICAL SECTION :
N*                       (a) Save    interrupt status into a local variable
N*                       (b) Disable interrupts
N*
N*                     EXIT  CRITICAL SECTION :
N*                       (c) Restore interrupt status from a local variable
N*
N*           (2) Critical section macro's most likely require inline assembly.  If the compiler does NOT
N*               allow inline assembly in C source files, critical section macro's MUST call an assembly
N*               subroutine defined in a 'cpu_a.asm' file located in the following software directory :
N*
N*                   \<CPU-Compiler Directory>\<cpu>\<compiler>\
N*
X
N*                       where
N*                               <CPU-Compiler Directory>    directory path for common   CPU-compiler software
N*                               <cpu>                       directory name for specific CPU
N*                               <compiler>                  directory name for specific compiler
N*
N*           (3) To save/restore interrupt status, a local variable 'cpu_sr' of type 'CPU_SR' MAY need to
N*               be declared (e.g. if 'CPU_CRITICAL_METHOD_STATUS_LOCAL' method is configured).  Configure
N*               'CPU_SR' data type with the appropriate-sized CPU data type large enough to completely
N*               store the CPU's/compiler's status word.
N*********************************************************************************************************
N*/
N
Ntypedef  CPU_INT32U  CPU_SR;                                    /* Defines   CPU status register size (see Note #3).    */
N
N                                                                /* Configure CPU critical method      (see Note #1) :   */
N#define  CPU_CFG_CRITICAL_METHOD        CPU_CRITICAL_METHOD_STATUS_LOCAL
N
N#define  CPU_CRITICAL_ENTER()           { cpu_sr = CPU_SR_Save(); }
N#define  CPU_CRITICAL_EXIT()            { CPU_SR_Restore(cpu_sr); }
N
N
N/*
N*********************************************************************************************************
N*                                         FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
Nvoid        CPU_IntDis       (void);
Nvoid        CPU_IntEn        (void);
N
Nvoid        CPU_IntSrcDis    (CPU_INT08U  pos);
Nvoid        CPU_IntSrcEn     (CPU_INT08U  pos);
NCPU_INT16S  CPU_IntSrcPrioGet(CPU_INT08U  pos);
Nvoid        CPU_IntSrcPrioSet(CPU_INT08U  pos,
N                              CPU_INT08U  prio);
N
NCPU_SR      CPU_SR_Save      (void);
Nvoid        CPU_SR_Restore   (CPU_SR      cpu_sr);
N
NCPU_INT32U  CPU_CntLeadZeros (CPU_INT32U  val);
NCPU_INT32U  CPU_RevBits      (CPU_INT32U  val);
N
Nvoid        CPU_WaitForInt   (void);
Nvoid        CPU_WaitForExcept(void);
N
Nvoid        CPU_BitBandClr   (CPU_ADDR    addr,
N                              CPU_INT08U  bit_nbr);
Nvoid        CPU_BitBandSet   (CPU_ADDR    addr,
N                              CPU_INT08U  bit_nbr);
N
N/*
N*********************************************************************************************************
N*                                           INTERRUPT SOURCES
N*********************************************************************************************************
N*/
N
N#define  CPU_INT_STK_PTR                                   0
N#define  CPU_INT_RESET                                     1
N#define  CPU_INT_NMI                                       2
N#define  CPU_INT_HFAULT                                    3
N#define  CPU_INT_MEM                                       4
N#define  CPU_INT_BUSFAULT                                  5
N#define  CPU_INT_USAGEFAULT                                6
N#define  CPU_INT_RSVD_07                                   7
N#define  CPU_INT_RSVD_08                                   8
N#define  CPU_INT_RSVD_09                                   9
N#define  CPU_INT_RSVD_10                                  10
N#define  CPU_INT_SVCALL                                   11
N#define  CPU_INT_DBGMON                                   12
N#define  CPU_INT_RSVD_13                                  13
N#define  CPU_INT_PENDSV                                   14
N#define  CPU_INT_SYSTICK                                  15
N
N
N/*
N*********************************************************************************************************
N*                                             CPU REGISTERS
N*********************************************************************************************************
N*/
N
N#define  CPU_REG_NVIC_NVIC              (*((volatile CPU_INT32U *)(0xE000E004))) /* Int Ctrl'er Type Reg.               */
N#define  CPU_REG_NVIC_ST_CTRL           (*((volatile CPU_INT32U *)(0xE000E010))) /* SysTick Ctrl & Status Reg.          */
N#define  CPU_REG_NVIC_ST_RELOAD         (*((volatile CPU_INT32U *)(0xE000E014))) /* SysTick Reload      Value Reg.      */
N#define  CPU_REG_NVIC_ST_CURRENT        (*((volatile CPU_INT32U *)(0xE000E018))) /* SysTick Current     Value Reg.      */
N#define  CPU_REG_NVIC_ST_CAL            (*((volatile CPU_INT32U *)(0xE000E01C))) /* SysTick Calibration Value Reg.      */
N                                                                                 /* IRQ Set En Reg.                     */
N#define  CPU_REG_NVIC_SETEN(n)          (*((volatile CPU_INT32U *)(0xE000E100 + (n) * 4)))
N                                                                                 /* IRQ Clr En Reg.                     */
N#define  CPU_REG_NVIC_CLREN(n)          (*((volatile CPU_INT32U *)(0xE000E180 + (n) * 4)))
N                                                                                 /* IRQ Set Pending Reg.                */
N#define  CPU_REG_NVIC_SETPEND(n)        (*((volatile CPU_INT32U *)(0xE000E200 + (n) * 4)))
N                                                                                 /* IRQ Clr Pending Reg.                */
N#define  CPU_REG_NVIC_CLRPEND(n)        (*((volatile CPU_INT32U *)(0xE000E280 + (n) * 4)))
N                                                                                 /* IRQ Active Reg.                     */
N#define  CPU_REG_NVIC_ACTIVE(n)         (*((volatile CPU_INT32U *)(0xE000E300 + (n) * 4)))
N                                                                                 /* IRQ Prio Reg.                       */
N#define  CPU_REG_NVIC_PRIO(n)           (*((volatile CPU_INT32U *)(0xE000E400 + (n) * 4)))
N
N#define  CPU_REG_NVIC_CPUID             (*((volatile CPU_INT32U *)(0xE000ED00))) /* CPUID Base Reg.                     */
N#define  CPU_REG_NVIC_ICSR              (*((volatile CPU_INT32U *)(0xE000ED04))) /* Int Ctrl State  Reg.                */
N#define  CPU_REG_NVIC_VTOR              (*((volatile CPU_INT32U *)(0xE000ED08))) /* Vect Tbl Offset Reg.                */
N#define  CPU_REG_NVIC_AIRCR             (*((volatile CPU_INT32U *)(0xE000ED0C))) /* App Int/Reset Ctrl Reg.             */
N#define  CPU_REG_NVIC_SCR               (*((volatile CPU_INT32U *)(0xE000ED10))) /* System Ctrl Reg.                    */
N#define  CPU_REG_NVIC_CCR               (*((volatile CPU_INT32U *)(0xE000ED14))) /* Cfg    Ctrl Reg.                    */
N#define  CPU_REG_NVIC_SHPRI1            (*((volatile CPU_INT32U *)(0xE000ED18))) /* System Handlers  4 to  7 Prio.      */
N#define  CPU_REG_NVIC_SHPRI2            (*((volatile CPU_INT32U *)(0xE000ED1C))) /* System Handlers  8 to 11 Prio.      */
N#define  CPU_REG_NVIC_SHPRI3            (*((volatile CPU_INT32U *)(0xE000ED20))) /* System Handlers 12 to 15 Prio.      */
N#define  CPU_REG_NVIC_SHCSR             (*((volatile CPU_INT32U *)(0xE000ED24))) /* System Handler Ctrl & State Reg.    */
N#define  CPU_REG_NVIC_CFSR              (*((volatile CPU_INT32U *)(0xE000ED28))) /* Configurable Fault Status Reg.      */
N#define  CPU_REG_NVIC_HFSR              (*((volatile CPU_INT32U *)(0xE000ED2C))) /* Hard  Fault Status Reg.             */
N#define  CPU_REG_NVIC_DFSR              (*((volatile CPU_INT32U *)(0xE000ED30))) /* Debug Fault Status Reg.             */
N#define  CPU_REG_NVIC_MMFAR             (*((volatile CPU_INT32U *)(0xE000ED34))) /* Mem Manage Addr Reg.                */
N#define  CPU_REG_NVIC_BFAR              (*((volatile CPU_INT32U *)(0xE000ED38))) /* Bus Fault  Addr Reg.                */
N#define  CPU_REG_NVIC_AFSR              (*((volatile CPU_INT32U *)(0xE000ED3C))) /* Aux Fault Status Reg.               */
N
N#define  CPU_REG_NVIC_PFR0              (*((volatile CPU_INT32U *)(0xE000ED40))) /* Processor Feature Reg 0.            */
N#define  CPU_REG_NVIC_PFR1              (*((volatile CPU_INT32U *)(0xE000ED44))) /* Processor Feature Reg 1.            */
N#define  CPU_REG_NVIC_DFR0              (*((volatile CPU_INT32U *)(0xE000ED48))) /* Debug     Feature Reg 0.            */
N#define  CPU_REG_NVIC_AFR0              (*((volatile CPU_INT32U *)(0xE000ED4C))) /* Aux       Feature Reg 0.            */
N#define  CPU_REG_NVIC_MMFR0             (*((volatile CPU_INT32U *)(0xE000ED50))) /* Memory Model Feature Reg 0.         */
N#define  CPU_REG_NVIC_MMFR1             (*((volatile CPU_INT32U *)(0xE000ED54))) /* Memory Model Feature Reg 1.         */
N#define  CPU_REG_NVIC_MMFR2             (*((volatile CPU_INT32U *)(0xE000ED58))) /* Memory Model Feature Reg 2.         */
N#define  CPU_REG_NVIC_MMFR3             (*((volatile CPU_INT32U *)(0xE000ED5C))) /* Memory Model Feature Reg 3.         */
N#define  CPU_REG_NVIC_ISAFR0            (*((volatile CPU_INT32U *)(0xE000ED60))) /* ISA Feature Reg 0.                  */
N#define  CPU_REG_NVIC_ISAFR1            (*((volatile CPU_INT32U *)(0xE000ED64))) /* ISA Feature Reg 1.                  */
N#define  CPU_REG_NVIC_ISAFR2            (*((volatile CPU_INT32U *)(0xE000ED68))) /* ISA Feature Reg 2.                  */
N#define  CPU_REG_NVIC_ISAFR3            (*((volatile CPU_INT32U *)(0xE000ED6C))) /* ISA Feature Reg 3.                  */
N#define  CPU_REG_NVIC_ISAFR4            (*((volatile CPU_INT32U *)(0xE000ED70))) /* ISA Feature Reg 4.                  */
N#define  CPU_REG_NVIC_SW_TRIG           (*((volatile CPU_INT32U *)(0xE000EF00))) /* Software Trigger Int Reg.           */
N
N#define  CPU_REG_MPU_TYPE               (*((volatile CPU_INT32U *)(0xE000ED90))) /* MPU Type Reg.                       */
N#define  CPU_REG_MPU_CTRL               (*((volatile CPU_INT32U *)(0xE000ED94))) /* MPU Ctrl Reg.                       */
N#define  CPU_REG_MPU_REG_NBR            (*((volatile CPU_INT32U *)(0xE000ED98))) /* MPU Region Nbr Reg.                 */
N#define  CPU_REG_MPU_REG_BASE           (*((volatile CPU_INT32U *)(0xE000ED9C))) /* MPU Region Base Addr Reg.           */
N#define  CPU_REG_MPU_REG_ATTR           (*((volatile CPU_INT32U *)(0xE000EDA0))) /* MPU Region Attrib & Size Reg.       */
N
N#define  CPU_REG_DBG_CTRL               (*((volatile CPU_INT32U *)(0xE000EDF0))) /* Debug Halting Ctrl & Status Reg.    */
N#define  CPU_REG_DBG_SELECT             (*((volatile CPU_INT32U *)(0xE000EDF4))) /* Debug Core Reg Selector Reg.        */
N#define  CPU_REG_DBG_DATA               (*((volatile CPU_INT32U *)(0xE000EDF8))) /* Debug Core Reg Data     Reg.        */
N#define  CPU_REG_DBG_INT                (*((volatile CPU_INT32U *)(0xE000EDFC))) /* Debug Except & Monitor Ctrl Reg.    */
N
N/*
N*********************************************************************************************************
N*                                          CPU REGISTER BITS
N*********************************************************************************************************
N*/
N
N                                                                /* ---------- SYSTICK CTRL & STATUS REG BITS ---------- */
N#define  CPU_REG_NVIC_ST_CTRL_COUNTFLAG         DEF_BIT_16
N#define  CPU_REG_NVIC_ST_CTRL_CLKSOURCE         DEF_BIT_02
N#define  CPU_REG_NVIC_ST_CTRL_TICKINT           DEF_BIT_01
N#define  CPU_REG_NVIC_ST_CTRL_ENABLE            DEF_BIT_00
N
N
N                                                                /* -------- SYSTICK CALIBRATION VALUE REG BITS -------- */
N#define  CPU_REG_NVIC_ST_CAL_NOREF              DEF_BIT_31
N#define  CPU_REG_NVIC_ST_CAL_SKEW               DEF_BIT_30
N
N                                                                /* -------------- INT CTRL STATE REG BITS ------------- */
N#define  CPU_REG_NVIC_ICSR_NMIPENDSET           DEF_BIT_31
N#define  CPU_REG_NVIC_ICSR_PENDSVSET            DEF_BIT_28
N#define  CPU_REG_NVIC_ICSR_PENDSVCLR            DEF_BIT_27
N#define  CPU_REG_NVIC_ICSR_PENDSTSET            DEF_BIT_26
N#define  CPU_REG_NVIC_ICSR_PENDSTCLR            DEF_BIT_25
N#define  CPU_REG_NVIC_ICSR_ISRPREEMPT           DEF_BIT_23
N#define  CPU_REG_NVIC_ICSR_ISRPENDING           DEF_BIT_22
N#define  CPU_REG_NVIC_ICSR_RETTOBASE            DEF_BIT_11
N
N                                                                /* ------------- VECT TBL OFFSET REG BITS ------------- */
N#define  CPU_REG_NVIC_VTOR_TBLBASE              DEF_BIT_29
N
N                                                                /* ------------ APP INT/RESET CTRL REG BITS ----------- */
N#define  CPU_REG_NVIC_AIRCR_ENDIANNESS          DEF_BIT_15
N#define  CPU_REG_NVIC_AIRCR_SYSRESETREQ         DEF_BIT_02
N#define  CPU_REG_NVIC_AIRCR_VECTCLRACTIVE       DEF_BIT_01
N#define  CPU_REG_NVIC_AIRCR_VECTRESET           DEF_BIT_00
N
N                                                                /* --------------- SYSTEM CTRL REG BITS --------------- */
N#define  CPU_REG_NVIC_SCR_SEVONPEND             DEF_BIT_04
N#define  CPU_REG_NVIC_SCR_SLEEPDEEP             DEF_BIT_02
N#define  CPU_REG_NVIC_SCR_SLEEPONEXIT           DEF_BIT_01
N
N                                                                /* ----------------- CFG CTRL REG BITS ---------------- */
N#define  CPU_REG_NVIC_CCR_STKALIGN              DEF_BIT_09
N#define  CPU_REG_NVIC_CCR_BFHFNMIGN             DEF_BIT_08
N#define  CPU_REG_NVIC_CCR_DIV_0_TRP             DEF_BIT_04
N#define  CPU_REG_NVIC_CCR_UNALIGN_TRP           DEF_BIT_03
N#define  CPU_REG_NVIC_CCR_USERSETMPEND          DEF_BIT_01
N#define  CPU_REG_NVIC_CCR_NONBASETHRDENA        DEF_BIT_00
N
N                                                                /* ------- SYSTEM HANDLER CTRL & STATE REG BITS ------- */
N#define  CPU_REG_NVIC_SHCSR_USGFAULTENA         DEF_BIT_18
N#define  CPU_REG_NVIC_SHCSR_BUSFAULTENA         DEF_BIT_17
N#define  CPU_REG_NVIC_SHCSR_MEMFAULTENA         DEF_BIT_16
N#define  CPU_REG_NVIC_SHCSR_SVCALLPENDED        DEF_BIT_15
N#define  CPU_REG_NVIC_SHCSR_BUSFAULTPENDED      DEF_BIT_14
N#define  CPU_REG_NVIC_SHCSR_MEMFAULTPENDED      DEF_BIT_13
N#define  CPU_REG_NVIC_SHCSR_USGFAULTPENDED      DEF_BIT_12
N#define  CPU_REG_NVIC_SHCSR_SYSTICKACT          DEF_BIT_11
N#define  CPU_REG_NVIC_SHCSR_PENDSVACT           DEF_BIT_10
N#define  CPU_REG_NVIC_SHCSR_MONITORACT          DEF_BIT_08
N#define  CPU_REG_NVIC_SHCSR_SVCALLACT           DEF_BIT_07
N#define  CPU_REG_NVIC_SHCSR_USGFAULTACT         DEF_BIT_03
N#define  CPU_REG_NVIC_SHCSR_BUSFAULTACT         DEF_BIT_01
N#define  CPU_REG_NVIC_SHCSR_MEMFAULTACT         DEF_BIT_00
N
N                                                                /* -------- CONFIGURABLE FAULT STATUS REG BITS -------- */
N#define  CPU_REG_NVIC_CFSR_DIVBYZERO            DEF_BIT_25
N#define  CPU_REG_NVIC_CFSR_UNALIGNED            DEF_BIT_24
N#define  CPU_REG_NVIC_CFSR_NOCP                 DEF_BIT_19
N#define  CPU_REG_NVIC_CFSR_INVPC                DEF_BIT_18
N#define  CPU_REG_NVIC_CFSR_INVSTATE             DEF_BIT_17
N#define  CPU_REG_NVIC_CFSR_UNDEFINSTR           DEF_BIT_16
N#define  CPU_REG_NVIC_CFSR_BFARVALID            DEF_BIT_15
N#define  CPU_REG_NVIC_CFSR_STKERR               DEF_BIT_12
N#define  CPU_REG_NVIC_CFSR_UNSTKERR             DEF_BIT_11
N#define  CPU_REG_NVIC_CFSR_IMPRECISERR          DEF_BIT_10
N#define  CPU_REG_NVIC_CFSR_PRECISERR            DEF_BIT_09
N#define  CPU_REG_NVIC_CFSR_IBUSERR              DEF_BIT_08
N#define  CPU_REG_NVIC_CFSR_MMARVALID            DEF_BIT_07
N#define  CPU_REG_NVIC_CFSR_MSTKERR              DEF_BIT_04
N#define  CPU_REG_NVIC_CFSR_MUNSTKERR            DEF_BIT_03
N#define  CPU_REG_NVIC_CFSR_DACCVIOL             DEF_BIT_01
N#define  CPU_REG_NVIC_CFSR_IACCVIOL             DEF_BIT_00
N
N                                                                /* ------------ HARD FAULT STATUS REG BITS ------------ */
N#define  CPU_REG_NVIC_HFSR_DEBUGEVT             DEF_BIT_31
N#define  CPU_REG_NVIC_HFSR_FORCED               DEF_BIT_30
N#define  CPU_REG_NVIC_HFSR_VECTTBL              DEF_BIT_01
N
N                                                                /* ------------ DEBUG FAULT STATUS REG BITS ----------- */
N#define  CPU_REG_NVIC_DFSR_EXTERNAL             DEF_BIT_04
N#define  CPU_REG_NVIC_DFSR_VCATCH               DEF_BIT_03
N#define  CPU_REG_NVIC_DFSR_DWTTRAP              DEF_BIT_02
N#define  CPU_REG_NVIC_DFSR_BKPT                 DEF_BIT_01
N#define  CPU_REG_NVIC_DFSR_HALTED               DEF_BIT_00
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N#ifndef   CPU_CFG_ADDR_SIZE
S#error   "CPU_CFG_ADDR_SIZE              not #define'd in 'cpu.h'               "
S#error   "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error   "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error   "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
S
S#elif   ((CPU_CFG_ADDR_SIZE != CPU_WORD_SIZE_08) && \
S         (CPU_CFG_ADDR_SIZE != CPU_WORD_SIZE_16) && \
S         (CPU_CFG_ADDR_SIZE != CPU_WORD_SIZE_32))
X#elif   ((4 != 1) &&          (4 != 2) &&          (4 != 4))
S#error   "CPU_CFG_ADDR_SIZE        illegally #define'd in 'cpu.h'               "
S#error   "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error   "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error   "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
N#endif
N
N
N#ifndef   CPU_CFG_DATA_SIZE
S#error   "CPU_CFG_DATA_SIZE              not #define'd in 'cpu.h'               "
S#error   "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error   "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error   "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
S
S#elif   ((CPU_CFG_DATA_SIZE != CPU_WORD_SIZE_08) && \
S         (CPU_CFG_DATA_SIZE != CPU_WORD_SIZE_16) && \
S         (CPU_CFG_DATA_SIZE != CPU_WORD_SIZE_32))
X#elif   ((4 != 1) &&          (4 != 2) &&          (4 != 4))
S#error   "CPU_CFG_DATA_SIZE        illegally #define'd in 'cpu.h'               "
S#error   "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error   "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error   "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
N#endif
N
N
N
N#ifndef   CPU_CFG_ENDIAN_TYPE
S#error   "CPU_CFG_ENDIAN_TYPE            not #define'd in 'cpu.h'   "
S#error   "                         [MUST be  CPU_ENDIAN_TYPE_BIG   ]"
S#error   "                         [     ||  CPU_ENDIAN_TYPE_LITTLE]"
S
S#elif   ((CPU_CFG_ENDIAN_TYPE != CPU_ENDIAN_TYPE_BIG   ) && \
S         (CPU_CFG_ENDIAN_TYPE != CPU_ENDIAN_TYPE_LITTLE))
X#elif   ((2 != 1   ) &&          (2 != 2))
S#error   "CPU_CFG_ENDIAN_TYPE      illegally #define'd in 'cpu.h'   "
S#error   "                         [MUST be  CPU_ENDIAN_TYPE_BIG   ]"
S#error   "                         [     ||  CPU_ENDIAN_TYPE_LITTLE]"
N#endif
N
N
N
N
N#ifndef   CPU_CFG_CRITICAL_METHOD
S#error   "CPU_CFG_CRITICAL_METHOD        not #define'd in 'cpu.h'             "
S#error   "                         [MUST be  CPU_CRITICAL_METHOD_INT_DIS_EN  ]"
S#error   "                         [     ||  CPU_CRITICAL_METHOD_STATUS_STK  ]"
S#error   "                         [     ||  CPU_CRITICAL_METHOD_STATUS_LOCAL]"
S
S#elif   ((CPU_CFG_CRITICAL_METHOD != CPU_CRITICAL_METHOD_INT_DIS_EN  ) && \
S         (CPU_CFG_CRITICAL_METHOD != CPU_CRITICAL_METHOD_STATUS_STK  ) && \
S         (CPU_CFG_CRITICAL_METHOD != CPU_CRITICAL_METHOD_STATUS_LOCAL))
X#elif   ((3 != 1  ) &&          (3 != 2  ) &&          (3 != 3))
S#error   "CPU_CFG_CRITICAL_METHOD  illegally #define'd in 'cpu.h'             "
S#error   "                         [MUST be  CPU_CRITICAL_METHOD_INT_DIS_EN  ]"
S#error   "                         [     ||  CPU_CRITICAL_METHOD_STATUS_STK  ]"
S#error   "                         [     ||  CPU_CRITICAL_METHOD_STATUS_LOCAL]"
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of CPU cfg module inclusion.                     */
L 50 "..\..\..\..\..\uC-CPU\ARM-Cortex-M3\RealView\cpu_c.c" 2
N#include  <lib_def.h>
L 1 "..\..\..\..\..\uC-LIB\lib_def.h" 1
N/*
N*********************************************************************************************************
N*                                               uC/LIB
N*                                       CUSTOM LIBRARY MODULES
N*
N*                          (c) Copyright 2004-2008; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/LIB is provided in source form for FREE evaluation, for educational
N*               use or peaceful research.  If you plan on using uC/LIB in a commercial
N*               product you need to contact Micrium to properly license its use in your
N*               product.  We provide ALL the source code for your convenience and to
N*               help you experience uC/LIB.  The fact that the source code is provided
N*               does NOT mean that you can use it without paying a licensing fee.
N*
N*               Knowledge of the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest
N*               software available.  Your honesty is greatly appreciated.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                     CORE CUSTOM LIBRARY MODULE
N*
N* Filename      : lib_def.h
N* Version       : V1.25
N* Programmer(s) : ITJ
N*********************************************************************************************************
N* Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
N*
N*                     (a) ALL standard library functions are implemented in the custom library modules :
N*
N*                         (1) \<Custom Library Directory>\lib*.*
N*
N*                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
N*
N*                               where
N*                                       <Custom Library Directory>      directory path for custom library software
N*                                       <cpu>                           directory name for specific processor (CPU)
N*                                       <compiler>                      directory name for specific compiler
N*
N*                     (b) Product-specific library functions are implemented in individual products.
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_DEF_MODULE_PRESENT
N#define  LIB_DEF_MODULE_PRESENT
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                CUSTOM LIBRARY MODULE VERSION NUMBER
N*
N* Note(s) : (1) (a) The custom library module software version is denoted as follows :
N*
N*                       Vx.yy
N*
N*                           where
N*                                   V               denotes 'Version' label
N*                                   x               denotes major software version revision number
N*                                   yy              denotes minor software version revision number
N*
N*               (b) The software version label #define is formatted as follows :
N*
N*                       ver = x.yy * 100
N*
N*                           where
N*                                   ver             denotes software version number scaled as an integer value
N*                                   x.yy            denotes software version number
N*********************************************************************************************************
N*/
N
N#define  LIB_VERSION                                     124u   /* See Note #1.                                         */
N
N
N/*
N*********************************************************************************************************
N*                                            INCLUDE FILES
N*
N* Note(s) : (1) The following common software files are located in the following directories :
N*
N*               (a) \<Custom Library Directory>\lib*.*
N*
N*               (b) (1) \<CPU-Compiler Directory>\cpu_def.h
N*
N*                   (2) \<CPU-Compiler Directory>\<cpu>\<compiler>\cpu*.*
N*
N*                           where
N*                                   <Custom Library Directory>      directory path for custom   library      software
N*                                   <CPU-Compiler Directory>        directory path for common   CPU-compiler software
N*                                   <cpu>                           directory name for specific processor (CPU)
N*                                   <compiler>                      directory name for specific compiler
N*
N*           (2) Compiler MUST be configured to include the '\<Custom Library Directory>\uC-LIB\',
N*               '\<CPU-Compiler Directory>\' directory, & the specific CPU-compiler directory as 
N*               additional include path directories.
N*********************************************************************************************************
N*/
N
N#include  <cpu.h>
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          STANDARD DEFINES
N*********************************************************************************************************
N*/
N
N
N#define  DEF_DISABLED                                      0
N#define  DEF_ENABLED                                       1
N
N#define  DEF_FALSE                                         0
N#define  DEF_TRUE                                          1
N
N#define  DEF_NO                                            0
N#define  DEF_YES                                           1
N
N#define  DEF_OFF                                           0
N#define  DEF_ON                                            1
N
N#define  DEF_CLR                                           0
N#define  DEF_SET                                           1
N
N#define  DEF_ACTIVE                                        0
N#define  DEF_INACTIVE                                      1
N
N#define  DEF_FAIL                                          0
N#define  DEF_OK                                            1
N
N
N                                                                /* -------------------- BIT DEFINES ------------------- */
N#define  DEF_BIT_NONE                                   0x00
N
N#define  DEF_BIT_00                                     0x01
N#define  DEF_BIT_01                                     0x02
N#define  DEF_BIT_02                                     0x04
N#define  DEF_BIT_03                                     0x08
N#define  DEF_BIT_04                                     0x10
N#define  DEF_BIT_05                                     0x20
N#define  DEF_BIT_06                                     0x40
N#define  DEF_BIT_07                                     0x80
N
N#define  DEF_BIT_08                                   0x0100
N#define  DEF_BIT_09                                   0x0200
N#define  DEF_BIT_10                                   0x0400
N#define  DEF_BIT_11                                   0x0800
N#define  DEF_BIT_12                                   0x1000
N#define  DEF_BIT_13                                   0x2000
N#define  DEF_BIT_14                                   0x4000
N#define  DEF_BIT_15                                   0x8000
N
N#define  DEF_BIT_16                               0x00010000
N#define  DEF_BIT_17                               0x00020000
N#define  DEF_BIT_18                               0x00040000
N#define  DEF_BIT_19                               0x00080000
N#define  DEF_BIT_20                               0x00100000
N#define  DEF_BIT_21                               0x00200000
N#define  DEF_BIT_22                               0x00400000
N#define  DEF_BIT_23                               0x00800000
N
N#define  DEF_BIT_24                               0x01000000
N#define  DEF_BIT_25                               0x02000000
N#define  DEF_BIT_26                               0x04000000
N#define  DEF_BIT_27                               0x08000000
N#define  DEF_BIT_28                               0x10000000
N#define  DEF_BIT_29                               0x20000000
N#define  DEF_BIT_30                               0x40000000
N#define  DEF_BIT_31                               0x80000000
N
N                                                                /* ------------------- OCTET DEFINES ------------------ */
N#define  DEF_OCTET_NBR_BITS                                8
N#define  DEF_OCTET_MASK                                 0xFF
N
N#define  DEF_NIBBLE_NBR_BITS                               4
N#define  DEF_NIBBLE_MASK                                0x0F
N
N
N/*$PAGE*/
N                                                                /* ------------------ INTEGER DEFINES ----------------- */
N#define  DEF_INT_08_NBR_BITS                               8
N#define  DEF_INT_08_MASK                                0xFF
N                                                            
N#define  DEF_INT_08U_MIN_VAL                               0u
N#define  DEF_INT_08U_MAX_VAL                             255u
N
N#define  DEF_INT_08S_MIN_VAL                            -128
N#define  DEF_INT_08S_MAX_VAL                             127
N
N#define  DEF_INT_08S_MIN_VAL_ONES_CPL                   -127
N#define  DEF_INT_08S_MAX_VAL_ONES_CPL                    127
N
N
N#define  DEF_INT_16_NBR_BITS                              16
N#define  DEF_INT_16_MASK                              0xFFFF
N                                                            
N#define  DEF_INT_16U_MIN_VAL                               0u
N#define  DEF_INT_16U_MAX_VAL                           65535u
N
N#define  DEF_INT_16S_MIN_VAL                          -32768
N#define  DEF_INT_16S_MAX_VAL                           32767
N
N#define  DEF_INT_16S_MIN_VAL_ONES_CPL                 -32767
N#define  DEF_INT_16S_MAX_VAL_ONES_CPL                  32767
N
N
N#define  DEF_INT_32_NBR_BITS                              32
N#define  DEF_INT_32_MASK                          0xFFFFFFFF
N                                                            
N#define  DEF_INT_32U_MIN_VAL                               0u
N#define  DEF_INT_32U_MAX_VAL                      4294967295u
N
N#define  DEF_INT_32S_MIN_VAL                     -2147483648
N#define  DEF_INT_32S_MAX_VAL                      2147483647
N
N#define  DEF_INT_32S_MIN_VAL_ONES_CPL            -2147483647
N#define  DEF_INT_32S_MAX_VAL_ONES_CPL             2147483647
N
N
N#define  DEF_INT_64_NBR_BITS                              64
N#define  DEF_INT_64_MASK                  0xFFFFFFFFFFFFFFFF
N                                                            
N#define  DEF_INT_64U_MIN_VAL                               0u
N#define  DEF_INT_64U_MAX_VAL            18446744073709551615u
N
N#define  DEF_INT_64S_MIN_VAL            -9223372036854775808
N#define  DEF_INT_64S_MAX_VAL             9223372036854775807
N
N#define  DEF_INT_64S_MIN_VAL_ONES_CPL   -9223372036854775807
N#define  DEF_INT_64S_MAX_VAL_ONES_CPL    9223372036854775807
N
N
N/*$PAGE*/
N                                                                /* ---------------- CPU INTEGER DEFINES --------------- */
N#define  DEF_INT_CPU_NBR_BITS                           (CPU_CFG_DATA_SIZE * DEF_OCTET_NBR_BITS)
N
N
N#if     (DEF_INT_CPU_NBR_BITS == DEF_INT_08_NBR_BITS)
X#if     ((4 * 8) == 8)
S
S#define  DEF_INT_CPU_MASK                                DEF_INT_08_MASK
S                                                                   
S#define  DEF_INT_CPU_U_MIN_VAL                           DEF_INT_08U_MIN_VAL
S#define  DEF_INT_CPU_U_MAX_VAL                           DEF_INT_08U_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL                           DEF_INT_08S_MIN_VAL
S#define  DEF_INT_CPU_S_MAX_VAL                           DEF_INT_08S_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL_ONES_CPL                  DEF_INT_08S_MIN_VAL_ONES_CPL
S#define  DEF_INT_CPU_S_MAX_VAL_ONES_CPL                  DEF_INT_08S_MAX_VAL_ONES_CPL
S
S
S#elif   (DEF_INT_CPU_NBR_BITS == DEF_INT_16_NBR_BITS)
X#elif   ((4 * 8) == 16)
S
S#define  DEF_INT_CPU_MASK                                DEF_INT_16_MASK
S                                                                   
S#define  DEF_INT_CPU_U_MIN_VAL                           DEF_INT_16U_MIN_VAL
S#define  DEF_INT_CPU_U_MAX_VAL                           DEF_INT_16U_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL                           DEF_INT_16S_MIN_VAL
S#define  DEF_INT_CPU_S_MAX_VAL                           DEF_INT_16S_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL_ONES_CPL                  DEF_INT_16S_MIN_VAL_ONES_CPL
S#define  DEF_INT_CPU_S_MAX_VAL_ONES_CPL                  DEF_INT_16S_MAX_VAL_ONES_CPL
S
S
N#elif   (DEF_INT_CPU_NBR_BITS == DEF_INT_32_NBR_BITS)
X#elif   ((4 * 8) == 32)
N
N#define  DEF_INT_CPU_MASK                                DEF_INT_32_MASK
N                                                    
N#define  DEF_INT_CPU_U_MIN_VAL                           DEF_INT_32U_MIN_VAL
N#define  DEF_INT_CPU_U_MAX_VAL                           DEF_INT_32U_MAX_VAL
N
N#define  DEF_INT_CPU_S_MIN_VAL                           DEF_INT_32S_MIN_VAL
N#define  DEF_INT_CPU_S_MAX_VAL                           DEF_INT_32S_MAX_VAL
N
N#define  DEF_INT_CPU_S_MIN_VAL_ONES_CPL                  DEF_INT_32S_MIN_VAL_ONES_CPL
N#define  DEF_INT_CPU_S_MAX_VAL_ONES_CPL                  DEF_INT_32S_MAX_VAL_ONES_CPL
N
N
N#elif   (DEF_INT_CPU_NBR_BITS == DEF_INT_64_NBR_BITS)
S
S#define  DEF_INT_CPU_MASK                                DEF_INT_64_MASK
S                                                                   
S#define  DEF_INT_CPU_U_MIN_VAL                           DEF_INT_64U_MIN_VAL
S#define  DEF_INT_CPU_U_MAX_VAL                           DEF_INT_64U_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL                           DEF_INT_64S_MIN_VAL
S#define  DEF_INT_CPU_S_MAX_VAL                           DEF_INT_64S_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL_ONES_CPL                  DEF_INT_64S_MIN_VAL_ONES_CPL
S#define  DEF_INT_CPU_S_MAX_VAL_ONES_CPL                  DEF_INT_64S_MAX_VAL_ONES_CPL
S                                                      
S
S#else
S
S#error  "CPU_CFG_DATA_SIZE  illegally #defined in 'cpu.h'      "
S#error  "                   [See 'cpu.h  CONFIGURATION ERRORS']"
S
N#endif
N
N
N/*$PAGE*/
N                                                                /* ------------------- TIME DEFINES ------------------- */
N#define  DEF_TIME_NBR_HR_PER_DAY                          24uL
N
N#define  DEF_TIME_NBR_MIN_PER_HR                          60uL
N#define  DEF_TIME_NBR_MIN_PER_DAY                       (DEF_TIME_NBR_MIN_PER_HR  * DEF_TIME_NBR_HR_PER_DAY)
N
N#define  DEF_TIME_NBR_SEC_PER_MIN                         60uL
N#define  DEF_TIME_NBR_SEC_PER_HR                        (DEF_TIME_NBR_SEC_PER_MIN * DEF_TIME_NBR_MIN_PER_HR)
N#define  DEF_TIME_NBR_SEC_PER_DAY                       (DEF_TIME_NBR_SEC_PER_HR  * DEF_TIME_NBR_HR_PER_DAY)
N
N#define  DEF_TIME_NBR_mS_PER_SEC                        1000uL
N#define  DEF_TIME_NBR_uS_PER_SEC                     1000000uL
N#define  DEF_TIME_NBR_nS_PER_SEC                  1000000000uL
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             ERROR CODES
N*
N* Note(s) : (1) All generic library error codes are #define'd in 'lib_def.h';
N*               Any module-specific error codes are #define'd in library module header files.
N*********************************************************************************************************
N*/
N
N#define  LIB_ERR_NONE                                      0
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             DATA TYPES
N*********************************************************************************************************
N*/
N
Ntypedef  CPU_INT16U  LIB_ERR;
N
N
N/*
N*********************************************************************************************************
N*                                          GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             BIT MACRO'S
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                              DEF_BIT()
N*
N* Description : Create bit mask with single, specified bit set.
N*
N* Argument(s) : bit         Bit number of bit to set.
N*
N* Return(s)   : Bit mask with single, specified bit set.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'bit' values that overflow the target CPU &/or compiler environment (e.g. negative
N*                   or greater-than-CPU-data-size values) MAY generate compiler warnings &/or errors.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT(bit)                            (1u << (bit))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                           DEF_BIT_MASK()
N*
N* Description : Shift a bit mask.
N*
N* Argument(s) : bit_mask    Bit mask to shift.
N*
N*               bit_shift   Number of bit positions to left-shift bit mask.
N*
N* Return(s)   : Shifted bit mask.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'bit_shift' values that overflow the target CPU &/or compiler environment (e.g. negative
N*                   or greater-than-CPU-data-size values) MAY generate compiler warnings &/or errors.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_MASK(bit_mask, bit_shift)             ((bit_mask)       << (bit_shift))
N
N
N/*
N*********************************************************************************************************
N*                                           DEF_BIT_FIELD()
N*
N* Description : Create & shift a contiguous bit field.
N*
N* Argument(s) : bit_field   Number of contiguous bits to set in the bit field.
N*
N*               bit_shift   Number of bit positions   to left-shift bit field.
N*
N* Return(s)   : Shifted bit field.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'bit_field'/'bit_shift' values that overflow the target CPU &/or compiler environment 
N*                   (e.g. negative or greater-than-CPU-data-size values) MAY generate compiler warnings
N*                   &/or errors.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_FIELD(bit_field, bit_shift)         ((((bit_field) >= DEF_INT_CPU_NBR_BITS) ? (DEF_INT_CPU_U_MAX_VAL)   \
N                                                                                             : (DEF_BIT(bit_field) - 1)) \
N                                                                                                    << (bit_shift))
X#define  DEF_BIT_FIELD(bit_field, bit_shift)         ((((bit_field) >= DEF_INT_CPU_NBR_BITS) ? (DEF_INT_CPU_U_MAX_VAL)                                                                                                : (DEF_BIT(bit_field) - 1))                                                                                                     << (bit_shift))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            DEF_BIT_SET()
N*
N* Description : Set specified bit(s) in a value.
N*
N* Argument(s) : val         Value to modify by setting specified bit(s).
N*
N*               mask        Mask of bits to set.
N*
N* Return(s)   : Modified value with specified bit(s) set.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_SET(val, mask)                       { (val) |=  (mask); }
N
N
N/*
N*********************************************************************************************************
N*                                            DEF_BIT_CLR()
N*
N* Description : Clear specified bit(s) in a value.
N*
N* Argument(s) : val         Value to modify by clearing specified bit(s).
N*
N*               mask        Mask of bits to clear.
N*
N* Return(s)   : Modified value with specified bit(s) clear.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_CLR(val, mask)                       { (val) &= ~(mask); }
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          DEF_BIT_IS_SET()
N*
N* Description : Determine if specified bit(s) in a value are set.
N*
N* Argument(s) : val         Value to check for specified bit(s) set.
N*
N*               mask        Mask of bits to check if set.
N*
N* Return(s)   : DEF_YES, if ALL specified bit(s) are     set in value.
N*     
N*               DEF_NO,	 if ALL specified bit(s) are NOT set in value.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_IS_SET(val, mask)                   ((((val) & (mask)) == (mask)) ? (DEF_YES) : (DEF_NO ))
N
N
N/*
N*********************************************************************************************************
N*                                          DEF_BIT_IS_CLR()
N*
N* Description : Determine if specified bit(s) in a value are clear.
N*
N* Argument(s) : val         Value to check for specified bit(s) clear.
N*
N*               mask        Mask of bits to check if clear.
N*
N* Return(s)   : DEF_YES, if ALL specified bit(s) are     clear in value.
N*     
N*               DEF_NO,	 if ALL specified bit(s) are NOT clear in value.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_IS_CLR(val, mask)                    (((val) & (mask))            ? (DEF_NO ) : (DEF_YES))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        DEF_BIT_IS_SET_ANY()
N*
N* Description : Determine if any specified bit(s) in a value are set.
N*
N* Argument(s) : val         Value to check for specified bit(s) set.
N*
N*               mask        Mask of bits to check if set.
N*
N* Return(s)   : DEF_YES, if ANY specified bit(s) are     set in value.
N*     
N*               DEF_NO,	 if ALL specified bit(s) are NOT set in value.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_IS_SET_ANY(val, mask)                (((val) & (mask))            ? (DEF_YES) : (DEF_NO ))
N
N
N/*
N*********************************************************************************************************
N*                                        DEF_BIT_IS_CLR_ANY()
N*
N* Description : Determine if any specified bit(s) in a value are clear.
N*
N* Argument(s) : val         Value to check for specified bit(s) clear.
N*
N*               mask        Mask of bits to check if clear.
N*
N* Return(s)   : DEF_YES, if ANY specified bit(s) are     clear in value.
N*     
N*               DEF_NO,	 if ALL specified bit(s) are NOT clear in value.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_IS_CLR_ANY(val, mask)               ((((val) & (mask)) != (mask)) ? (DEF_YES) : (DEF_NO ))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            MATH MACRO'S
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                              DEF_MIN()
N*
N* Description : Determine the minimum of two values.
N*
N* Argument(s) : a           First  value.
N*
N*               b           Second value.
N*
N* Return(s)   : Minimum of the two values.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_MIN(a, b)                                  (((a) < (b)) ? (a) : (b))
N
N
N/*
N*********************************************************************************************************
N*                                              DEF_MAX()
N*
N* Description : Determine the maximum of two values.
N*
N* Argument(s) : a           First  value.
N*
N*               b           Second value.
N*
N* Return(s)   : Maximum of the two values.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_MAX(a, b)                                  (((a) > (b)) ? (a) : (b))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                              DEF_ABS()
N*
N* Description : Determine the absolute value of a value.
N*
N* Argument(s) : a           Value to calculate absolute value.
N*
N* Return(s)   : Absolute value of the value.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_ABS(a)                                     (((a) < 0) ? (-(a)) : (a))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                        CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of lib def module include.                       */
N
L 51 "..\..\..\..\..\uC-CPU\ARM-Cortex-M3\RealView\cpu_c.c" 2
N
N
N/*
N*********************************************************************************************************
N*                                              LOCAL DEFINES
N*********************************************************************************************************
N*/
N
N#define  CPU_INT_SRC_POS_MAX      ((((CPU_REG_NVIC_NVIC + 1) & 0x1F) * 32) + 1)
N
N#define  CPU_BIT_BAND_SRAM_REG_LO       0x20000000
N#define  CPU_BIT_BAND_SRAM_REG_HI       0x200FFFFF
N#define  CPU_BIT_BAND_SRAM_BASE         0x22000000
N
N
N#define  CPU_BIT_BAND_PERIPH_REG_LO     0x40000000
N#define  CPU_BIT_BAND_PERIPH_REG_HI     0x400FFFFF
N#define  CPU_BIT_BAND_PERIPH_BASE       0x42000000
N
N
N/*
N*********************************************************************************************************
N*                                             LOCAL CONSTANTS
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                            LOCAL DATA TYPES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                              LOCAL TABLES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                         LOCAL GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                        LOCAL FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                       LOCAL CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                           CPU_BitBandClr()
N*
N* Description : Clear bit in bit-band region.
N*
N* Argument(s) : addr            Byte address in memory space.
N*
N*               bit_nbr         Bit number in byte.
N*
N* Return(s)   : none.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
Nvoid  CPU_BitBandClr (CPU_ADDR    addr,
N                      CPU_INT08U  bit_nbr)
N{
N    CPU_ADDR  bit_word_off;
N    CPU_ADDR  bit_word_addr;
N
N
N    if ((addr >= CPU_BIT_BAND_SRAM_REG_LO) &&
X    if ((addr >= 0x20000000) &&
N        (addr <= CPU_BIT_BAND_SRAM_REG_HI)) {
X        (addr <= 0x200FFFFF)) {
N        bit_word_off  = ((addr - CPU_BIT_BAND_SRAM_REG_LO) * 32) + (bit_nbr * 4);
X        bit_word_off  = ((addr - 0x20000000) * 32) + (bit_nbr * 4);
N        bit_word_addr = CPU_BIT_BAND_SRAM_BASE + bit_word_off;
X        bit_word_addr = 0x22000000 + bit_word_off;
N
N       *(volatile CPU_INT32U *)(bit_word_addr) = 0;
N
N    } else if ((addr >= CPU_BIT_BAND_PERIPH_REG_LO) &&
X    } else if ((addr >= 0x40000000) &&
N               (addr <= CPU_BIT_BAND_PERIPH_REG_HI)) {
X               (addr <= 0x400FFFFF)) {
N        bit_word_off  = ((addr - CPU_BIT_BAND_PERIPH_REG_LO) * 32) + (bit_nbr * 4);
X        bit_word_off  = ((addr - 0x40000000) * 32) + (bit_nbr * 4);
N        bit_word_addr = CPU_BIT_BAND_PERIPH_BASE + bit_word_off;
X        bit_word_addr = 0x42000000 + bit_word_off;
N
N       *(volatile CPU_INT32U *)(bit_word_addr) = 0;
N    }
N}
N
N
N/*
N*********************************************************************************************************
N*                                           CPU_BitBandClr()
N*
N* Description : Set bit in bit-band region.
N*
N* Argument(s) : addr            Byte address in memory space.
N*
N*               bit_nbr         Bit number in byte.
N*
N* Return(s)   : none.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
Nvoid  CPU_BitBandSet (CPU_ADDR    addr,
N                      CPU_INT08U  bit_nbr)
N{
N    CPU_ADDR  bit_word_off;
N    CPU_ADDR  bit_word_addr;
N
N
N    if ((addr >= CPU_BIT_BAND_SRAM_REG_LO) &&
X    if ((addr >= 0x20000000) &&
N        (addr <= CPU_BIT_BAND_SRAM_REG_HI)) {
X        (addr <= 0x200FFFFF)) {
N        bit_word_off  = ((addr - CPU_BIT_BAND_SRAM_REG_LO) * 32) + (bit_nbr * 4);
X        bit_word_off  = ((addr - 0x20000000) * 32) + (bit_nbr * 4);
N        bit_word_addr = CPU_BIT_BAND_SRAM_BASE + bit_word_off;
X        bit_word_addr = 0x22000000 + bit_word_off;
N
N       *(volatile CPU_INT32U *)(bit_word_addr) = 1;
N
N    } else if ((addr >= CPU_BIT_BAND_PERIPH_REG_LO) &&
X    } else if ((addr >= 0x40000000) &&
N               (addr <= CPU_BIT_BAND_PERIPH_REG_HI)) {
X               (addr <= 0x400FFFFF)) {
N        bit_word_off  = ((addr - CPU_BIT_BAND_PERIPH_REG_LO) * 32) + (bit_nbr * 4);
X        bit_word_off  = ((addr - 0x40000000) * 32) + (bit_nbr * 4);
N        bit_word_addr = CPU_BIT_BAND_PERIPH_BASE + bit_word_off;
X        bit_word_addr = 0x42000000 + bit_word_off;
N
N       *(volatile CPU_INT32U *)(bit_word_addr) = 1;
N    }
N}
N
N
N/*
N*********************************************************************************************************
N*                                           CPU_IntSrcDis()
N*
N* Description : Disable an interrupt source.
N*
N* Argument(s) : pos     Position of interrupt vector in interrupt table :
N*
N*                           0       Invalid (see Note #1a).
N*                           1       Invalid (see Note #1b).
N*                           2       Non-maskable interrupt.
N*                           3       Hard Fault.
N*                           4       Memory Management.
N*                           5       Bus Fault.
N*                           6       Usage Fault.
N*                           7-10    Reserved.
N*                           11      SVCall
N*                           12      Debug monitor.
N*                           13      Reserved
N*                           14      PendSV.
N*                           15      SysTick.
N*                           16+     External Interrupt.
N*
N* Return(s)   : none.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) Several table positions do not contain interrupt sources :
N*
N*                   (a) Position 0 contains the stack pointer.
N*                   (b) Positions 7-10, 13 are reserved.
N*
N*               (2) Several interrupts cannot be disabled/enabled :
N*
N*                   (a) Reset.
N*                   (b) NMI.
N*                   (c) Hard fault.
N*                   (d) SVCall.
N*                   (e) Debug monitor.
N*                   (f) PendSV.
N*
N*               (3) The maximum Cortex-M3 table position is 256.  A particular Cortex-M3 may have fewer
N*                   than 240 external exceptions and, consequently, fewer than 256 table positions.
N*                   This function assumes that the specified table position is valid if the interrupt
N*                   controller type register's INTLINESNUM field is large enough so that the position
N*                   COULD be valid.
N*********************************************************************************************************
N*/
N
Nvoid  CPU_IntSrcDis (CPU_INT08U  pos)
N{
N#if (CPU_CFG_CRITICAL_METHOD == CPU_CRITICAL_METHOD_STATUS_LOCAL)
X#if (3 == 3)
N    CPU_SR      cpu_sr;
N#endif
N    CPU_INT08U  group;
N    CPU_INT08U  pos_max;
N    CPU_INT08U  nbr;
N
N
N    switch (pos) {
N        case CPU_INT_STK_PTR:                                   /* ---------------- INVALID OR RESERVED --------------- */
X        case 0:                                    
N        case CPU_INT_RSVD_07:
X        case 7:
N        case CPU_INT_RSVD_08:
X        case 8:
N        case CPU_INT_RSVD_09:
X        case 9:
N        case CPU_INT_RSVD_10:
X        case 10:
N        case CPU_INT_RSVD_13:
X        case 13:
N             break;
N
N
N                                                                /* ----------------- SYSTEM EXCEPTIONS ---------------- */
N        case CPU_INT_RESET:                                     /* Reset (see Note #2).                                 */
X        case 1:                                      
N        case CPU_INT_NMI:                                       /* Non-maskable interrupt (see Note #2).                */
X        case 2:                                        
N        case CPU_INT_HFAULT:                                    /* Hard fault (see Note #2).                            */
X        case 3:                                     
N        case CPU_INT_SVCALL:                                    /* SVCall (see Note #2).                                */
X        case 11:                                     
N        case CPU_INT_DBGMON:                                    /* Debug monitor (see Note #2).                         */
X        case 12:                                     
N        case CPU_INT_PENDSV:                                    /* PendSV (see Note #2).                                */
X        case 14:                                     
N             break;
N
N        case CPU_INT_MEM:                                       /* Memory management.                                   */
X        case 4:                                        
N             CPU_CRITICAL_ENTER();
X             { cpu_sr = CPU_SR_Save(); };
N             CPU_REG_NVIC_SHCSR &= ~CPU_REG_NVIC_SHCSR_MEMFAULTENA;
X             (*((volatile CPU_INT32U *)(0xE000ED24))) &= ~0x00010000;
N             CPU_CRITICAL_EXIT();
X             { CPU_SR_Restore(cpu_sr); };
N             break;
N
N        case CPU_INT_BUSFAULT:                                  /* Bus fault.                                           */
X        case 5:                                   
N             CPU_CRITICAL_ENTER();
X             { cpu_sr = CPU_SR_Save(); };
N             CPU_REG_NVIC_SHCSR &= ~CPU_REG_NVIC_SHCSR_BUSFAULTENA;
X             (*((volatile CPU_INT32U *)(0xE000ED24))) &= ~0x00020000;
N             CPU_CRITICAL_EXIT();
X             { CPU_SR_Restore(cpu_sr); };
N             break;
N
N        case CPU_INT_USAGEFAULT:                                /* Usage fault.                                         */
X        case 6:                                 
N             CPU_CRITICAL_ENTER();
X             { cpu_sr = CPU_SR_Save(); };
N             CPU_REG_NVIC_SHCSR &= ~CPU_REG_NVIC_SHCSR_USGFAULTENA;
X             (*((volatile CPU_INT32U *)(0xE000ED24))) &= ~0x00040000;
N             CPU_CRITICAL_EXIT();
X             { CPU_SR_Restore(cpu_sr); };
N             break;
N
N        case CPU_INT_SYSTICK:                                   /* SysTick.                                             */
X        case 15:                                    
N             CPU_CRITICAL_ENTER();
X             { cpu_sr = CPU_SR_Save(); };
N             CPU_REG_NVIC_ST_CTRL &= ~CPU_REG_NVIC_ST_CTRL_ENABLE;
X             (*((volatile CPU_INT32U *)(0xE000E010))) &= ~0x01;
N             CPU_CRITICAL_EXIT();
X             { CPU_SR_Restore(cpu_sr); };
N             break;
N
N
N                                                                /* ---------------- EXTERNAL INTERRUPT ---------------- */
N        default:
N            pos_max = CPU_INT_SRC_POS_MAX;
X            pos_max = (((((*((volatile CPU_INT32U *)(0xE000E004))) + 1) & 0x1F) * 32) + 1);
N            if (pos < pos_max) {                                /* See Note #3.                                         */
N                 group = (pos - 16) / 32;
N                 nbr   = (pos - 16) % 32;
N
N                 CPU_CRITICAL_ENTER();
X                 { cpu_sr = CPU_SR_Save(); };
N                 CPU_REG_NVIC_CLREN(group) = DEF_BIT(nbr);
X                 (*((volatile CPU_INT32U *)(0xE000E180 + (group) * 4))) = (1u << (nbr));
N                 CPU_CRITICAL_EXIT();
X                 { CPU_SR_Restore(cpu_sr); };
N             }
N             break;
N    }
N}
N
N
N/*
N*********************************************************************************************************
N*                                           CPU_IntSrcEn()
N*
N* Description : Enable an interrupt source.
N*
N* Argument(s) : pos     Position of interrupt vector in interrupt table (see 'CPU_IntSrcDis()').
N*
N* Return(s)   : none.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) See 'CPU_IntSrcDis() Note #1'.
N*
N*               (2) See 'CPU_IntSrcDis() Note #2'.
N*
N*               (3) See 'CPU_IntSrcDis() Note #3'.
N*********************************************************************************************************
N*/
N
Nvoid  CPU_IntSrcEn (CPU_INT08U  pos)
N{
N#if (CPU_CFG_CRITICAL_METHOD == CPU_CRITICAL_METHOD_STATUS_LOCAL)
X#if (3 == 3)
N    CPU_SR      cpu_sr;
N#endif
N    CPU_INT08U  group;
N    CPU_INT08U  nbr;
N    CPU_INT08U  pos_max;
N
N
N    switch (pos) {
N        case CPU_INT_STK_PTR:                                   /* ---------------- INVALID OR RESERVED --------------- */
X        case 0:                                    
N        case CPU_INT_RSVD_07:
X        case 7:
N        case CPU_INT_RSVD_08:
X        case 8:
N        case CPU_INT_RSVD_09:
X        case 9:
N        case CPU_INT_RSVD_10:
X        case 10:
N        case CPU_INT_RSVD_13:
X        case 13:
N             break;
N
N
N                                                                /* ----------------- SYSTEM EXCEPTIONS ---------------- */
N        case CPU_INT_RESET:                                     /* Reset (see Note #2).                                 */
X        case 1:                                      
N        case CPU_INT_NMI:                                       /* Non-maskable interrupt (see Note #2).                */
X        case 2:                                        
N        case CPU_INT_HFAULT:                                    /* Hard fault (see Note #2).                            */
X        case 3:                                     
N        case CPU_INT_SVCALL:                                    /* SVCall (see Note #2).                                */
X        case 11:                                     
N        case CPU_INT_DBGMON:                                    /* Debug monitor (see Note #2).                         */
X        case 12:                                     
N        case CPU_INT_PENDSV:                                    /* PendSV (see Note #2).                                */
X        case 14:                                     
N             break;
N
N        case CPU_INT_MEM:                                       /* Memory management.                                   */
X        case 4:                                        
N             CPU_CRITICAL_ENTER();
X             { cpu_sr = CPU_SR_Save(); };
N             CPU_REG_NVIC_SHCSR |= CPU_REG_NVIC_SHCSR_MEMFAULTENA;
X             (*((volatile CPU_INT32U *)(0xE000ED24))) |= 0x00010000;
N             CPU_CRITICAL_EXIT();
X             { CPU_SR_Restore(cpu_sr); };
N             break;
N
N        case CPU_INT_BUSFAULT:                                  /* Bus fault.                                           */
X        case 5:                                   
N             CPU_CRITICAL_ENTER();
X             { cpu_sr = CPU_SR_Save(); };
N             CPU_REG_NVIC_SHCSR |= CPU_REG_NVIC_SHCSR_BUSFAULTENA;
X             (*((volatile CPU_INT32U *)(0xE000ED24))) |= 0x00020000;
N             CPU_CRITICAL_EXIT();
X             { CPU_SR_Restore(cpu_sr); };
N             break;
N
N        case CPU_INT_USAGEFAULT:                                /* Usage fault.                                         */
X        case 6:                                 
N             CPU_CRITICAL_ENTER();
X             { cpu_sr = CPU_SR_Save(); };
N             CPU_REG_NVIC_SHCSR |= CPU_REG_NVIC_SHCSR_USGFAULTENA;
X             (*((volatile CPU_INT32U *)(0xE000ED24))) |= 0x00040000;
N             CPU_CRITICAL_EXIT();
X             { CPU_SR_Restore(cpu_sr); };
N             break;
N
N        case CPU_INT_SYSTICK:                                   /* SysTick.                                             */
X        case 15:                                    
N             CPU_CRITICAL_ENTER();
X             { cpu_sr = CPU_SR_Save(); };
N             CPU_REG_NVIC_ST_CTRL |= CPU_REG_NVIC_ST_CTRL_ENABLE;
X             (*((volatile CPU_INT32U *)(0xE000E010))) |= 0x01;
N             CPU_CRITICAL_EXIT();
X             { CPU_SR_Restore(cpu_sr); };
N             break;
N
N
N                                                                /* ---------------- EXTERNAL INTERRUPT ---------------- */
N        default:
N            pos_max = CPU_INT_SRC_POS_MAX;
X            pos_max = (((((*((volatile CPU_INT32U *)(0xE000E004))) + 1) & 0x1F) * 32) + 1);
N            if (pos < pos_max) {                                /* See Note #3.                                         */
N                 group = (pos - 16) / 32;
N                 nbr   = (pos - 16) % 32;
N
N                 CPU_CRITICAL_ENTER();
X                 { cpu_sr = CPU_SR_Save(); };
N                 CPU_REG_NVIC_SETEN(group) = DEF_BIT(nbr);
X                 (*((volatile CPU_INT32U *)(0xE000E100 + (group) * 4))) = (1u << (nbr));
N                 CPU_CRITICAL_EXIT();
X                 { CPU_SR_Restore(cpu_sr); };
N             }
N             break;
N    }
N}
N
N
N/*
N*********************************************************************************************************
N*                                           CPU_IntSrcPrioSet()
N*
N* Description : Set priority of an interrupt source.
N*
N* Argument(s) : pos     Position of interrupt vector in interrupt table (see 'CPU_IntSrcDis()').
N*
N*               prio    Priority.  Use a lower priority number for a higher priority.
N*
N* Return(s)   : none.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) See 'CPU_IntSrcDis() Note #1'.
N*
N*               (2) Several interrupts priorities CANNOT be set :
N*
N*                   (a) Reset (always -3).
N*                   (b) NMI (always -2).
N*                   (c) Hard fault (always -1).
N*
N*               (3) See 'CPU_IntSrcDis() Note #3'.
N*********************************************************************************************************
N*/
N
Nvoid  CPU_IntSrcPrioSet (CPU_INT08U  pos,
N                         CPU_INT08U  prio)
N{
N#if (CPU_CFG_CRITICAL_METHOD == CPU_CRITICAL_METHOD_STATUS_LOCAL)
X#if (3 == 3)
N    CPU_SR      cpu_sr;
N#endif
N    CPU_INT08U  group;
N    CPU_INT08U  nbr;
N    CPU_INT08U  pos_max;
N    CPU_INT32U  prio_32;
N    CPU_INT32U  temp;
N
N
N    prio_32 = CPU_RevBits((CPU_INT08U)prio);
N    prio    = (CPU_INT08U)(prio_32 >> (3 * DEF_OCTET_NBR_BITS));
X    prio    = (CPU_INT08U)(prio_32 >> (3 * 8));
N
N    switch (pos) {
N        case CPU_INT_STK_PTR:                                   /* ---------------- INVALID OR RESERVED --------------- */
X        case 0:                                    
N        case CPU_INT_RSVD_07:
X        case 7:
N        case CPU_INT_RSVD_08:
X        case 8:
N        case CPU_INT_RSVD_09:
X        case 9:
N        case CPU_INT_RSVD_10:
X        case 10:
N        case CPU_INT_RSVD_13:
X        case 13:
N             break;
N
N
N                                                                /* ----------------- SYSTEM EXCEPTIONS ---------------- */
N        case CPU_INT_RESET:                                     /* Reset (see Note #2).                                 */
X        case 1:                                      
N        case CPU_INT_NMI:                                       /* Non-maskable interrupt (see Note #2).                */
X        case 2:                                        
N        case CPU_INT_HFAULT:                                    /* Hard fault (see Note #2).                            */
X        case 3:                                     
N             break;
N
N        case CPU_INT_MEM:                                       /* Memory management.                                   */
X        case 4:                                        
N             CPU_CRITICAL_ENTER();
X             { cpu_sr = CPU_SR_Save(); };
N             temp                 = CPU_REG_NVIC_SHPRI1;
X             temp                 = (*((volatile CPU_INT32U *)(0xE000ED18)));
N             temp                &= ~(DEF_OCTET_MASK << (0 * DEF_OCTET_NBR_BITS));
X             temp                &= ~(0xFF << (0 * 8));
N             temp                |=  (prio           << (0 * DEF_OCTET_NBR_BITS));
X             temp                |=  (prio           << (0 * 8));
N             CPU_REG_NVIC_SHPRI1  = temp;
X             (*((volatile CPU_INT32U *)(0xE000ED18)))  = temp;
N             CPU_CRITICAL_EXIT();
X             { CPU_SR_Restore(cpu_sr); };
N             break;
N
N        case CPU_INT_BUSFAULT:                                  /* Bus fault.                                           */
X        case 5:                                   
N             CPU_CRITICAL_ENTER();
X             { cpu_sr = CPU_SR_Save(); };
N             temp                 = CPU_REG_NVIC_SHPRI1;
X             temp                 = (*((volatile CPU_INT32U *)(0xE000ED18)));
N             temp                &= ~(DEF_OCTET_MASK << (1 * DEF_OCTET_NBR_BITS));
X             temp                &= ~(0xFF << (1 * 8));
N             temp                |=  (prio           << (1 * DEF_OCTET_NBR_BITS));
X             temp                |=  (prio           << (1 * 8));
N             CPU_REG_NVIC_SHPRI1  = temp;
X             (*((volatile CPU_INT32U *)(0xE000ED18)))  = temp;
N             CPU_CRITICAL_EXIT();
X             { CPU_SR_Restore(cpu_sr); };
N             break;
N
N        case CPU_INT_USAGEFAULT:                                /* Usage fault.                                         */
X        case 6:                                 
N             CPU_CRITICAL_ENTER();
X             { cpu_sr = CPU_SR_Save(); };
N             temp                 = CPU_REG_NVIC_SHPRI1;
X             temp                 = (*((volatile CPU_INT32U *)(0xE000ED18)));
N             temp                &= ~(DEF_OCTET_MASK << (2 * DEF_OCTET_NBR_BITS));
X             temp                &= ~(0xFF << (2 * 8));
N             temp                |=  (prio           << (2 * DEF_OCTET_NBR_BITS));
X             temp                |=  (prio           << (2 * 8));
N             CPU_REG_NVIC_SHPRI1  = temp;
X             (*((volatile CPU_INT32U *)(0xE000ED18)))  = temp;
N             CPU_CRITICAL_EXIT();
X             { CPU_SR_Restore(cpu_sr); };
N             break;
N
N        case CPU_INT_SVCALL:                                    /* SVCall.                                              */
X        case 11:                                     
N             CPU_CRITICAL_ENTER();
X             { cpu_sr = CPU_SR_Save(); };
N             temp                 = CPU_REG_NVIC_SHPRI2;
X             temp                 = (*((volatile CPU_INT32U *)(0xE000ED1C)));
N             temp                &= ~((CPU_INT32U)DEF_OCTET_MASK << (3 * DEF_OCTET_NBR_BITS));
X             temp                &= ~((CPU_INT32U)0xFF << (3 * 8));
N             temp                |=  (prio                       << (3 * DEF_OCTET_NBR_BITS));
X             temp                |=  (prio                       << (3 * 8));
N             CPU_REG_NVIC_SHPRI2  = temp;
X             (*((volatile CPU_INT32U *)(0xE000ED1C)))  = temp;
N             CPU_CRITICAL_EXIT();
X             { CPU_SR_Restore(cpu_sr); };
N             break;
N
N        case CPU_INT_DBGMON:                                    /* Debug monitor.                                       */
X        case 12:                                     
N             CPU_CRITICAL_ENTER();
X             { cpu_sr = CPU_SR_Save(); };
N             temp                = CPU_REG_NVIC_SHPRI3;
X             temp                = (*((volatile CPU_INT32U *)(0xE000ED20)));
N             temp                &= ~(DEF_OCTET_MASK << (0 * DEF_OCTET_NBR_BITS));
X             temp                &= ~(0xFF << (0 * 8));
N             temp                |=  (prio           << (0 * DEF_OCTET_NBR_BITS));
X             temp                |=  (prio           << (0 * 8));
N             CPU_REG_NVIC_SHPRI3  = temp;
X             (*((volatile CPU_INT32U *)(0xE000ED20)))  = temp;
N             CPU_CRITICAL_EXIT();
X             { CPU_SR_Restore(cpu_sr); };
N             break;
N
N        case CPU_INT_PENDSV:                                    /* PendSV.                                              */
X        case 14:                                     
N             CPU_CRITICAL_ENTER();
X             { cpu_sr = CPU_SR_Save(); };
N             temp                 = CPU_REG_NVIC_SHPRI3;
X             temp                 = (*((volatile CPU_INT32U *)(0xE000ED20)));
N             temp                &= ~(DEF_OCTET_MASK << (2 * DEF_OCTET_NBR_BITS));
X             temp                &= ~(0xFF << (2 * 8));
N             temp                |=  (prio           << (2 * DEF_OCTET_NBR_BITS));
X             temp                |=  (prio           << (2 * 8));
N             CPU_REG_NVIC_SHPRI3  = temp;
X             (*((volatile CPU_INT32U *)(0xE000ED20)))  = temp;
N             CPU_CRITICAL_EXIT();
X             { CPU_SR_Restore(cpu_sr); };
N             break;
N
N        case CPU_INT_SYSTICK:                                   /* SysTick.                                             */
X        case 15:                                    
N             CPU_CRITICAL_ENTER();
X             { cpu_sr = CPU_SR_Save(); };
N             temp                 = CPU_REG_NVIC_SHPRI3;
X             temp                 = (*((volatile CPU_INT32U *)(0xE000ED20)));
N             temp                &= ~((CPU_INT32U)DEF_OCTET_MASK << (3 * DEF_OCTET_NBR_BITS));
X             temp                &= ~((CPU_INT32U)0xFF << (3 * 8));
N             temp                |=  (prio                       << (3 * DEF_OCTET_NBR_BITS));
X             temp                |=  (prio                       << (3 * 8));
N             CPU_REG_NVIC_SHPRI3  = temp;
X             (*((volatile CPU_INT32U *)(0xE000ED20)))  = temp;
N             CPU_CRITICAL_EXIT();
X             { CPU_SR_Restore(cpu_sr); };
N             break;
N
N
N                                                                /* ---------------- EXTERNAL INTERRUPT ---------------- */
N        default:
N            pos_max = CPU_INT_SRC_POS_MAX;
X            pos_max = (((((*((volatile CPU_INT32U *)(0xE000E004))) + 1) & 0x1F) * 32) + 1);
N            if (pos < pos_max) {                                /* See Note #3.                                         */
N                 group                    = (pos - 16) / 4;
N                 nbr                      = (pos - 16) % 4;
N
N                 CPU_CRITICAL_ENTER();
X                 { cpu_sr = CPU_SR_Save(); };
N                 temp                     = CPU_REG_NVIC_PRIO(group);
X                 temp                     = (*((volatile CPU_INT32U *)(0xE000E400 + (group) * 4)));
N                 temp                    &= ~(DEF_OCTET_MASK << (nbr * DEF_OCTET_NBR_BITS));
X                 temp                    &= ~(0xFF << (nbr * 8));
N                 temp                    |=  (prio           << (nbr * DEF_OCTET_NBR_BITS));
X                 temp                    |=  (prio           << (nbr * 8));
N                 CPU_REG_NVIC_PRIO(group) = temp;
X                 (*((volatile CPU_INT32U *)(0xE000E400 + (group) * 4))) = temp;
N                 CPU_CRITICAL_EXIT();
X                 { CPU_SR_Restore(cpu_sr); };
N             }
N             break;
N    }
N}
N
N
N/*
N*********************************************************************************************************
N*                                           CPU_IntSrcPrioGet()
N*
N* Description : Get priority of an interrupt source.
N*
N* Argument(s) : pos     Position of interrupt vector in interrupt table (see 'CPU_IntSrcDis()').
N*
N* Return(s)   : Priority of interrupt source.  If the interrupt source specified is invalid, then
N*               DEF_INT_16S_MIN_VAL is returned.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) See 'CPU_IntSrcDis() Note #1'.
N*
N*               (2) See 'CPU_IntSrcPrioSet() Note #2'.
N*
N*               (3) See 'CPU_IntSrcDis() Note #3'.
N*********************************************************************************************************
N*/
N
NCPU_INT16S  CPU_IntSrcPrioGet (CPU_INT08U  pos)
N{
N#if (CPU_CFG_CRITICAL_METHOD == CPU_CRITICAL_METHOD_STATUS_LOCAL)
X#if (3 == 3)
N    CPU_SR      cpu_sr;
N#endif
N    CPU_INT08U  group;
N    CPU_INT08U  nbr;
N    CPU_INT08U  pos_max;
N    CPU_INT16S  prio;
N    CPU_INT32U  prio_32;
N    CPU_INT32U  temp;
N
N
N    switch (pos) {
N        case CPU_INT_STK_PTR:                                   /* ---------------- INVALID OR RESERVED --------------- */
X        case 0:                                    
N        case CPU_INT_RSVD_07:
X        case 7:
N        case CPU_INT_RSVD_08:
X        case 8:
N        case CPU_INT_RSVD_09:
X        case 9:
N        case CPU_INT_RSVD_10:
X        case 10:
N        case CPU_INT_RSVD_13:
X        case 13:
N             prio = DEF_INT_16S_MIN_VAL;
X             prio = -32768;
N             break;
N
N
N                                                                /* ----------------- SYSTEM EXCEPTIONS ---------------- */
N        case CPU_INT_RESET:                                     /* Reset (see Note #2).                                 */
X        case 1:                                      
N             prio = -3;
N             break;
N
N        case CPU_INT_NMI:                                       /* Non-maskable interrupt (see Note #2).                */
X        case 2:                                        
N             prio = -2;
N             break;
N
N        case CPU_INT_HFAULT:                                    /* Hard fault (see Note #2).                            */
X        case 3:                                     
N             prio = -1;
N             break;
N
N
N        case CPU_INT_MEM:                                       /* Memory management.                                   */
X        case 4:                                        
N             CPU_CRITICAL_ENTER();
X             { cpu_sr = CPU_SR_Save(); };
N             temp = CPU_REG_NVIC_SHPRI1;
X             temp = (*((volatile CPU_INT32U *)(0xE000ED18)));
N             prio = (temp >> (0 * DEF_OCTET_NBR_BITS)) & DEF_OCTET_MASK;
X             prio = (temp >> (0 * 8)) & 0xFF;
N             CPU_CRITICAL_EXIT();
X             { CPU_SR_Restore(cpu_sr); };
N             break;
N
N
N        case CPU_INT_BUSFAULT:                                  /* Bus fault.                                           */
X        case 5:                                   
N             CPU_CRITICAL_ENTER();
X             { cpu_sr = CPU_SR_Save(); };
N             temp = CPU_REG_NVIC_SHPRI1;
X             temp = (*((volatile CPU_INT32U *)(0xE000ED18)));
N             prio = (temp >> (1 * DEF_OCTET_NBR_BITS)) & DEF_OCTET_MASK;
X             prio = (temp >> (1 * 8)) & 0xFF;
N             CPU_CRITICAL_EXIT();
X             { CPU_SR_Restore(cpu_sr); };
N             break;
N
N
N        case CPU_INT_USAGEFAULT:                                /* Usage fault.                                         */
X        case 6:                                 
N             CPU_CRITICAL_ENTER();
X             { cpu_sr = CPU_SR_Save(); };
N             temp = CPU_REG_NVIC_SHPRI1;
X             temp = (*((volatile CPU_INT32U *)(0xE000ED18)));
N             prio = (temp >> (2 * DEF_OCTET_NBR_BITS)) & DEF_OCTET_MASK;
X             prio = (temp >> (2 * 8)) & 0xFF;
N             break;
N
N        case CPU_INT_SVCALL:                                    /* SVCall.                                              */
X        case 11:                                     
N             CPU_CRITICAL_ENTER();
X             { cpu_sr = CPU_SR_Save(); };
N             temp = CPU_REG_NVIC_SHPRI2;
X             temp = (*((volatile CPU_INT32U *)(0xE000ED1C)));
N             prio = (temp >> (3 * DEF_OCTET_NBR_BITS)) & DEF_OCTET_MASK;
X             prio = (temp >> (3 * 8)) & 0xFF;
N             CPU_CRITICAL_EXIT();
X             { CPU_SR_Restore(cpu_sr); };
N             break;
N
N        case CPU_INT_DBGMON:                                    /* Debug monitor.                                       */
X        case 12:                                     
N             CPU_CRITICAL_ENTER();
X             { cpu_sr = CPU_SR_Save(); };
N             temp = CPU_REG_NVIC_SHPRI3;
X             temp = (*((volatile CPU_INT32U *)(0xE000ED20)));
N             prio = (temp >> (0 * DEF_OCTET_NBR_BITS)) & DEF_OCTET_MASK;
X             prio = (temp >> (0 * 8)) & 0xFF;
N             CPU_CRITICAL_EXIT();
X             { CPU_SR_Restore(cpu_sr); };
N             break;
N
N        case CPU_INT_PENDSV:                                    /* PendSV.                                              */
X        case 14:                                     
N             CPU_CRITICAL_ENTER();
X             { cpu_sr = CPU_SR_Save(); };
N             temp = CPU_REG_NVIC_SHPRI3;
X             temp = (*((volatile CPU_INT32U *)(0xE000ED20)));
N             prio = (temp >> (2 * DEF_OCTET_NBR_BITS)) & DEF_OCTET_MASK;
X             prio = (temp >> (2 * 8)) & 0xFF;
N             CPU_CRITICAL_EXIT();
X             { CPU_SR_Restore(cpu_sr); };
N             break;
N
N        case CPU_INT_SYSTICK:                                   /* SysTick.                                             */
X        case 15:                                    
N             CPU_CRITICAL_ENTER();
X             { cpu_sr = CPU_SR_Save(); };
N             temp = CPU_REG_NVIC_SHPRI3;
X             temp = (*((volatile CPU_INT32U *)(0xE000ED20)));
N             prio = (temp >> (3 * DEF_OCTET_NBR_BITS)) & DEF_OCTET_MASK;
X             prio = (temp >> (3 * 8)) & 0xFF;
N             CPU_CRITICAL_EXIT();
X             { CPU_SR_Restore(cpu_sr); };
N             break;
N
N
N                                                                /* ---------------- EXTERNAL INTERRUPT ---------------- */
N        default:
N            pos_max = CPU_INT_SRC_POS_MAX;
X            pos_max = (((((*((volatile CPU_INT32U *)(0xE000E004))) + 1) & 0x1F) * 32) + 1);
N            if (pos < pos_max) {                                /* See Note #3.                                         */
N                 group = (pos - 16) / 4;
N                 nbr   = (pos - 16) % 4;
N
N                 CPU_CRITICAL_ENTER();
X                 { cpu_sr = CPU_SR_Save(); };
N                 temp  = CPU_REG_NVIC_PRIO(group);
X                 temp  = (*((volatile CPU_INT32U *)(0xE000E400 + (group) * 4)));
N                 CPU_CRITICAL_EXIT();
X                 { CPU_SR_Restore(cpu_sr); };
N
N                 prio  = (temp >> (nbr * DEF_OCTET_NBR_BITS)) & DEF_OCTET_MASK;
X                 prio  = (temp >> (nbr * 8)) & 0xFF;
N             } else {
N                 prio  = DEF_INT_16S_MIN_VAL;
X                 prio  = -32768;
N             }
N             break;
N    }
N
N    if (prio >= 0) {
N        prio_32 = CPU_RevBits((CPU_INT32U)prio);
N        prio    = (CPU_INT16S)(prio_32 >> (3 * DEF_OCTET_NBR_BITS));
X        prio    = (CPU_INT16S)(prio_32 >> (3 * 8));
N    }
N
N    return (prio);
N}
