; generated by ARM/Thumb C/C++ Compiler with , RVCT3.1 [Build 919] for uVision
; commandline ArmCC [--debug -c --asm --interleave -o.\output\stm32f10x_usart.o --depend=.\output\stm32f10x_usart.d --device=DARMSTM --apcs=interwork -O1 -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -IC:\Keil\ARM\INC\ST\STM32F10x --omf_browse=.\output\stm32f10x_usart.crf ..\..\..\..\..\CPU\ST\STM32\src\stm32f10x_usart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  USART_DeInit PROC
;;;92     void USART_DeInit(USART_TypeDef* USARTx)
;;;93     {
000000  b510              PUSH     {r4,lr}
;;;94       /* Check the parameters */
;;;95       assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;96     
;;;97       switch (*(u32*)&USARTx)
000002  4ac1              LDR      r2,|L1.776|
000004  1a81              SUBS     r1,r0,r2
000006  1513              ASRS     r3,r2,#20
000008  4290              CMP      r0,r2
00000a  d02b              BEQ      |L1.100|
00000c  dc0f              BGT      |L1.46|
00000e  49bf              LDR      r1,|L1.780|
000010  1840              ADDS     r0,r0,r1
000012  d01c              BEQ      |L1.78|
000014  4298              CMP      r0,r3
000016  d13b              BNE      |L1.144|
;;;98       {
;;;99         case USART1_BASE:
;;;100          RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
;;;101          RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
;;;102          break;
;;;103    
;;;104        case USART2_BASE:
;;;105          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
;;;106          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
;;;107          break;
;;;108    
;;;109        case USART3_BASE:
;;;110          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
000018  2101              MOVS     r1,#1
00001a  048c              LSLS     r4,r1,#18
00001c  4620              MOV      r0,r4
00001e  f7fff7ff          BL       RCC_APB1PeriphResetCmd
;;;111          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
000022  4620              MOV      r0,r4
000024  e8bde8bd          POP      {r4,lr}
000028  2100              MOVS     r1,#0
00002a  f7fff7ff          B.W      RCC_APB1PeriphResetCmd
                  |L1.46|
00002e  4299              CMP      r1,r3                 ;97
000030  d023              BEQ      |L1.122|
000032  f5b1f5b1          CMP      r1,#0xec00            ;97
000036  d12b              BNE      |L1.144|
000038  2101              MOVS     r1,#1                 ;100
00003a  038c              LSLS     r4,r1,#14             ;100
00003c  4620              MOV      r0,r4                 ;100
00003e  f7fff7ff          BL       RCC_APB2PeriphResetCmd
000042  4620              MOV      r0,r4                 ;101
000044  e8bde8bd          POP      {r4,lr}               ;101
000048  2100              MOVS     r1,#0                 ;101
00004a  f7fff7ff          B.W      RCC_APB2PeriphResetCmd
                  |L1.78|
00004e  2101              MOVS     r1,#1                 ;105
000050  044c              LSLS     r4,r1,#17             ;105
000052  4620              MOV      r0,r4                 ;105
000054  f7fff7ff          BL       RCC_APB1PeriphResetCmd
000058  4620              MOV      r0,r4                 ;106
00005a  e8bde8bd          POP      {r4,lr}               ;106
00005e  2100              MOVS     r1,#0                 ;106
000060  f7fff7ff          B.W      RCC_APB1PeriphResetCmd
                  |L1.100|
;;;112          break;
;;;113        
;;;114        case UART4_BASE:
;;;115          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
000064  2101              MOVS     r1,#1
000066  04cc              LSLS     r4,r1,#19
000068  4620              MOV      r0,r4
00006a  f7fff7ff          BL       RCC_APB1PeriphResetCmd
;;;116          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
00006e  4620              MOV      r0,r4
000070  e8bde8bd          POP      {r4,lr}
000074  2100              MOVS     r1,#0
000076  f7fff7ff          B.W      RCC_APB1PeriphResetCmd
                  |L1.122|
;;;117          break;
;;;118        
;;;119        case UART5_BASE:
;;;120          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
00007a  2101              MOVS     r1,#1
00007c  050c              LSLS     r4,r1,#20
00007e  4620              MOV      r0,r4
000080  f7fff7ff          BL       RCC_APB1PeriphResetCmd
;;;121          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
000084  4620              MOV      r0,r4
000086  e8bde8bd          POP      {r4,lr}
00008a  2100              MOVS     r1,#0
00008c  f7fff7ff          B.W      RCC_APB1PeriphResetCmd
                  |L1.144|
;;;122          break;            
;;;123    
;;;124        default:
;;;125          break;
;;;126      }
;;;127    }
000090  bd10              POP      {r4,pc}
;;;128    
                          ENDP

                  USART_Init PROC
;;;142    void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
;;;143    {
000092  b530              PUSH     {r4,r5,lr}
000094  b085              SUB      sp,sp,#0x14
000096  4604              MOV      r4,r0
000098  460d              MOV      r5,r1
;;;144      u32 tmpreg = 0x00, apbclock = 0x00;
;;;145      u32 integerdivider = 0x00;
;;;146      u32 fractionaldivider = 0x00;
;;;147      u32 usartxbase = 0;
;;;148      RCC_ClocksTypeDef RCC_ClocksStatus;
;;;149    
;;;150      /* Check the parameters */
;;;151      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;152      assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
;;;153      assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
;;;154      assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
;;;155      assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
;;;156      assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
;;;157      assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
;;;158      /* The hardware flow control is available only for USART1, USART2 and USART3 */          
;;;159      assert_param(IS_USART_PERIPH_HFC(USARTx, USART_InitStruct->USART_HardwareFlowControl));
;;;160      
;;;161      usartxbase = (*(u32*)&USARTx);
;;;162    
;;;163    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;164      tmpreg = USARTx->CR2;
00009a  8a20              LDRH     r0,[r4,#0x10]
;;;165      /* Clear STOP[13:12] bits */
;;;166      tmpreg &= CR2_STOP_CLEAR_Mask;
00009c  f64cf64c          MOV      r1,#0xcfff
0000a0  4008              ANDS     r0,r0,r1
;;;167    
;;;168      /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
;;;169      /* Set STOP[13:12] bits according to USART_StopBits value */
;;;170      tmpreg |= (u32)USART_InitStruct->USART_StopBits;
0000a2  88e9              LDRH     r1,[r5,#6]
0000a4  4301              ORRS     r1,r1,r0
;;;171      
;;;172      /* Write to USART CR2 */
;;;173      USARTx->CR2 = (u16)tmpreg;
0000a6  8221              STRH     r1,[r4,#0x10]
;;;174    
;;;175    /*---------------------------- USART CR1 Configuration -----------------------*/
;;;176      tmpreg = USARTx->CR1;
0000a8  89a0              LDRH     r0,[r4,#0xc]
;;;177      /* Clear M, PCE, PS, TE and RE bits */
;;;178      tmpreg &= CR1_CLEAR_Mask;
0000aa  f64ef64e          MOV      r1,#0xe9f3
0000ae  4008              ANDS     r0,r0,r1
;;;179    
;;;180      /* Configure the USART Word Length, Parity and mode ----------------------- */
;;;181      /* Set the M bits according to USART_WordLength value */
;;;182      /* Set PCE and PS bits according to USART_Parity value */
;;;183      /* Set TE and RE bits according to USART_Mode value */
;;;184      tmpreg |= (u32)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
0000b0  88a9              LDRH     r1,[r5,#4]
0000b2  892a              LDRH     r2,[r5,#8]
0000b4  4311              ORRS     r1,r1,r2
0000b6  896a              LDRH     r2,[r5,#0xa]
0000b8  4302              ORRS     r2,r2,r0
0000ba  4311              ORRS     r1,r1,r2
;;;185                USART_InitStruct->USART_Mode;
;;;186    
;;;187      /* Write to USART CR1 */
;;;188      USARTx->CR1 = (u16)tmpreg;
0000bc  81a1              STRH     r1,[r4,#0xc]
;;;189    
;;;190    /*---------------------------- USART CR3 Configuration -----------------------*/  
;;;191      tmpreg = USARTx->CR3;
0000be  8aa0              LDRH     r0,[r4,#0x14]
;;;192      /* Clear CTSE and RTSE bits */
;;;193      tmpreg &= CR3_CLEAR_Mask;
0000c0  f64ff64f          MOV      r1,#0xfcff
0000c4  4008              ANDS     r0,r0,r1
;;;194    
;;;195      /* Configure the USART HFC -------------------------------------------------*/
;;;196      /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
;;;197      tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
0000c6  89a9              LDRH     r1,[r5,#0xc]
0000c8  4301              ORRS     r1,r1,r0
;;;198    
;;;199      /* Write to USART CR3 */
;;;200      USARTx->CR3 = (u16)tmpreg;
0000ca  82a1              STRH     r1,[r4,#0x14]
;;;201    
;;;202    /*---------------------------- USART BRR Configuration -----------------------*/
;;;203      /* Configure the USART Baud Rate -------------------------------------------*/
;;;204      RCC_GetClocksFreq(&RCC_ClocksStatus);
0000cc  4668              MOV      r0,sp
0000ce  f7fff7ff          BL       RCC_GetClocksFreq
;;;205      if (usartxbase == USART1_BASE)
0000d2  488f              LDR      r0,|L1.784|
0000d4  4284              CMP      r4,r0
0000d6  d101              BNE      |L1.220|
;;;206      {
;;;207        apbclock = RCC_ClocksStatus.PCLK2_Frequency;
0000d8  9803              LDR      r0,[sp,#0xc]
0000da  e000              B        |L1.222|
                  |L1.220|
;;;208      }
;;;209      else
;;;210      {
;;;211        apbclock = RCC_ClocksStatus.PCLK1_Frequency;
0000dc  9802              LDR      r0,[sp,#8]
                  |L1.222|
;;;212      }
;;;213    
;;;214      /* Determine the integer part */
;;;215      integerdivider = ((0x19 * apbclock) / (0x04 * (USART_InitStruct->USART_BaudRate)));
0000de  2119              MOVS     r1,#0x19
0000e0  4348              MULS     r0,r1,r0
0000e2  6829              LDR      r1,[r5,#0]
0000e4  0089              LSLS     r1,r1,#2
0000e6  fbb0fbb0          UDIV     r0,r0,r1
;;;216      tmpreg = (integerdivider / 0x64) << 0x04;
0000ea  2364              MOVS     r3,#0x64
0000ec  fbb0fbb0          UDIV     r1,r0,r3
0000f0  0109              LSLS     r1,r1,#4
;;;217    
;;;218      /* Determine the fractional part */
;;;219      fractionaldivider = integerdivider - (0x64 * (tmpreg >> 0x04));
0000f2  090a              LSRS     r2,r1,#4
0000f4  f06ff06f          MVN      r5,#0x18
0000f8  436a              MULS     r2,r5,r2
0000fa  eb00eb00          ADD      r0,r0,r2,LSL #2
;;;220      tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) & ((u8)0x0F);
0000fe  2232              MOVS     r2,#0x32
000100  eb02eb02          ADD      r0,r2,r0,LSL #4
000104  fbb0fbb0          UDIV     r0,r0,r3
000108  f000f000          AND      r0,r0,#0xf
00010c  4308              ORRS     r0,r0,r1
;;;221    
;;;222      /* Write to USART BRR */
;;;223      USARTx->BRR = (u16)tmpreg;
00010e  8120              STRH     r0,[r4,#8]
;;;224    }
000110  b005              ADD      sp,sp,#0x14
000112  bd30              POP      {r4,r5,pc}
;;;225    
                          ENDP

                  USART_StructInit PROC
;;;236      /* USART_InitStruct members default value */
;;;237      USART_InitStruct->USART_BaudRate = 9600;
000114  f44ff44f          MOV      r1,#0x2580
000118  6001              STR      r1,[r0,#0]
;;;238      USART_InitStruct->USART_WordLength = USART_WordLength_8b;
00011a  2100              MOVS     r1,#0
00011c  8081              STRH     r1,[r0,#4]
;;;239      USART_InitStruct->USART_StopBits = USART_StopBits_1;
00011e  80c1              STRH     r1,[r0,#6]
;;;240      USART_InitStruct->USART_Parity = USART_Parity_No ;
000120  8101              STRH     r1,[r0,#8]
;;;241      USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000122  220c              MOVS     r2,#0xc
000124  8142              STRH     r2,[r0,#0xa]
;;;242      USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
000126  8181              STRH     r1,[r0,#0xc]
;;;243    }
000128  4770              BX       lr
;;;244    
                          ENDP

                  USART_ClockInit PROC
;;;257    void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
;;;258    {
00012a  b510              PUSH     {r4,lr}
;;;259      u32 tmpreg = 0x00;
;;;260    
;;;261      /* Check the parameters */
;;;262      assert_param(IS_USART_123_PERIPH(USARTx));
;;;263      assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
;;;264      assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
;;;265      assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
;;;266      assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));              
;;;267      
;;;268    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;269      tmpreg = USARTx->CR2;
00012c  8a02              LDRH     r2,[r0,#0x10]
;;;270      /* Clear CLKEN, CPOL, CPHA and LBCL bits */
;;;271      tmpreg &= CR2_CLOCK_CLEAR_Mask;
00012e  f24ff24f          MOV      r3,#0xf0ff
000132  401a              ANDS     r2,r2,r3
;;;272    
;;;273      /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
;;;274      /* Set CLKEN bit according to USART_Clock value */
;;;275      /* Set CPOL bit according to USART_CPOL value */
;;;276      /* Set CPHA bit according to USART_CPHA value */
;;;277      /* Set LBCL bit according to USART_LastBit value */
;;;278      tmpreg |= (u32)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
000134  880b              LDRH     r3,[r1,#0]
000136  884c              LDRH     r4,[r1,#2]
000138  4323              ORRS     r3,r3,r4
00013a  888c              LDRH     r4,[r1,#4]
00013c  88c9              LDRH     r1,[r1,#6]
00013e  430c              ORRS     r4,r4,r1
000140  4323              ORRS     r3,r3,r4
000142  4313              ORRS     r3,r3,r2
;;;279                     USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
;;;280    
;;;281      /* Write to USART CR2 */
;;;282      USARTx->CR2 = (u16)tmpreg;
000144  8203              STRH     r3,[r0,#0x10]
;;;283    }
000146  bd10              POP      {r4,pc}
;;;284    
                          ENDP

                  USART_ClockStructInit PROC
;;;295      /* USART_ClockInitStruct members default value */
;;;296      USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
000148  2100              MOVS     r1,#0
00014a  8001              STRH     r1,[r0,#0]
;;;297      USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
00014c  8041              STRH     r1,[r0,#2]
;;;298      USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
00014e  8081              STRH     r1,[r0,#4]
;;;299      USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
000150  80c1              STRH     r1,[r0,#6]
;;;300    }
000152  4770              BX       lr
;;;301    
                          ENDP

                  USART_Cmd PROC
;;;318      
;;;319      if (NewState != DISABLE)
000154  b121              CBZ      r1,|L1.352|
;;;320      {
;;;321        /* Enable the selected USART by setting the UE bit in the CR1 register */
;;;322        USARTx->CR1 |= CR1_UE_Set;
000156  8981              LDRH     r1,[r0,#0xc]
000158  f441f441          ORR      r1,r1,#0x2000
00015c  8181              STRH     r1,[r0,#0xc]
;;;323      }
;;;324      else
;;;325      {
;;;326        /* Disable the selected USART by clearing the UE bit in the CR1 register */
;;;327        USARTx->CR1 &= CR1_UE_Reset;
;;;328      }
;;;329    }
00015e  4770              BX       lr
                  |L1.352|
000160  8981              LDRH     r1,[r0,#0xc]          ;327
000162  f421f421          BIC      r1,r1,#0x2000         ;327
000166  8181              STRH     r1,[r0,#0xc]          ;327
000168  4770              BX       lr
;;;330    
                          ENDP

                  USART_ITConfig PROC
;;;356    void USART_ITConfig(USART_TypeDef* USARTx, u16 USART_IT, FunctionalState NewState)
;;;357    {
00016a  b510              PUSH     {r4,lr}
;;;358      u32 usartreg = 0x00, itpos = 0x00, itmask = 0x00;
;;;359      u32 usartxbase = 0x00;
;;;360    
;;;361      /* Check the parameters */
;;;362      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;363      assert_param(IS_USART_CONFIG_IT(USART_IT));
;;;364      assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */     
;;;365      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;366    
;;;367      usartxbase = (*(u32*)&(USARTx));
;;;368    
;;;369      /* Get the USART register index */
;;;370      usartreg = (((u8)USART_IT) >> 0x05);
00016c  f3c1f3c1          UBFX     r3,r1,#5,#3
;;;371    
;;;372      /* Get the interrupt position */
;;;373      itpos = USART_IT & IT_Mask;
000170  f001f001          AND      r4,r1,#0x1f
;;;374    
;;;375      itmask = (((u32)0x01) << itpos);
000174  2101              MOVS     r1,#1
000176  40a1              LSLS     r1,r1,r4
;;;376        
;;;377      if (usartreg == 0x01) /* The IT is in CR1 register */
000178  2b01              CMP      r3,#1
00017a  d101              BNE      |L1.384|
;;;378      {
;;;379        usartxbase += 0x0C;
00017c  300c              ADDS     r0,r0,#0xc
00017e  e004              B        |L1.394|
                  |L1.384|
;;;380      }
;;;381      else if (usartreg == 0x02) /* The IT is in CR2 register */
000180  2b02              CMP      r3,#2
000182  d101              BNE      |L1.392|
;;;382      {
;;;383        usartxbase += 0x10;
000184  3010              ADDS     r0,r0,#0x10
000186  e000              B        |L1.394|
                  |L1.392|
;;;384      }
;;;385      else /* The IT is in CR3 register */
;;;386      {
;;;387        usartxbase += 0x14; 
000188  3014              ADDS     r0,r0,#0x14
                  |L1.394|
;;;388      }
;;;389      if (NewState != DISABLE)
00018a  b11a              CBZ      r2,|L1.404|
;;;390      {
;;;391        *(vu32*)usartxbase  |= itmask;
00018c  6802              LDR      r2,[r0,#0]
00018e  430a              ORRS     r2,r2,r1
000190  6002              STR      r2,[r0,#0]
;;;392      }
;;;393      else
;;;394      {
;;;395        *(vu32*)usartxbase &= ~itmask;
;;;396      }
;;;397    }
000192  bd10              POP      {r4,pc}
                  |L1.404|
000194  6802              LDR      r2,[r0,#0]            ;395
000196  438a              BICS     r2,r2,r1              ;395
000198  6002              STR      r2,[r0,#0]            ;395
00019a  bd10              POP      {r4,pc}
;;;398    
                          ENDP

                  USART_DMACmd PROC
;;;421    
;;;422      if (NewState != DISABLE)
00019c  b11a              CBZ      r2,|L1.422|
;;;423      {
;;;424        /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;425           DMAR bits in the USART CR3 register */
;;;426        USARTx->CR3 |= USART_DMAReq;
00019e  8a82              LDRH     r2,[r0,#0x14]
0001a0  430a              ORRS     r2,r2,r1
0001a2  8282              STRH     r2,[r0,#0x14]
;;;427      }
;;;428      else
;;;429      {
;;;430        /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;431           DMAR bits in the USART CR3 register */
;;;432        USARTx->CR3 &= (u16)~USART_DMAReq;
;;;433      }
;;;434    }
0001a4  4770              BX       lr
                  |L1.422|
0001a6  8a82              LDRH     r2,[r0,#0x14]         ;432
0001a8  438a              BICS     r2,r2,r1              ;432
0001aa  8282              STRH     r2,[r0,#0x14]         ;432
0001ac  4770              BX       lr
;;;435    
                          ENDP

                  USART_SetAddress PROC
;;;452      /* Clear the USART address */
;;;453      USARTx->CR2 &= CR2_Address_Mask;
0001ae  8a02              LDRH     r2,[r0,#0x10]
0001b0  f022f022          BIC      r2,r2,#0xf
0001b4  8202              STRH     r2,[r0,#0x10]
;;;454      /* Set the USART address node */
;;;455      USARTx->CR2 |= USART_Address;
0001b6  8a02              LDRH     r2,[r0,#0x10]
0001b8  430a              ORRS     r2,r2,r1
0001ba  8202              STRH     r2,[r0,#0x10]
;;;456    }
0001bc  4770              BX       lr
;;;457    
                          ENDP

                  USART_WakeUpConfig PROC
;;;476      
;;;477      USARTx->CR1 &= CR1_WAKE_Mask;
0001be  8982              LDRH     r2,[r0,#0xc]
0001c0  f422f422          BIC      r2,r2,#0x800
0001c4  8182              STRH     r2,[r0,#0xc]
;;;478      USARTx->CR1 |= USART_WakeUp;
0001c6  8982              LDRH     r2,[r0,#0xc]
0001c8  430a              ORRS     r2,r2,r1
0001ca  8182              STRH     r2,[r0,#0xc]
;;;479    }
0001cc  4770              BX       lr
;;;480    
                          ENDP

                  USART_ReceiverWakeUpCmd PROC
;;;497      
;;;498      if (NewState != DISABLE)
0001ce  b121              CBZ      r1,|L1.474|
;;;499      {
;;;500        /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;501        USARTx->CR1 |= CR1_RWU_Set;
0001d0  8981              LDRH     r1,[r0,#0xc]
0001d2  f041f041          ORR      r1,r1,#2
0001d6  8181              STRH     r1,[r0,#0xc]
;;;502      }
;;;503      else
;;;504      {
;;;505        /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;506        USARTx->CR1 &= CR1_RWU_Reset;
;;;507      }
;;;508    }
0001d8  4770              BX       lr
                  |L1.474|
0001da  8981              LDRH     r1,[r0,#0xc]          ;506
0001dc  f021f021          BIC      r1,r1,#2              ;506
0001e0  8181              STRH     r1,[r0,#0xc]          ;506
0001e2  4770              BX       lr
;;;509    
                          ENDP

                  USART_LINBreakDetectLengthConfig PROC
;;;529      
;;;530      USARTx->CR2 &= CR2_LBDL_Mask;
0001e4  8a02              LDRH     r2,[r0,#0x10]
0001e6  f022f022          BIC      r2,r2,#0x20
0001ea  8202              STRH     r2,[r0,#0x10]
;;;531      USARTx->CR2 |= USART_LINBreakDetectLength;  
0001ec  8a02              LDRH     r2,[r0,#0x10]
0001ee  430a              ORRS     r2,r2,r1
0001f0  8202              STRH     r2,[r0,#0x10]
;;;532    }
0001f2  4770              BX       lr
;;;533    
                          ENDP

                  USART_LINCmd PROC
;;;550      
;;;551      if (NewState != DISABLE)
0001f4  b121              CBZ      r1,|L1.512|
;;;552      {
;;;553        /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;554        USARTx->CR2 |= CR2_LINEN_Set;
0001f6  8a01              LDRH     r1,[r0,#0x10]
0001f8  f441f441          ORR      r1,r1,#0x4000
0001fc  8201              STRH     r1,[r0,#0x10]
;;;555      }
;;;556      else
;;;557      {
;;;558        /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
;;;559        USARTx->CR2 &= CR2_LINEN_Reset;
;;;560      }
;;;561    }
0001fe  4770              BX       lr
                  |L1.512|
000200  8a01              LDRH     r1,[r0,#0x10]         ;559
000202  f421f421          BIC      r1,r1,#0x4000         ;559
000206  8201              STRH     r1,[r0,#0x10]         ;559
000208  4770              BX       lr
;;;562    
                          ENDP

                  USART_SendData PROC
;;;579      /* Transmit Data */
;;;580      USARTx->DR = (Data & (u16)0x01FF);
00020a  f3c1f3c1          UBFX     r1,r1,#0,#9
00020e  8081              STRH     r1,[r0,#4]
;;;581    }
000210  4770              BX       lr
;;;582    
                          ENDP

                  USART_ReceiveData PROC
;;;597      /* Receive Data */
;;;598      return (u16)(USARTx->DR & (u16)0x01FF);
000212  8880              LDRH     r0,[r0,#4]
000214  f3c0f3c0          UBFX     r0,r0,#0,#9
;;;599    }
000218  4770              BX       lr
;;;600    
                          ENDP

                  USART_SendBreak PROC
;;;615      /* Send break characters */
;;;616      USARTx->CR1 |= CR1_SBK_Set;
00021a  8981              LDRH     r1,[r0,#0xc]
00021c  f041f041          ORR      r1,r1,#1
000220  8181              STRH     r1,[r0,#0xc]
;;;617    }
000222  4770              BX       lr
;;;618    
                          ENDP

                  USART_SetGuardTime PROC
;;;634      /* Clear the USART Guard time */
;;;635      USARTx->GTPR &= GTPR_LSB_Mask;
000224  8b02              LDRH     r2,[r0,#0x18]
000226  b2d2              UXTB     r2,r2
000228  8302              STRH     r2,[r0,#0x18]
;;;636      /* Set the USART guard time */
;;;637      USARTx->GTPR |= (u16)((u16)USART_GuardTime << 0x08);
00022a  8b02              LDRH     r2,[r0,#0x18]
00022c  ea42ea42          ORR      r1,r2,r1,LSL #8
000230  8301              STRH     r1,[r0,#0x18]
;;;638    }
000232  4770              BX       lr
;;;639    
                          ENDP

                  USART_SetPrescaler PROC
;;;656      /* Clear the USART prescaler */
;;;657      USARTx->GTPR &= GTPR_MSB_Mask;
000234  8b02              LDRH     r2,[r0,#0x18]
000236  f402f402          AND      r2,r2,#0xff00
00023a  8302              STRH     r2,[r0,#0x18]
;;;658      /* Set the USART prescaler */
;;;659      USARTx->GTPR |= USART_Prescaler;
00023c  8b02              LDRH     r2,[r0,#0x18]
00023e  430a              ORRS     r2,r2,r1
000240  8302              STRH     r2,[r0,#0x18]
;;;660    }
000242  4770              BX       lr
;;;661    
                          ENDP

                  USART_SmartCardCmd PROC
;;;678    
;;;679      if (NewState != DISABLE)
000244  b121              CBZ      r1,|L1.592|
;;;680      {
;;;681        /* Enable the SC mode by setting the SCEN bit in the CR3 register */
;;;682        USARTx->CR3 |= CR3_SCEN_Set;
000246  8a81              LDRH     r1,[r0,#0x14]
000248  f041f041          ORR      r1,r1,#0x20
00024c  8281              STRH     r1,[r0,#0x14]
;;;683      }
;;;684      else
;;;685      {
;;;686        /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
;;;687        USARTx->CR3 &= CR3_SCEN_Reset;
;;;688      }
;;;689    }
00024e  4770              BX       lr
                  |L1.592|
000250  8a81              LDRH     r1,[r0,#0x14]         ;687
000252  f021f021          BIC      r1,r1,#0x20           ;687
000256  8281              STRH     r1,[r0,#0x14]         ;687
000258  4770              BX       lr
;;;690    
                          ENDP

                  USART_SmartCardNACKCmd PROC
;;;707    
;;;708      if (NewState != DISABLE)
00025a  b121              CBZ      r1,|L1.614|
;;;709      {
;;;710        /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
;;;711        USARTx->CR3 |= CR3_NACK_Set;
00025c  8a81              LDRH     r1,[r0,#0x14]
00025e  f041f041          ORR      r1,r1,#0x10
000262  8281              STRH     r1,[r0,#0x14]
;;;712      }
;;;713      else
;;;714      {
;;;715        /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
;;;716        USARTx->CR3 &= CR3_NACK_Reset;
;;;717      }
;;;718    }
000264  4770              BX       lr
                  |L1.614|
000266  8a81              LDRH     r1,[r0,#0x14]         ;716
000268  f021f021          BIC      r1,r1,#0x10           ;716
00026c  8281              STRH     r1,[r0,#0x14]         ;716
00026e  4770              BX       lr
;;;719    
                          ENDP

                  USART_HalfDuplexCmd PROC
;;;736      
;;;737      if (NewState != DISABLE)
000270  b121              CBZ      r1,|L1.636|
;;;738      {
;;;739        /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;740        USARTx->CR3 |= CR3_HDSEL_Set;
000272  8a81              LDRH     r1,[r0,#0x14]
000274  f041f041          ORR      r1,r1,#8
000278  8281              STRH     r1,[r0,#0x14]
;;;741      }
;;;742      else
;;;743      {
;;;744        /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
;;;745        USARTx->CR3 &= CR3_HDSEL_Reset;
;;;746      }
;;;747    }
00027a  4770              BX       lr
                  |L1.636|
00027c  8a81              LDRH     r1,[r0,#0x14]         ;745
00027e  f021f021          BIC      r1,r1,#8              ;745
000282  8281              STRH     r1,[r0,#0x14]         ;745
000284  4770              BX       lr
;;;748    
                          ENDP

                  USART_IrDAConfig PROC
;;;767        
;;;768      USARTx->CR3 &= CR3_IRLP_Mask;
000286  8a82              LDRH     r2,[r0,#0x14]
000288  f022f022          BIC      r2,r2,#4
00028c  8282              STRH     r2,[r0,#0x14]
;;;769      USARTx->CR3 |= USART_IrDAMode;
00028e  8a82              LDRH     r2,[r0,#0x14]
000290  430a              ORRS     r2,r2,r1
000292  8282              STRH     r2,[r0,#0x14]
;;;770    }
000294  4770              BX       lr
;;;771    
                          ENDP

                  USART_IrDACmd PROC
;;;788        
;;;789      if (NewState != DISABLE)
000296  b121              CBZ      r1,|L1.674|
;;;790      {
;;;791        /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
;;;792        USARTx->CR3 |= CR3_IREN_Set;
000298  8a81              LDRH     r1,[r0,#0x14]
00029a  f041f041          ORR      r1,r1,#2
00029e  8281              STRH     r1,[r0,#0x14]
;;;793      }
;;;794      else
;;;795      {
;;;796        /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
;;;797        USARTx->CR3 &= CR3_IREN_Reset;
;;;798      }
;;;799    }
0002a0  4770              BX       lr
                  |L1.674|
0002a2  8a81              LDRH     r1,[r0,#0x14]         ;797
0002a4  f021f021          BIC      r1,r1,#2              ;797
0002a8  8281              STRH     r1,[r0,#0x14]         ;797
0002aa  4770              BX       lr
;;;800    
                          ENDP

                  USART_GetFlagStatus PROC
;;;823    FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, u16 USART_FLAG)
;;;824    {
0002ac  4602              MOV      r2,r0
;;;825      FlagStatus bitstatus = RESET;
0002ae  2000              MOVS     r0,#0
;;;826    
;;;827      /* Check the parameters */
;;;828      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;829      assert_param(IS_USART_FLAG(USART_FLAG));
;;;830      assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART4 and UART5 */   
;;;831    
;;;832      if ((USARTx->SR & USART_FLAG) != (u16)RESET)
0002b0  8812              LDRH     r2,[r2,#0]
0002b2  420a              TST      r2,r1
0002b4  d000              BEQ      |L1.696|
;;;833      {
;;;834        bitstatus = SET;
0002b6  2001              MOVS     r0,#1
                  |L1.696|
;;;835      }
;;;836      else
;;;837      {
;;;838        bitstatus = RESET;
;;;839      }
;;;840      return bitstatus;
;;;841    }
0002b8  4770              BX       lr
;;;842    
                          ENDP

                  USART_ClearFlag PROC
;;;875       
;;;876      USARTx->SR = (u16)~USART_FLAG;
0002ba  43c9              MVNS     r1,r1
0002bc  8001              STRH     r1,[r0,#0]
;;;877    }
0002be  4770              BX       lr
;;;878    
                          ENDP

                  USART_GetITStatus PROC
;;;902    ITStatus USART_GetITStatus(USART_TypeDef* USARTx, u16 USART_IT)
;;;903    {
0002c0  b570              PUSH     {r4-r6,lr}
;;;904      u32 bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
;;;905      ITStatus bitstatus = RESET;
0002c2  2400              MOVS     r4,#0
;;;906    
;;;907      /* Check the parameters */
;;;908      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;909      assert_param(IS_USART_IT(USART_IT));
;;;910      assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */  
;;;911      
;;;912      /* Get the USART register index */
;;;913      usartreg = (((u8)USART_IT) >> 0x05);
0002c4  f3c1f3c1          UBFX     r3,r1,#5,#3
;;;914    
;;;915      /* Get the interrupt position */
;;;916      itmask = USART_IT & IT_Mask;
0002c8  f001f001          AND      r5,r1,#0x1f
;;;917    
;;;918      itmask = (u32)0x01 << itmask;
0002cc  2601              MOVS     r6,#1
0002ce  fa06fa06          LSL      r2,r6,r5
;;;919      
;;;920      if (usartreg == 0x01) /* The IT  is in CR1 register */
0002d2  2b01              CMP      r3,#1
0002d4  d102              BNE      |L1.732|
;;;921      {
;;;922        itmask &= USARTx->CR1;
0002d6  8983              LDRH     r3,[r0,#0xc]
0002d8  4013              ANDS     r3,r3,r2
0002da  e006              B        |L1.746|
                  |L1.732|
;;;923      }
;;;924      else if (usartreg == 0x02) /* The IT  is in CR2 register */
0002dc  2b02              CMP      r3,#2
0002de  d102              BNE      |L1.742|
;;;925      {
;;;926        itmask &= USARTx->CR2;
0002e0  8a03              LDRH     r3,[r0,#0x10]
0002e2  4013              ANDS     r3,r3,r2
0002e4  e001              B        |L1.746|
                  |L1.742|
;;;927      }
;;;928      else /* The IT  is in CR3 register */
;;;929      {
;;;930        itmask &= USARTx->CR3;
0002e6  8a83              LDRH     r3,[r0,#0x14]
0002e8  4013              ANDS     r3,r3,r2
                  |L1.746|
;;;931      }
;;;932      
;;;933      bitpos = USART_IT >> 0x08;
0002ea  0a09              LSRS     r1,r1,#8
;;;934    
;;;935      bitpos = (u32)0x01 << bitpos;
0002ec  408e              LSLS     r6,r6,r1
;;;936      bitpos &= USARTx->SR;
0002ee  8800              LDRH     r0,[r0,#0]
0002f0  4030              ANDS     r0,r0,r6
;;;937    
;;;938      if ((itmask != (u16)RESET)&&(bitpos != (u16)RESET))
0002f2  b10b              CBZ      r3,|L1.760|
0002f4  b100              CBZ      r0,|L1.760|
;;;939      {
;;;940        bitstatus = SET;
0002f6  2401              MOVS     r4,#1
                  |L1.760|
;;;941      }
;;;942      else
;;;943      {
;;;944        bitstatus = RESET;
;;;945      }
;;;946      
;;;947      return bitstatus;  
0002f8  4620              MOV      r0,r4
;;;948    }
0002fa  bd70              POP      {r4-r6,pc}
;;;949    
                          ENDP

                  USART_ClearITPendingBit PROC
;;;984      
;;;985      bitpos = USART_IT >> 0x08;
0002fc  0a0a              LSRS     r2,r1,#8
;;;986    
;;;987      itmask = (u16)((u16)0x01 << bitpos);
0002fe  2101              MOVS     r1,#1
000300  4091              LSLS     r1,r1,r2
;;;988      USARTx->SR = (u16)~itmask;
000302  43c9              MVNS     r1,r1
000304  8001              STRH     r1,[r0,#0]
;;;989    }
000306  4770              BX       lr
;;;990    
                          ENDP

                  |L1.776|
000308  40004c00          DCD      0x40004c00
                  |L1.780|
00030c  bfffbc00          DCD      0xbfffbc00
                  |L1.784|
000310  40013800          DCD      0x40013800
