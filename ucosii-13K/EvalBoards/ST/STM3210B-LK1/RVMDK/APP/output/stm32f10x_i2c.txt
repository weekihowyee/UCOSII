; generated by ARM/Thumb C/C++ Compiler with , RVCT3.1 [Build 919] for uVision
; commandline ArmCC [--debug -c --asm --interleave -o.\output\stm32f10x_i2c.o --depend=.\output\stm32f10x_i2c.d --device=DARMSTM --apcs=interwork -O1 -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -IC:\Keil\ARM\INC\ST\STM32F10x --omf_browse=.\output\stm32f10x_i2c.crf ..\..\..\..\..\CPU\ST\STM32\src\stm32f10x_i2c.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  I2C_DeInit PROC
;;;111    void I2C_DeInit(I2C_TypeDef* I2Cx)
;;;112    {
000000  b510              PUSH     {r4,lr}
;;;113      /* Check the parameters */
;;;114      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;115    
;;;116      switch (*(u32*)&I2Cx)
000002  49da              LDR      r1,|L1.876|
000004  1840              ADDS     r0,r0,r1
000006  d00d              BEQ      |L1.36|
000008  f5b0f5b0          CMP      r0,#0x400
00000c  d115              BNE      |L1.58|
;;;117      {
;;;118        case I2C1_BASE:
;;;119          /* Enable I2C1 reset state */
;;;120          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
;;;121          /* Release I2C1 from reset state */
;;;122          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
;;;123          break;
;;;124    
;;;125        case I2C2_BASE:
;;;126          /* Enable I2C2 reset state */
;;;127          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
00000e  2101              MOVS     r1,#1
000010  058c              LSLS     r4,r1,#22
000012  4620              MOV      r0,r4
000014  f7fff7ff          BL       RCC_APB1PeriphResetCmd
;;;128          /* Release I2C2 from reset state */
;;;129          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
000018  4620              MOV      r0,r4
00001a  e8bde8bd          POP      {r4,lr}
00001e  2100              MOVS     r1,#0
000020  f7fff7ff          B.W      RCC_APB1PeriphResetCmd
                  |L1.36|
000024  2101              MOVS     r1,#1                 ;120
000026  054c              LSLS     r4,r1,#21             ;120
000028  4620              MOV      r0,r4                 ;120
00002a  f7fff7ff          BL       RCC_APB1PeriphResetCmd
00002e  4620              MOV      r0,r4                 ;122
000030  e8bde8bd          POP      {r4,lr}               ;122
000034  2100              MOVS     r1,#0                 ;122
000036  f7fff7ff          B.W      RCC_APB1PeriphResetCmd
                  |L1.58|
;;;130          break;
;;;131    
;;;132        default:
;;;133          break;
;;;134      }
;;;135    }
00003a  bd10              POP      {r4,pc}
;;;136    
                          ENDP

                  I2C_Init PROC
;;;148    void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
;;;149    {
00003c  b570              PUSH     {r4-r6,lr}
00003e  b086              SUB      sp,sp,#0x18
000040  4604              MOV      r4,r0
000042  460d              MOV      r5,r1
;;;150      u16 tmpreg = 0, freqrange = 0;
;;;151      u16 result = 0x04;
;;;152      u32 pclk1 = 8000000;
;;;153      RCC_ClocksTypeDef  rcc_clocks;
;;;154    
;;;155      /* Check the parameters */
;;;156      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;157      assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
;;;158      assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
;;;159      assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
;;;160      assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
;;;161      assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
;;;162      assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
;;;163    
;;;164    /*---------------------------- I2Cx CR2 Configuration ------------------------*/
;;;165      /* Get the I2Cx CR2 value */
;;;166      tmpreg = I2Cx->CR2;
000044  88a0              LDRH     r0,[r4,#4]
;;;167      /* Clear frequency FREQ[5:0] bits */
;;;168      tmpreg &= CR2_FREQ_Reset;
000046  f020f020          BIC      r6,r0,#0x3f
;;;169      /* Get pclk1 frequency value */
;;;170      RCC_GetClocksFreq(&rcc_clocks);
00004a  a801              ADD      r0,sp,#4
00004c  f7fff7ff          BL       RCC_GetClocksFreq
;;;171      pclk1 = rcc_clocks.PCLK1_Frequency;
000050  9803              LDR      r0,[sp,#0xc]
;;;172      /* Set frequency bits depending on pclk1 value */
;;;173      freqrange = (u16)(pclk1 / 1000000);
000052  49c7              LDR      r1,|L1.880|
000054  fbb0fbb0          UDIV     r1,r0,r1
000058  b289              UXTH     r1,r1
;;;174      tmpreg |= freqrange;
00005a  430e              ORRS     r6,r6,r1
;;;175      /* Write to I2Cx CR2 */
;;;176      I2Cx->CR2 = tmpreg;
00005c  80a6              STRH     r6,[r4,#4]
;;;177    
;;;178    /*---------------------------- I2Cx CCR Configuration ------------------------*/
;;;179      /* Disable the selected I2C peripheral to configure TRISE */
;;;180      I2Cx->CR1 &= CR1_PE_Reset;
00005e  8822              LDRH     r2,[r4,#0]
000060  f022f022          BIC      r2,r2,#1
000064  8022              STRH     r2,[r4,#0]
;;;181    
;;;182      /* Reset tmpreg value */
;;;183      /* Clear F/S, DUTY and CCR[11:0] bits */
;;;184      tmpreg = 0;
;;;185    
;;;186      /* Configure speed in standard mode */
;;;187      if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
000066  4bc3              LDR      r3,|L1.884|
000068  68ea              LDR      r2,[r5,#0xc]
00006a  429a              CMP      r2,r3
00006c  d809              BHI      |L1.130|
;;;188      {
;;;189        /* Standard mode speed calculate */
;;;190        result = (u16)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
00006e  0052              LSLS     r2,r2,#1
000070  fbb0fbb0          UDIV     r0,r0,r2
000074  b280              UXTH     r0,r0
;;;191        /* Test if CCR value is under 0x4*/
;;;192        if (result < 0x04)
000076  2804              CMP      r0,#4
000078  d200              BCS      |L1.124|
;;;193        {
;;;194          /* Set minimum allowed value */
;;;195          result = 0x04;  
00007a  2004              MOVS     r0,#4
                  |L1.124|
;;;196        }
;;;197        /* Set speed value for standard mode */
;;;198        tmpreg |= result;	  
;;;199        /* Set Maximum Rise Time for standard mode */
;;;200        I2Cx->TRISE = freqrange + 1; 
00007c  1c49              ADDS     r1,r1,#1
00007e  8421              STRH     r1,[r4,#0x20]
000080  e020              B        |L1.196|
                  |L1.130|
;;;201      }
;;;202      /* Configure speed in fast mode */
;;;203      else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
;;;204      {
;;;205        if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
000082  886b              LDRH     r3,[r5,#2]
000084  f5a3f5a3          SUB      r6,r3,#0xbf00
000088  3eff              SUBS     r6,r6,#0xff
00008a  d105              BNE      |L1.152|
;;;206        {
;;;207          /* Fast mode speed calculate: Tlow/Thigh = 2 */
;;;208          result = (u16)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
00008c  eb02eb02          ADD      r2,r2,r2,LSL #1
000090  fbb0fbb0          UDIV     r0,r0,r2
000094  b280              UXTH     r0,r0
000096  e006              B        |L1.166|
                  |L1.152|
;;;209        }
;;;210        else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
;;;211        {
;;;212          /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
;;;213          result = (u16)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
000098  2319              MOVS     r3,#0x19
00009a  435a              MULS     r2,r3,r2
00009c  fbb0fbb0          UDIV     r0,r0,r2
0000a0  b280              UXTH     r0,r0
;;;214          /* Set DUTY bit */
;;;215          result |= I2C_DutyCycle_16_9;
0000a2  f440f440          ORR      r0,r0,#0x4000
                  |L1.166|
;;;216        }
;;;217        /* Test if CCR value is under 0x1*/
;;;218        if ((result & CCR_CCR_Set) == 0)
0000a6  0502              LSLS     r2,r0,#20
0000a8  d101              BNE      |L1.174|
;;;219        {
;;;220          /* Set minimum allowed value */
;;;221          result |= (u16)0x0001;  
0000aa  f040f040          ORR      r0,r0,#1
                  |L1.174|
;;;222        }
;;;223        /* Set speed value and set F/S bit for fast mode */
;;;224        tmpreg |= result | CCR_FS_Set;
0000ae  f440f440          ORR      r0,r0,#0x8000
;;;225        /* Set Maximum Rise Time for fast mode */
;;;226        I2Cx->TRISE = (u16)(((freqrange * 300) / 1000) + 1);  
0000b2  f44ff44f          MOV      r2,#0x12c
0000b6  4351              MULS     r1,r2,r1
0000b8  f44ff44f          MOV      r2,#0x3e8
0000bc  fbb1fbb1          UDIV     r1,r1,r2
0000c0  1c49              ADDS     r1,r1,#1
0000c2  8421              STRH     r1,[r4,#0x20]
                  |L1.196|
;;;227      }
;;;228      /* Write to I2Cx CCR */
;;;229      I2Cx->CCR = tmpreg;
0000c4  83a0              STRH     r0,[r4,#0x1c]
;;;230    
;;;231      /* Enable the selected I2C peripheral */
;;;232      I2Cx->CR1 |= CR1_PE_Set;
0000c6  8820              LDRH     r0,[r4,#0]
0000c8  f040f040          ORR      r0,r0,#1
0000cc  8020              STRH     r0,[r4,#0]
;;;233    
;;;234    /*---------------------------- I2Cx CR1 Configuration ------------------------*/
;;;235      /* Get the I2Cx CR1 value */
;;;236      tmpreg = I2Cx->CR1;
0000ce  8820              LDRH     r0,[r4,#0]
;;;237      /* Clear ACK, SMBTYPE and  SMBUS bits */
;;;238      tmpreg &= CR1_CLEAR_Mask;
0000d0  f64ff64f          MOV      r1,#0xfbf5
0000d4  4008              ANDS     r0,r0,r1
;;;239      /* Configure I2Cx: mode and acknowledgement */
;;;240      /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
;;;241      /* Set ACK bit according to I2C_Ack value */
;;;242      tmpreg |= (u16)((u32)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
0000d6  8829              LDRH     r1,[r5,#0]
0000d8  88ea              LDRH     r2,[r5,#6]
0000da  4311              ORRS     r1,r1,r2
0000dc  4301              ORRS     r1,r1,r0
;;;243      /* Write to I2Cx CR1 */
;;;244      I2Cx->CR1 = tmpreg;
0000de  8021              STRH     r1,[r4,#0]
;;;245    
;;;246    /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
;;;247      /* Set I2Cx Own Address1 and acknowledged address */
;;;248      I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
0000e0  8928              LDRH     r0,[r5,#8]
0000e2  88a9              LDRH     r1,[r5,#4]
0000e4  4308              ORRS     r0,r0,r1
0000e6  8120              STRH     r0,[r4,#8]
;;;249    }
0000e8  b006              ADD      sp,sp,#0x18
0000ea  bd70              POP      {r4-r6,pc}
;;;250    
                          ENDP

                  I2C_StructInit PROC
;;;262      /* Initialize the I2C_Mode member */
;;;263      I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
0000ec  2100              MOVS     r1,#0
0000ee  8001              STRH     r1,[r0,#0]
;;;264    
;;;265      /* Initialize the I2C_DutyCycle member */
;;;266      I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
0000f0  f64bf64b          MOV      r2,#0xbfff
0000f4  8042              STRH     r2,[r0,#2]
;;;267    
;;;268      /* Initialize the I2C_OwnAddress1 member */
;;;269      I2C_InitStruct->I2C_OwnAddress1 = 0;
0000f6  8081              STRH     r1,[r0,#4]
;;;270    
;;;271      /* Initialize the I2C_Ack member */
;;;272      I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
0000f8  80c1              STRH     r1,[r0,#6]
;;;273    
;;;274      /* Initialize the I2C_AcknowledgedAddress member */
;;;275      I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
0000fa  f44ff44f          MOV      r1,#0x4000
0000fe  8101              STRH     r1,[r0,#8]
;;;276    
;;;277      /* initialize the I2C_ClockSpeed member */
;;;278      I2C_InitStruct->I2C_ClockSpeed = 5000;
000100  f241f241          MOV      r1,#0x1388
000104  60c1              STR      r1,[r0,#0xc]
;;;279    }
000106  4770              BX       lr
;;;280    
                          ENDP

                  I2C_Cmd PROC
;;;295    
;;;296      if (NewState != DISABLE)
000108  b121              CBZ      r1,|L1.276|
;;;297      {
;;;298        /* Enable the selected I2C peripheral */
;;;299        I2Cx->CR1 |= CR1_PE_Set;
00010a  8801              LDRH     r1,[r0,#0]
00010c  f041f041          ORR      r1,r1,#1
000110  8001              STRH     r1,[r0,#0]
;;;300      }
;;;301      else
;;;302      {
;;;303        /* Disable the selected I2C peripheral */
;;;304        I2Cx->CR1 &= CR1_PE_Reset;
;;;305      }
;;;306    }
000112  4770              BX       lr
                  |L1.276|
000114  8801              LDRH     r1,[r0,#0]            ;304
000116  f021f021          BIC      r1,r1,#1              ;304
00011a  8001              STRH     r1,[r0,#0]            ;304
00011c  4770              BX       lr
;;;307    
                          ENDP

                  I2C_DMACmd PROC
;;;322    
;;;323      if (NewState != DISABLE)
00011e  b121              CBZ      r1,|L1.298|
;;;324      {
;;;325        /* Enable the selected I2C DMA requests */
;;;326        I2Cx->CR2 |= CR2_DMAEN_Set;
000120  8881              LDRH     r1,[r0,#4]
000122  f441f441          ORR      r1,r1,#0x800
000126  8081              STRH     r1,[r0,#4]
;;;327      }
;;;328      else
;;;329      {
;;;330        /* Disable the selected I2C DMA requests */
;;;331        I2Cx->CR2 &= CR2_DMAEN_Reset;
;;;332      }
;;;333    }
000128  4770              BX       lr
                  |L1.298|
00012a  8881              LDRH     r1,[r0,#4]            ;331
00012c  f421f421          BIC      r1,r1,#0x800          ;331
000130  8081              STRH     r1,[r0,#4]            ;331
000132  4770              BX       lr
;;;334    
                          ENDP

                  I2C_DMALastTransferCmd PROC
;;;349    
;;;350      if (NewState != DISABLE)
000134  b121              CBZ      r1,|L1.320|
;;;351      {
;;;352        /* Next DMA transfer is the last transfer */
;;;353        I2Cx->CR2 |= CR2_LAST_Set;
000136  8881              LDRH     r1,[r0,#4]
000138  f441f441          ORR      r1,r1,#0x1000
00013c  8081              STRH     r1,[r0,#4]
;;;354      }
;;;355      else
;;;356      {
;;;357        /* Next DMA transfer is not the last transfer */
;;;358        I2Cx->CR2 &= CR2_LAST_Reset;
;;;359      }
;;;360    }
00013e  4770              BX       lr
                  |L1.320|
000140  8881              LDRH     r1,[r0,#4]            ;358
000142  f421f421          BIC      r1,r1,#0x1000         ;358
000146  8081              STRH     r1,[r0,#4]            ;358
000148  4770              BX       lr
;;;361    
                          ENDP

                  I2C_GenerateSTART PROC
;;;376    
;;;377      if (NewState != DISABLE)
00014a  b121              CBZ      r1,|L1.342|
;;;378      {
;;;379        /* Generate a START condition */
;;;380        I2Cx->CR1 |= CR1_START_Set;
00014c  8801              LDRH     r1,[r0,#0]
00014e  f441f441          ORR      r1,r1,#0x100
000152  8001              STRH     r1,[r0,#0]
;;;381      }
;;;382      else
;;;383      {
;;;384        /* Disable the START condition generation */
;;;385        I2Cx->CR1 &= CR1_START_Reset;
;;;386      }
;;;387    }
000154  4770              BX       lr
                  |L1.342|
000156  8801              LDRH     r1,[r0,#0]            ;385
000158  f421f421          BIC      r1,r1,#0x100          ;385
00015c  8001              STRH     r1,[r0,#0]            ;385
00015e  4770              BX       lr
;;;388    
                          ENDP

                  I2C_GenerateSTOP PROC
;;;403    
;;;404      if (NewState != DISABLE)
000160  b121              CBZ      r1,|L1.364|
;;;405      {
;;;406        /* Generate a STOP condition */
;;;407        I2Cx->CR1 |= CR1_STOP_Set;
000162  8801              LDRH     r1,[r0,#0]
000164  f441f441          ORR      r1,r1,#0x200
000168  8001              STRH     r1,[r0,#0]
;;;408      }
;;;409      else
;;;410      {
;;;411        /* Disable the STOP condition generation */
;;;412        I2Cx->CR1 &= CR1_STOP_Reset;
;;;413      }
;;;414    }
00016a  4770              BX       lr
                  |L1.364|
00016c  8801              LDRH     r1,[r0,#0]            ;412
00016e  f421f421          BIC      r1,r1,#0x200          ;412
000172  8001              STRH     r1,[r0,#0]            ;412
000174  4770              BX       lr
;;;415    
                          ENDP

                  I2C_AcknowledgeConfig PROC
;;;430    
;;;431      if (NewState != DISABLE)
000176  b121              CBZ      r1,|L1.386|
;;;432      {
;;;433        /* Enable the acknowledgement */
;;;434        I2Cx->CR1 |= CR1_ACK_Set;
000178  8801              LDRH     r1,[r0,#0]
00017a  f441f441          ORR      r1,r1,#0x400
00017e  8001              STRH     r1,[r0,#0]
;;;435      }
;;;436      else
;;;437      {
;;;438        /* Disable the acknowledgement */
;;;439        I2Cx->CR1 &= CR1_ACK_Reset;
;;;440      }
;;;441    }
000180  4770              BX       lr
                  |L1.386|
000182  8801              LDRH     r1,[r0,#0]            ;439
000184  f421f421          BIC      r1,r1,#0x400          ;439
000188  8001              STRH     r1,[r0,#0]            ;439
00018a  4770              BX       lr
;;;442    
                          ENDP

                  I2C_OwnAddress2Config PROC
;;;458      /* Get the old register value */
;;;459      tmpreg = I2Cx->OAR2;
00018c  8982              LDRH     r2,[r0,#0xc]
;;;460      /* Reset I2Cx Own address2 bit [7:1] */
;;;461      tmpreg &= OAR2_ADD2_Reset;
00018e  f022f022          BIC      r2,r2,#0xfe
;;;462      /* Set I2Cx Own address2 */
;;;463      tmpreg |= (u16)(Address & (u16)0x00FE);
000192  f001f001          AND      r1,r1,#0xfe
000196  4311              ORRS     r1,r1,r2
;;;464      /* Store the new register value */
;;;465      I2Cx->OAR2 = tmpreg;
000198  8181              STRH     r1,[r0,#0xc]
;;;466    }
00019a  4770              BX       lr
;;;467    
                          ENDP

                  I2C_DualAddressCmd PROC
;;;482    
;;;483      if (NewState != DISABLE)
00019c  b121              CBZ      r1,|L1.424|
;;;484      {
;;;485        /* Enable dual addressing mode */
;;;486        I2Cx->OAR2 |= OAR2_ENDUAL_Set;
00019e  8981              LDRH     r1,[r0,#0xc]
0001a0  f041f041          ORR      r1,r1,#1
0001a4  8181              STRH     r1,[r0,#0xc]
;;;487      }
;;;488      else
;;;489      {
;;;490        /* Disable dual addressing mode */
;;;491        I2Cx->OAR2 &= OAR2_ENDUAL_Reset;
;;;492      }
;;;493    }
0001a6  4770              BX       lr
                  |L1.424|
0001a8  8981              LDRH     r1,[r0,#0xc]          ;491
0001aa  f021f021          BIC      r1,r1,#1              ;491
0001ae  8181              STRH     r1,[r0,#0xc]          ;491
0001b0  4770              BX       lr
;;;494    
                          ENDP

                  I2C_GeneralCallCmd PROC
;;;509    
;;;510      if (NewState != DISABLE)
0001b2  b121              CBZ      r1,|L1.446|
;;;511      {
;;;512        /* Enable generall call */
;;;513        I2Cx->CR1 |= CR1_ENGC_Set;
0001b4  8801              LDRH     r1,[r0,#0]
0001b6  f041f041          ORR      r1,r1,#0x40
0001ba  8001              STRH     r1,[r0,#0]
;;;514      }
;;;515      else
;;;516      {
;;;517        /* Disable generall call */
;;;518        I2Cx->CR1 &= CR1_ENGC_Reset;
;;;519      }
;;;520    }
0001bc  4770              BX       lr
                  |L1.446|
0001be  8801              LDRH     r1,[r0,#0]            ;518
0001c0  f021f021          BIC      r1,r1,#0x40           ;518
0001c4  8001              STRH     r1,[r0,#0]            ;518
0001c6  4770              BX       lr
;;;521    
                          ENDP

                  I2C_ITConfig PROC
;;;543      
;;;544      if (NewState != DISABLE)
0001c8  b11a              CBZ      r2,|L1.466|
;;;545      {
;;;546        /* Enable the selected I2C interrupts */
;;;547        I2Cx->CR2 |= I2C_IT;
0001ca  8882              LDRH     r2,[r0,#4]
0001cc  430a              ORRS     r2,r2,r1
0001ce  8082              STRH     r2,[r0,#4]
;;;548      }
;;;549      else
;;;550      {
;;;551        /* Disable the selected I2C interrupts */
;;;552        I2Cx->CR2 &= (u16)~I2C_IT;
;;;553      }
;;;554    }
0001d0  4770              BX       lr
                  |L1.466|
0001d2  8882              LDRH     r2,[r0,#4]            ;552
0001d4  438a              BICS     r2,r2,r1              ;552
0001d6  8082              STRH     r2,[r0,#4]            ;552
0001d8  4770              BX       lr
;;;555    
                          ENDP

                  I2C_SendData PROC
;;;569      /* Write in the DR register the data to be sent */
;;;570      I2Cx->DR = Data;
0001da  8201              STRH     r1,[r0,#0x10]
;;;571    }
0001dc  4770              BX       lr
;;;572    
                          ENDP

                  I2C_ReceiveData PROC
;;;585      /* Return the data in the DR register */
;;;586      return (u8)I2Cx->DR;
0001de  8a00              LDRH     r0,[r0,#0x10]
0001e0  b2c0              UXTB     r0,r0
;;;587    }
0001e2  4770              BX       lr
;;;588    
                          ENDP

                  I2C_Send7bitAddress PROC
;;;608      /* Test on the direction to set/reset the read/write bit */
;;;609      if (I2C_Direction != I2C_Direction_Transmitter)
0001e4  b112              CBZ      r2,|L1.492|
;;;610      {
;;;611        /* Set the address bit0 for read */
;;;612        Address |= OAR1_ADD0_Set;
0001e6  f041f041          ORR      r1,r1,#1
0001ea  e001              B        |L1.496|
                  |L1.492|
;;;613      }
;;;614      else
;;;615      {
;;;616        /* Reset the address bit0 for write */
;;;617        Address &= OAR1_ADD0_Reset;
0001ec  f001f001          AND      r1,r1,#0xfe
                  |L1.496|
;;;618      }
;;;619      /* Send the address */
;;;620      I2Cx->DR = Address;
0001f0  8201              STRH     r1,[r0,#0x10]
;;;621    }
0001f2  4770              BX       lr
;;;622    
                          ENDP

                  I2C_ReadRegister PROC
;;;646      /* Return the selected register value */
;;;647      return (*(vu16 *)(*((vu32 *)&I2Cx) + I2C_Register));
0001f4  5a40              LDRH     r0,[r0,r1]
;;;648    }
0001f6  4770              BX       lr
;;;649    
                          ENDP

                  I2C_SoftwareResetCmd PROC
;;;664    
;;;665      if (NewState != DISABLE)
0001f8  b121              CBZ      r1,|L1.516|
;;;666      {
;;;667        /* Peripheral under reset */
;;;668        I2Cx->CR1 |= CR1_SWRST_Set;
0001fa  8801              LDRH     r1,[r0,#0]
0001fc  f441f441          ORR      r1,r1,#0x8000
000200  8001              STRH     r1,[r0,#0]
;;;669      }
;;;670      else
;;;671      {
;;;672        /* Peripheral not under reset */
;;;673        I2Cx->CR1 &= CR1_SWRST_Reset;
;;;674      }
;;;675    }
000202  4770              BX       lr
                  |L1.516|
000204  8801              LDRH     r1,[r0,#0]            ;673
000206  f3c1f3c1          UBFX     r1,r1,#0,#15          ;673
00020a  8001              STRH     r1,[r0,#0]            ;673
00020c  4770              BX       lr
;;;676    
                          ENDP

                  I2C_SMBusAlertConfig PROC
;;;693    
;;;694      if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
00020e  f5b1f5b1          CMP      r1,#0x2000
000212  d104              BNE      |L1.542|
;;;695      {
;;;696        /* Drive the SMBusAlert pin Low */
;;;697        I2Cx->CR1 |= I2C_SMBusAlert_Low;
000214  8801              LDRH     r1,[r0,#0]
000216  f441f441          ORR      r1,r1,#0x2000
00021a  8001              STRH     r1,[r0,#0]
;;;698      }
;;;699      else
;;;700      {
;;;701        /* Drive the SMBusAlert pin High  */
;;;702        I2Cx->CR1 &= I2C_SMBusAlert_High;
;;;703      }
;;;704    }
00021c  4770              BX       lr
                  |L1.542|
00021e  8801              LDRH     r1,[r0,#0]            ;702
000220  f421f421          BIC      r1,r1,#0x2000         ;702
000224  8001              STRH     r1,[r0,#0]            ;702
000226  4770              BX       lr
;;;705    
                          ENDP

                  I2C_TransmitPEC PROC
;;;720    
;;;721      if (NewState != DISABLE)
000228  b121              CBZ      r1,|L1.564|
;;;722      {
;;;723        /* Enable the selected I2C PEC transmission */
;;;724        I2Cx->CR1 |= CR1_PEC_Set;
00022a  8801              LDRH     r1,[r0,#0]
00022c  f441f441          ORR      r1,r1,#0x1000
000230  8001              STRH     r1,[r0,#0]
;;;725      }
;;;726      else
;;;727      {
;;;728        /* Disable the selected I2C PEC transmission */
;;;729        I2Cx->CR1 &= CR1_PEC_Reset;
;;;730      }
;;;731    }
000232  4770              BX       lr
                  |L1.564|
000234  8801              LDRH     r1,[r0,#0]            ;729
000236  f421f421          BIC      r1,r1,#0x1000         ;729
00023a  8001              STRH     r1,[r0,#0]            ;729
00023c  4770              BX       lr
;;;732    
                          ENDP

                  I2C_PECPositionConfig PROC
;;;751    
;;;752      if (I2C_PECPosition == I2C_PECPosition_Next)
00023e  f5b1f5b1          CMP      r1,#0x800
000242  d104              BNE      |L1.590|
;;;753      {
;;;754        /* Next byte in shift register is PEC */
;;;755        I2Cx->CR1 |= I2C_PECPosition_Next;
000244  8801              LDRH     r1,[r0,#0]
000246  f441f441          ORR      r1,r1,#0x800
00024a  8001              STRH     r1,[r0,#0]
;;;756      }
;;;757      else
;;;758      {
;;;759        /* Current byte in shift register is PEC */
;;;760        I2Cx->CR1 &= I2C_PECPosition_Current;
;;;761      }
;;;762    }
00024c  4770              BX       lr
                  |L1.590|
00024e  8801              LDRH     r1,[r0,#0]            ;760
000250  f421f421          BIC      r1,r1,#0x800          ;760
000254  8001              STRH     r1,[r0,#0]            ;760
000256  4770              BX       lr
;;;763    
                          ENDP

                  I2C_CalculatePEC PROC
;;;779    
;;;780      if (NewState != DISABLE)
000258  b121              CBZ      r1,|L1.612|
;;;781      {
;;;782        /* Enable the selected I2C PEC calculation */
;;;783        I2Cx->CR1 |= CR1_ENPEC_Set;
00025a  8801              LDRH     r1,[r0,#0]
00025c  f041f041          ORR      r1,r1,#0x20
000260  8001              STRH     r1,[r0,#0]
;;;784      }
;;;785      else
;;;786      {
;;;787        /* Disable the selected I2C PEC calculation */
;;;788        I2Cx->CR1 &= CR1_ENPEC_Reset;
;;;789      }
;;;790    }
000262  4770              BX       lr
                  |L1.612|
000264  8801              LDRH     r1,[r0,#0]            ;788
000266  f021f021          BIC      r1,r1,#0x20           ;788
00026a  8001              STRH     r1,[r0,#0]            ;788
00026c  4770              BX       lr
;;;791    
                          ENDP

                  I2C_GetPEC PROC
;;;804      /* Return the selected I2C PEC value */
;;;805      return ((I2Cx->SR2) >> 8);
00026e  8b00              LDRH     r0,[r0,#0x18]
000270  0a00              LSRS     r0,r0,#8
;;;806    }
000272  4770              BX       lr
;;;807    
                          ENDP

                  I2C_ARPCmd PROC
;;;822    
;;;823      if (NewState != DISABLE)
000274  b121              CBZ      r1,|L1.640|
;;;824      {
;;;825        /* Enable the selected I2C ARP */
;;;826        I2Cx->CR1 |= CR1_ENARP_Set;
000276  8801              LDRH     r1,[r0,#0]
000278  f041f041          ORR      r1,r1,#0x10
00027c  8001              STRH     r1,[r0,#0]
;;;827      }
;;;828      else
;;;829      {
;;;830        /* Disable the selected I2C ARP */
;;;831        I2Cx->CR1 &= CR1_ENARP_Reset;
;;;832      }
;;;833    }
00027e  4770              BX       lr
                  |L1.640|
000280  8801              LDRH     r1,[r0,#0]            ;831
000282  f021f021          BIC      r1,r1,#0x10           ;831
000286  8001              STRH     r1,[r0,#0]            ;831
000288  4770              BX       lr
;;;834    
                          ENDP

                  I2C_StretchClockCmd PROC
;;;849    
;;;850      if (NewState == DISABLE)
00028a  b921              CBNZ     r1,|L1.662|
;;;851      {
;;;852        /* Enable the selected I2C Clock stretching */
;;;853        I2Cx->CR1 |= CR1_NOSTRETCH_Set;
00028c  8801              LDRH     r1,[r0,#0]
00028e  f041f041          ORR      r1,r1,#0x80
000292  8001              STRH     r1,[r0,#0]
;;;854      }
;;;855      else
;;;856      {
;;;857        /* Disable the selected I2C Clock stretching */
;;;858        I2Cx->CR1 &= CR1_NOSTRETCH_Reset;
;;;859      }
;;;860    }
000294  4770              BX       lr
                  |L1.662|
000296  8801              LDRH     r1,[r0,#0]            ;858
000298  f021f021          BIC      r1,r1,#0x80           ;858
00029c  8001              STRH     r1,[r0,#0]            ;858
00029e  4770              BX       lr
;;;861    
                          ENDP

                  I2C_FastModeDutyCycleConfig PROC
;;;878    
;;;879      if (I2C_DutyCycle != I2C_DutyCycle_16_9)
0002a0  f5b1f5b1          CMP      r1,#0x4000
0002a4  d004              BEQ      |L1.688|
;;;880      {
;;;881        /* I2C fast mode Tlow/Thigh=2 */
;;;882        I2Cx->CCR &= I2C_DutyCycle_2;
0002a6  8b81              LDRH     r1,[r0,#0x1c]
0002a8  f421f421          BIC      r1,r1,#0x4000
0002ac  8381              STRH     r1,[r0,#0x1c]
;;;883      }
;;;884      else
;;;885      {
;;;886        /* I2C fast mode Tlow/Thigh=16/9 */
;;;887        I2Cx->CCR |= I2C_DutyCycle_16_9;
;;;888      }
;;;889    }
0002ae  4770              BX       lr
                  |L1.688|
0002b0  8b81              LDRH     r1,[r0,#0x1c]         ;887
0002b2  f441f441          ORR      r1,r1,#0x4000         ;887
0002b6  8381              STRH     r1,[r0,#0x1c]         ;887
0002b8  4770              BX       lr
;;;890    
                          ENDP

                  I2C_GetLastEvent PROC
;;;906      /* Read the I2Cx status register */
;;;907      flag1 = I2Cx->SR1;
0002ba  8a81              LDRH     r1,[r0,#0x14]
;;;908      flag2 = I2Cx->SR2;
0002bc  8b00              LDRH     r0,[r0,#0x18]
;;;909      flag2 = flag2 << 16;
0002be  0400              LSLS     r0,r0,#16
;;;910    
;;;911      /* Get the last event value from I2C status register */
;;;912      lastevent = (flag1 | flag2) & FLAG_Mask;
0002c0  4301              ORRS     r1,r1,r0
0002c2  f021f021          BIC      r0,r1,#0xff000000
;;;913    
;;;914      /* Return status */
;;;915      return lastevent;
;;;916    }
0002c6  4770              BX       lr
;;;917    
                          ENDP

                  I2C_CheckEvent PROC
;;;940    ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, u32 I2C_EVENT)
;;;941    {
0002c8  4602              MOV      r2,r0
;;;942      u32 lastevent = 0;
;;;943      u32 flag1 = 0, flag2 = 0;
;;;944      ErrorStatus status = ERROR;
0002ca  2000              MOVS     r0,#0
;;;945    
;;;946      /* Check the parameters */
;;;947      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;948      assert_param(IS_I2C_EVENT(I2C_EVENT));
;;;949    
;;;950      /* Read the I2Cx status register */
;;;951      flag1 = I2Cx->SR1;
0002cc  8a93              LDRH     r3,[r2,#0x14]
;;;952      flag2 = I2Cx->SR2;
0002ce  8b12              LDRH     r2,[r2,#0x18]
;;;953      flag2 = flag2 << 16;
0002d0  0412              LSLS     r2,r2,#16
;;;954    
;;;955      /* Get the last event value from I2C status register */
;;;956      lastevent = (flag1 | flag2) & FLAG_Mask;
0002d2  4313              ORRS     r3,r3,r2
0002d4  f023f023          BIC      r2,r3,#0xff000000
;;;957    
;;;958      /* Check whether the last event is equal to I2C_EVENT */
;;;959      if (lastevent == I2C_EVENT )
0002d8  428a              CMP      r2,r1
0002da  d100              BNE      |L1.734|
;;;960      {
;;;961        /* SUCCESS: last event is equal to I2C_EVENT */
;;;962        status = SUCCESS;
0002dc  2001              MOVS     r0,#1
                  |L1.734|
;;;963      }
;;;964      else
;;;965      {
;;;966        /* ERROR: last event is different from I2C_EVENT */
;;;967        status = ERROR;
;;;968      }
;;;969    
;;;970      /* Return status */
;;;971      return status;
;;;972    }
0002de  4770              BX       lr
;;;973    
                          ENDP

                  I2C_GetFlagStatus PROC
;;;1005   FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, u32 I2C_FLAG)
;;;1006   {
0002e0  4602              MOV      r2,r0
;;;1007     FlagStatus bitstatus = RESET;
0002e2  2000              MOVS     r0,#0
;;;1008     u32 i2cstatus = 0;
;;;1009     u32 flag1 = 0, flag2 = 0;
;;;1010   
;;;1011     /* Check the parameters */
;;;1012     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1013     assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
;;;1014   
;;;1015     /* Read the I2Cx status register */
;;;1016     flag1 = I2Cx->SR1;
0002e4  8a93              LDRH     r3,[r2,#0x14]
;;;1017     flag2 = I2Cx->SR2;
0002e6  8b12              LDRH     r2,[r2,#0x18]
;;;1018     flag2 = (flag2 & FLAG_Mask) << 16;
0002e8  0412              LSLS     r2,r2,#16
;;;1019   
;;;1020     /* Get the I2C status value */
;;;1021     i2cstatus = flag1 | flag2;
0002ea  4313              ORRS     r3,r3,r2
;;;1022   
;;;1023     /* Get bit[23:0] of the flag */
;;;1024     I2C_FLAG &= FLAG_Mask;
0002ec  f021f021          BIC      r1,r1,#0xff000000
;;;1025   
;;;1026     /* Check the status of the specified I2C flag */
;;;1027     if ((i2cstatus & I2C_FLAG) != (u32)RESET)
0002f0  420b              TST      r3,r1
0002f2  d000              BEQ      |L1.758|
;;;1028     {
;;;1029       /* I2C_FLAG is set */
;;;1030       bitstatus = SET;
0002f4  2001              MOVS     r0,#1
                  |L1.758|
;;;1031     }
;;;1032     else
;;;1033     {
;;;1034       /* I2C_FLAG is reset */
;;;1035       bitstatus = RESET;
;;;1036     }
;;;1037     /* Return the I2C_FLAG status */
;;;1038     return  bitstatus;
;;;1039   }
0002f6  4770              BX       lr
;;;1040   
                          ENDP

                  I2C_ClearFlag PROC
;;;1072     /* Get the I2C flag position */
;;;1073     flagpos = I2C_FLAG & FLAG_Mask;
0002f8  f021f021          BIC      r2,r1,#0xff000000
;;;1074   
;;;1075     /* Get the I2C flag index */
;;;1076     flagindex = I2C_FLAG >> 28;
0002fc  0f09              LSRS     r1,r1,#28
;;;1077   
;;;1078     /* Clear the flag by writing 0 */
;;;1079     if (flagindex == 1)
0002fe  2901              CMP      r1,#1
000300  d102              BNE      |L1.776|
;;;1080     {
;;;1081       /* Clear the selected I2C flag */
;;;1082       I2Cx->SR1 = (u16)~flagpos;
000302  43d1              MVNS     r1,r2
000304  8281              STRH     r1,[r0,#0x14]
;;;1083     }
;;;1084     /* Flags that need a read of the SR1 register to be cleared */
;;;1085     else if (flagindex == 2)
;;;1086     {
;;;1087       /* Read the SR1 register */
;;;1088       (void)I2Cx->SR1;
;;;1089     }
;;;1090     /* Flags that need a read of SR1 and a write on CR1 registers to be cleared */
;;;1091     else if (flagindex == 6)
;;;1092     {
;;;1093       /* Read the SR1 register */
;;;1094       (void)I2Cx->SR1;
;;;1095   
;;;1096       /* Write on the CR1 register */
;;;1097       I2Cx->CR1 |= CR1_PE_Set;
;;;1098     }
;;;1099     /* Flags that need a read of SR1 and SR2 registers to be cleared */
;;;1100     else /*flagindex == 0xA*/
;;;1101     {
;;;1102       /* Read the SR1 register */
;;;1103       (void)I2Cx->SR1;
;;;1104   
;;;1105       /* Read the SR2 register */
;;;1106       (void)I2Cx->SR2;
;;;1107     }
;;;1108   }
000306  4770              BX       lr
                  |L1.776|
000308  2902              CMP      r1,#2                 ;1085
00030a  d101              BNE      |L1.784|
00030c  8a80              LDRH     r0,[r0,#0x14]         ;1088
00030e  4770              BX       lr
                  |L1.784|
000310  2906              CMP      r1,#6                 ;1091
000312  d105              BNE      |L1.800|
000314  8a81              LDRH     r1,[r0,#0x14]         ;1094
000316  8801              LDRH     r1,[r0,#0]            ;1097
000318  f041f041          ORR      r1,r1,#1              ;1097
00031c  8001              STRH     r1,[r0,#0]            ;1097
00031e  4770              BX       lr
                  |L1.800|
000320  8a81              LDRH     r1,[r0,#0x14]         ;1103
000322  8b00              LDRH     r0,[r0,#0x18]         ;1106
000324  4770              BX       lr
;;;1109   
                          ENDP

                  I2C_GetITStatus PROC
;;;1134   ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, u32 I2C_IT)
;;;1135   {
000326  4602              MOV      r2,r0
;;;1136     ITStatus bitstatus = RESET;
000328  2000              MOVS     r0,#0
;;;1137     u32 i2cstatus = 0;
;;;1138     u32 flag1 = 0, flag2 = 0;
;;;1139   
;;;1140     /* Check the parameters */
;;;1141     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1142     assert_param(IS_I2C_GET_IT(I2C_IT));
;;;1143   
;;;1144     /* Read the I2Cx status register */
;;;1145     flag1 = I2Cx->SR1;
00032a  8a93              LDRH     r3,[r2,#0x14]
;;;1146     flag2 = I2Cx->SR2;
00032c  8b12              LDRH     r2,[r2,#0x18]
;;;1147     flag2 = (flag2 & FLAG_Mask) << 16;
00032e  0412              LSLS     r2,r2,#16
;;;1148   
;;;1149     /* Get the I2C status value */
;;;1150     i2cstatus = flag1 | flag2;
000330  4313              ORRS     r3,r3,r2
;;;1151   
;;;1152     /* Get bit[23:0] of the flag */
;;;1153     I2C_IT &= FLAG_Mask;
000332  f021f021          BIC      r1,r1,#0xff000000
;;;1154   
;;;1155     /* Check the status of the specified I2C flag */
;;;1156     if ((i2cstatus & I2C_IT) != (u32)RESET)
000336  420b              TST      r3,r1
000338  d000              BEQ      |L1.828|
;;;1157     {
;;;1158       /* I2C_IT is set */
;;;1159       bitstatus = SET;
00033a  2001              MOVS     r0,#1
                  |L1.828|
;;;1160     }
;;;1161     else
;;;1162     {
;;;1163       /* I2C_IT is reset */
;;;1164       bitstatus = RESET;
;;;1165     }
;;;1166     /* Return the I2C_IT status */
;;;1167     return  bitstatus;
;;;1168   }
00033c  4770              BX       lr
;;;1169   
                          ENDP

                  I2C_ClearITPendingBit PROC
;;;1201     /* Get the I2C flag position */
;;;1202     flagpos = I2C_IT & FLAG_Mask;
00033e  f021f021          BIC      r2,r1,#0xff000000
;;;1203   
;;;1204     /* Get the I2C flag index */
;;;1205     flagindex = I2C_IT >> 28;
000342  0f09              LSRS     r1,r1,#28
;;;1206   
;;;1207     /* Clear the flag by writing 0 */
;;;1208     if (flagindex == 1)
000344  2901              CMP      r1,#1
000346  d102              BNE      |L1.846|
;;;1209     {
;;;1210       /* Clear the selected I2C flag */
;;;1211       I2Cx->SR1 = (u16)~flagpos;
000348  43d1              MVNS     r1,r2
00034a  8281              STRH     r1,[r0,#0x14]
;;;1212     }
;;;1213     /* Flags that need a read of the SR1 register to be cleared */
;;;1214     else if (flagindex == 2)
;;;1215     {
;;;1216       /* Read the SR1 register */
;;;1217       (void)I2Cx->SR1;
;;;1218     }
;;;1219     /* Flags that need a read of SR1 and a write on CR1 registers to be cleared */
;;;1220     else if (flagindex == 6)
;;;1221     {
;;;1222       /* Read the SR1 register */
;;;1223       (void)I2Cx->SR1;
;;;1224   
;;;1225       /* Write on the CR1 register */
;;;1226       I2Cx->CR1 |= CR1_PE_Set;
;;;1227     }
;;;1228     /* Flags that need a read of SR1 and SR2 registers to be cleared */
;;;1229     else /*flagindex == 0xA*/
;;;1230     {
;;;1231       /* Read the SR1 register */
;;;1232       (void)I2Cx->SR1;
;;;1233   
;;;1234       /* Read the SR2 register */
;;;1235       (void)I2Cx->SR2;
;;;1236     }
;;;1237   }
00034c  4770              BX       lr
                  |L1.846|
00034e  2902              CMP      r1,#2                 ;1214
000350  d101              BNE      |L1.854|
000352  8a80              LDRH     r0,[r0,#0x14]         ;1217
000354  4770              BX       lr
                  |L1.854|
000356  2906              CMP      r1,#6                 ;1220
000358  d105              BNE      |L1.870|
00035a  8a81              LDRH     r1,[r0,#0x14]         ;1223
00035c  8801              LDRH     r1,[r0,#0]            ;1226
00035e  f041f041          ORR      r1,r1,#1              ;1226
000362  8001              STRH     r1,[r0,#0]            ;1226
000364  4770              BX       lr
                  |L1.870|
000366  8a81              LDRH     r1,[r0,#0x14]         ;1232
000368  8b00              LDRH     r0,[r0,#0x18]         ;1235
00036a  4770              BX       lr
;;;1238   
                          ENDP

                  |L1.876|
00036c  bfffac00          DCD      0xbfffac00
                  |L1.880|
000370  000f4240          DCD      0x000f4240
                  |L1.884|
000374  000186a0          DCD      0x000186a0
