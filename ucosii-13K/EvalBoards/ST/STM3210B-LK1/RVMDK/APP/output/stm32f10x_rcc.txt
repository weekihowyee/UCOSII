; generated by ARM/Thumb C/C++ Compiler with , RVCT3.1 [Build 919] for uVision
; commandline ArmCC [--debug -c --asm --interleave -o.\output\stm32f10x_rcc.o --depend=.\output\stm32f10x_rcc.d --device=DARMSTM --apcs=interwork -O1 -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -IC:\Keil\ARM\INC\ST\STM32F10x --omf_browse=.\output\stm32f10x_rcc.crf ..\..\..\..\..\CPU\ST\STM32\src\stm32f10x_rcc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;129      /* Set HSION bit */
;;;130      RCC->CR |= (u32)0x00000001;
000000  48af              LDR      r0,|L1.704|
000002  6801              LDR      r1,[r0,#0]
000004  f041f041          ORR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;131    
;;;132      /* Reset SW[1:0], HPRE[3:0], PPRE1[2:0], PPRE2[2:0], ADCPRE[1:0] and MCO[2:0] bits */
;;;133      RCC->CFGR &= (u32)0xF8FF0000;
00000a  6841              LDR      r1,[r0,#4]
00000c  4aad              LDR      r2,|L1.708|
00000e  4011              ANDS     r1,r1,r2
000010  6041              STR      r1,[r0,#4]
;;;134      
;;;135      /* Reset HSEON, CSSON and PLLON bits */
;;;136      RCC->CR &= (u32)0xFEF6FFFF;
000012  6801              LDR      r1,[r0,#0]
000014  4aac              LDR      r2,|L1.712|
000016  4011              ANDS     r1,r1,r2
000018  6001              STR      r1,[r0,#0]
;;;137    
;;;138      /* Reset HSEBYP bit */
;;;139      RCC->CR &= (u32)0xFFFBFFFF;
00001a  6801              LDR      r1,[r0,#0]
00001c  f421f421          BIC      r1,r1,#0x40000
000020  6001              STR      r1,[r0,#0]
;;;140    
;;;141      /* Reset PLLSRC, PLLXTPRE, PLLMUL[3:0] and USBPRE bits */
;;;142      RCC->CFGR &= (u32)0xFF80FFFF;
000022  6841              LDR      r1,[r0,#4]
000024  f421f421          BIC      r1,r1,#0x7f0000
000028  6041              STR      r1,[r0,#4]
;;;143    
;;;144      /* Disable all interrupts */
;;;145      RCC->CIR = 0x00000000;
00002a  2100              MOVS     r1,#0
00002c  6081              STR      r1,[r0,#8]
;;;146    }
00002e  4770              BX       lr
;;;147    
                          ENDP

                  RCC_HSEConfig PROC
;;;168      /* Reset HSEON bit */
;;;169      RCC->CR &= CR_HSEON_Reset;
000030  49a3              LDR      r1,|L1.704|
000032  680a              LDR      r2,[r1,#0]
000034  f422f422          BIC      r2,r2,#0x10000
000038  600a              STR      r2,[r1,#0]
;;;170    
;;;171      /* Reset HSEBYP bit */
;;;172      RCC->CR &= CR_HSEBYP_Reset;
00003a  680a              LDR      r2,[r1,#0]
00003c  f422f422          BIC      r2,r2,#0x40000
000040  600a              STR      r2,[r1,#0]
;;;173    
;;;174      /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
;;;175      switch(RCC_HSE)
000042  f5b0f5b0          CMP      r0,#0x10000
000046  d007              BEQ      |L1.88|
000048  f5b0f5b0          CMP      r0,#0x40000
00004c  d103              BNE      |L1.86|
;;;176      {
;;;177        case RCC_HSE_ON:
;;;178          /* Set HSEON bit */
;;;179          RCC->CR |= CR_HSEON_Set;
;;;180          break;
;;;181          
;;;182        case RCC_HSE_Bypass:
;;;183          /* Set HSEBYP and HSEON bits */
;;;184          RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
00004e  6808              LDR      r0,[r1,#0]
000050  f440f440          ORR      r0,r0,#0x50000
000054  6008              STR      r0,[r1,#0]
                  |L1.86|
;;;185          break;            
;;;186          
;;;187        default:
;;;188          break;      
;;;189      }
;;;190    }
000056  4770              BX       lr
                  |L1.88|
000058  6808              LDR      r0,[r1,#0]            ;179
00005a  f440f440          ORR      r0,r0,#0x10000        ;179
00005e  6008              STR      r0,[r1,#0]            ;179
000060  4770              BX       lr
;;;191    
                          ENDP

                  RCC_GetFlagStatus PROC
;;;990    FlagStatus RCC_GetFlagStatus(u8 RCC_FLAG)
;;;991    {
000062  4603              MOV      r3,r0
;;;992      u32 tmp = 0;
;;;993      u32 statusreg = 0;
;;;994      FlagStatus bitstatus = RESET;
000064  2000              MOVS     r0,#0
;;;995    
;;;996      /* Check the parameters */
;;;997      assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;998    
;;;999      /* Get the RCC register index */
;;;1000     tmp = RCC_FLAG >> 5;
000066  0959              LSRS     r1,r3,#5
;;;1001   
;;;1002     if (tmp == 1)               /* The flag to check is in CR register */
000068  4a95              LDR      r2,|L1.704|
00006a  2901              CMP      r1,#1
00006c  d101              BNE      |L1.114|
;;;1003     {
;;;1004       statusreg = RCC->CR;
00006e  6811              LDR      r1,[r2,#0]
000070  e004              B        |L1.124|
                  |L1.114|
;;;1005     }
;;;1006     else if (tmp == 2)          /* The flag to check is in BDCR register */
000072  2902              CMP      r1,#2
000074  d101              BNE      |L1.122|
;;;1007     {
;;;1008       statusreg = RCC->BDCR;
000076  6a11              LDR      r1,[r2,#0x20]
000078  e000              B        |L1.124|
                  |L1.122|
;;;1009     }
;;;1010     else                       /* The flag to check is in CSR register */
;;;1011     {
;;;1012       statusreg = RCC->CSR;
00007a  6a51              LDR      r1,[r2,#0x24]
                  |L1.124|
;;;1013     }
;;;1014   
;;;1015     /* Get the flag position */
;;;1016     tmp = RCC_FLAG & FLAG_Mask;
00007c  f003f003          AND      r2,r3,#0x1f
;;;1017   
;;;1018     if ((statusreg & ((u32)1 << tmp)) != (u32)RESET)
000080  2301              MOVS     r3,#1
000082  4093              LSLS     r3,r3,r2
000084  420b              TST      r3,r1
000086  d000              BEQ      |L1.138|
;;;1019     {
;;;1020       bitstatus = SET;
000088  2001              MOVS     r0,#1
                  |L1.138|
;;;1021     }
;;;1022     else
;;;1023     {
;;;1024       bitstatus = RESET;
;;;1025     }
;;;1026   
;;;1027     /* Return the flag status */
;;;1028     return bitstatus;
;;;1029   }
00008a  4770              BX       lr
;;;1030   
                          ENDP

                  RCC_WaitForHSEStartUp PROC
;;;201    ErrorStatus RCC_WaitForHSEStartUp(void)
;;;202    {
00008c  b530              PUSH     {r4,r5,lr}
00008e  4c8f              LDR      r4,|L1.716|
000090  f240f240          MOV      r5,#0x1ff
                  |L1.148|
;;;203      ErrorStatus status = ERROR;
;;;204    
;;;205      /* Wait till HSE is ready and if Time out is reached exit */
;;;206      do
;;;207      {
;;;208        HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
000094  2031              MOVS     r0,#0x31
000096  f7fff7ff          BL       RCC_GetFlagStatus
00009a  7020              STRB     r0,[r4,#0]  ; HSEStatus
;;;209        StartUpCounter++;  
00009c  6860              LDR      r0,[r4,#4]  ; StartUpCounter
00009e  1c40              ADDS     r0,r0,#1
0000a0  6060              STR      r0,[r4,#4]  ; StartUpCounter
;;;210      } while((HSEStatus == RESET) && (StartUpCounter != HSEStartUp_TimeOut));
0000a2  7820              LDRB     r0,[r4,#0]  ; HSEStatus
0000a4  b910              CBNZ     r0,|L1.172|
0000a6  6860              LDR      r0,[r4,#4]  ; StartUpCounter
0000a8  42a8              CMP      r0,r5
0000aa  d1f3              BNE      |L1.148|
                  |L1.172|
;;;211    
;;;212    
;;;213      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
0000ac  2031              MOVS     r0,#0x31
0000ae  f7fff7ff          BL       RCC_GetFlagStatus
0000b2  b108              CBZ      r0,|L1.184|
;;;214      {
;;;215        status = SUCCESS;
0000b4  2001              MOVS     r0,#1
;;;216      }
;;;217      else
;;;218      {
;;;219        status = ERROR;
;;;220      }  
;;;221    
;;;222      return (status);
;;;223    }
0000b6  bd30              POP      {r4,r5,pc}
                  |L1.184|
0000b8  2000              MOVS     r0,#0                 ;219
0000ba  bd30              POP      {r4,r5,pc}
;;;224    
                          ENDP

                  RCC_AdjustHSICalibrationValue PROC
;;;240    
;;;241      tmpreg = RCC->CR;
0000bc  4a80              LDR      r2,|L1.704|
0000be  6811              LDR      r1,[r2,#0]
;;;242    
;;;243      /* Clear HSITRIM[4:0] bits */
;;;244      tmpreg &= CR_HSITRIM_Mask;
0000c0  f021f021          BIC      r1,r1,#0xf8
;;;245    
;;;246      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;247      tmpreg |= (u32)HSICalibrationValue << 3;
0000c4  ea41ea41          ORR      r0,r1,r0,LSL #3
;;;248    
;;;249      /* Store the new value */
;;;250      RCC->CR = tmpreg;
0000c8  6010              STR      r0,[r2,#0]
;;;251    }
0000ca  4770              BX       lr
;;;252    
                          ENDP

                  RCC_HSICmd PROC
;;;267    
;;;268      *(vu32 *) CR_HSION_BB = (u32)NewState;
0000cc  4980              LDR      r1,|L1.720|
0000ce  6008              STR      r0,[r1,#0]
;;;269    }
0000d0  4770              BX       lr
;;;270    
                          ENDP

                  RCC_PLLConfig PROC
;;;295    
;;;296      tmpreg = RCC->CFGR;
0000d2  4b7b              LDR      r3,|L1.704|
0000d4  685a              LDR      r2,[r3,#4]
;;;297    
;;;298      /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
;;;299      tmpreg &= CFGR_PLL_Mask;
0000d6  f422f422          BIC      r2,r2,#0x3f0000
;;;300    
;;;301      /* Set the PLL configuration bits */
;;;302      tmpreg |= RCC_PLLSource | RCC_PLLMul;
0000da  4308              ORRS     r0,r0,r1
0000dc  4310              ORRS     r0,r0,r2
;;;303    
;;;304      /* Store the new value */
;;;305      RCC->CFGR = tmpreg;
0000de  6058              STR      r0,[r3,#4]
;;;306    }
0000e0  4770              BX       lr
;;;307    
                          ENDP

                  RCC_PLLCmd PROC
;;;321    
;;;322      *(vu32 *) CR_PLLON_BB = (u32)NewState;
0000e2  497b              LDR      r1,|L1.720|
0000e4  6608              STR      r0,[r1,#0x60]
;;;323    }
0000e6  4770              BX       lr
;;;324    
                          ENDP

                  RCC_SYSCLKConfig PROC
;;;342    
;;;343      tmpreg = RCC->CFGR;
0000e8  4a75              LDR      r2,|L1.704|
0000ea  6851              LDR      r1,[r2,#4]
;;;344    
;;;345      /* Clear SW[1:0] bits */
;;;346      tmpreg &= CFGR_SW_Mask;
0000ec  f021f021          BIC      r1,r1,#3
;;;347    
;;;348      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;349      tmpreg |= RCC_SYSCLKSource;
0000f0  4301              ORRS     r1,r1,r0
;;;350    
;;;351      /* Store the new value */
;;;352      RCC->CFGR = tmpreg;
0000f2  6051              STR      r1,[r2,#4]
;;;353    }
0000f4  4770              BX       lr
;;;354    
                          ENDP

                  RCC_GetSYSCLKSource PROC
;;;367    {
;;;368      return ((u8)(RCC->CFGR & CFGR_SWS_Mask));
0000f6  4872              LDR      r0,|L1.704|
0000f8  6840              LDR      r0,[r0,#4]
0000fa  f000f000          AND      r0,r0,#0xc
;;;369    }
0000fe  4770              BX       lr
;;;370    
                          ENDP

                  RCC_HCLKConfig PROC
;;;395    
;;;396      tmpreg = RCC->CFGR;
000100  4a6f              LDR      r2,|L1.704|
000102  6851              LDR      r1,[r2,#4]
;;;397    
;;;398      /* Clear HPRE[3:0] bits */
;;;399      tmpreg &= CFGR_HPRE_Reset_Mask;
000104  f021f021          BIC      r1,r1,#0xf0
;;;400    
;;;401      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;402      tmpreg |= RCC_SYSCLK;
000108  4301              ORRS     r1,r1,r0
;;;403    
;;;404      /* Store the new value */
;;;405      RCC->CFGR = tmpreg;
00010a  6051              STR      r1,[r2,#4]
;;;406    }
00010c  4770              BX       lr
;;;407    
                          ENDP

                  RCC_PCLK1Config PROC
;;;428    
;;;429      tmpreg = RCC->CFGR;
00010e  4a6c              LDR      r2,|L1.704|
000110  6851              LDR      r1,[r2,#4]
;;;430    
;;;431      /* Clear PPRE1[2:0] bits */
;;;432      tmpreg &= CFGR_PPRE1_Reset_Mask;
000112  f421f421          BIC      r1,r1,#0x700
;;;433    
;;;434      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;435      tmpreg |= RCC_HCLK;
000116  4301              ORRS     r1,r1,r0
;;;436    
;;;437      /* Store the new value */
;;;438      RCC->CFGR = tmpreg;
000118  6051              STR      r1,[r2,#4]
;;;439    }
00011a  4770              BX       lr
;;;440    
                          ENDP

                  RCC_PCLK2Config PROC
;;;461    
;;;462      tmpreg = RCC->CFGR;
00011c  4a68              LDR      r2,|L1.704|
00011e  6851              LDR      r1,[r2,#4]
;;;463    
;;;464      /* Clear PPRE2[2:0] bits */
;;;465      tmpreg &= CFGR_PPRE2_Reset_Mask;
000120  f421f421          BIC      r1,r1,#0x3800
;;;466    
;;;467      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;468      tmpreg |= RCC_HCLK << 3;
000124  ea41ea41          ORR      r0,r1,r0,LSL #3
;;;469    
;;;470      /* Store the new value */
;;;471      RCC->CFGR = tmpreg;
000128  6050              STR      r0,[r2,#4]
;;;472    }
00012a  4770              BX       lr
;;;473    
                          ENDP

                  RCC_ITConfig PROC
;;;495    
;;;496      if (NewState != DISABLE)
00012c  4a64              LDR      r2,|L1.704|
00012e  b119              CBZ      r1,|L1.312|
;;;497      {
;;;498        /* Perform Byte access to RCC_CIR[12:8] bits to enable the selected interrupts */
;;;499        *(vu8 *) CIR_BYTE2_ADDRESS |= RCC_IT;
000130  7a51              LDRB     r1,[r2,#9]
000132  4301              ORRS     r1,r1,r0
000134  7251              STRB     r1,[r2,#9]
;;;500      }
;;;501      else
;;;502      {
;;;503        /* Perform Byte access to RCC_CIR[12:8] bits to disable the selected interrupts */
;;;504        *(vu8 *) CIR_BYTE2_ADDRESS &= (u8)~RCC_IT;
;;;505      }
;;;506    }
000136  4770              BX       lr
                  |L1.312|
000138  7a51              LDRB     r1,[r2,#9]            ;504
00013a  4381              BICS     r1,r1,r0              ;504
00013c  7251              STRB     r1,[r2,#9]            ;504
00013e  4770              BX       lr
;;;507    
                          ENDP

                  RCC_USBCLKConfig PROC
;;;525    
;;;526      *(vu32 *) CFGR_USBPRE_BB = RCC_USBCLKSource;
000140  4963              LDR      r1,|L1.720|
000142  31d8              ADDS     r1,r1,#0xd8
000144  6008              STR      r0,[r1,#0]
;;;527    }
000146  4770              BX       lr
;;;528    
                          ENDP

                  RCC_ADCCLKConfig PROC
;;;548    
;;;549      tmpreg = RCC->CFGR;
000148  4a5d              LDR      r2,|L1.704|
00014a  6851              LDR      r1,[r2,#4]
;;;550    
;;;551      /* Clear ADCPRE[1:0] bits */
;;;552      tmpreg &= CFGR_ADCPRE_Reset_Mask;
00014c  f421f421          BIC      r1,r1,#0xc000
;;;553    
;;;554      /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
;;;555      tmpreg |= RCC_PCLK2;
000150  4301              ORRS     r1,r1,r0
;;;556    
;;;557      /* Store the new value */
;;;558      RCC->CFGR = tmpreg;
000152  6051              STR      r1,[r2,#4]
;;;559    }
000154  4770              BX       lr
;;;560    
                          ENDP

                  RCC_LSEConfig PROC
;;;579      /* Reset LSEON bit */
;;;580      *(vu8 *) BDCR_ADDRESS = RCC_LSE_OFF;
000156  495a              LDR      r1,|L1.704|
000158  2200              MOVS     r2,#0
00015a  3120              ADDS     r1,r1,#0x20
00015c  700a              STRB     r2,[r1,#0]
;;;581    
;;;582      /* Reset LSEBYP bit */
;;;583      *(vu8 *) BDCR_ADDRESS = RCC_LSE_OFF;
00015e  f801f801          STRB     r2,[r1],#-0x20
;;;584    
;;;585      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;586      switch(RCC_LSE)
000162  2801              CMP      r0,#1
000164  d005              BEQ      |L1.370|
000166  2804              CMP      r0,#4
000168  d102              BNE      |L1.368|
;;;587      {
;;;588        case RCC_LSE_ON:
;;;589          /* Set LSEON bit */
;;;590          *(vu8 *) BDCR_ADDRESS = RCC_LSE_ON;
;;;591          break;
;;;592          
;;;593        case RCC_LSE_Bypass:
;;;594          /* Set LSEBYP and LSEON bits */
;;;595          *(vu8 *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
00016a  2005              MOVS     r0,#5
00016c  f881f881          STRB     r0,[r1,#0x20]
                  |L1.368|
;;;596          break;            
;;;597          
;;;598        default:
;;;599          break;      
;;;600      }
;;;601    }
000170  4770              BX       lr
                  |L1.370|
000172  2001              MOVS     r0,#1                 ;590
000174  f881f881          STRB     r0,[r1,#0x20]         ;590
000178  4770              BX       lr
;;;602    
                          ENDP

                  RCC_LSICmd PROC
;;;616    
;;;617      *(vu32 *) CSR_LSION_BB = (u32)NewState;
00017a  4956              LDR      r1,|L1.724|
00017c  6008              STR      r0,[r1,#0]
;;;618    }
00017e  4770              BX       lr
;;;619    
                          ENDP

                  RCC_RTCCLKConfig PROC
;;;639      /* Select the RTC clock source */
;;;640      RCC->BDCR |= RCC_RTCCLKSource;
000180  4a4f              LDR      r2,|L1.704|
000182  6a11              LDR      r1,[r2,#0x20]
000184  4301              ORRS     r1,r1,r0
000186  6211              STR      r1,[r2,#0x20]
;;;641    }
000188  4770              BX       lr
;;;642    
                          ENDP

                  RCC_RTCCLKCmd PROC
;;;657    
;;;658      *(vu32 *) BDCR_RTCEN_BB = (u32)NewState;
00018a  4952              LDR      r1,|L1.724|
00018c  3944              SUBS     r1,r1,#0x44
00018e  6008              STR      r0,[r1,#0]
;;;659    }
000190  4770              BX       lr
;;;660    
                          ENDP

                  RCC_GetClocksFreq PROC
;;;669    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
;;;670    {
000192  b530              PUSH     {r4,r5,lr}
;;;671      u32 tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
;;;672    
;;;673      /* Get SYSCLK source -------------------------------------------------------*/
;;;674      tmp = RCC->CFGR & CFGR_SWS_Mask;
000194  4a4a              LDR      r2,|L1.704|
000196  6851              LDR      r1,[r2,#4]
000198  f001f001          AND      r1,r1,#0xc
;;;675    
;;;676      switch (tmp)
00019c  4b4e              LDR      r3,|L1.728|
00019e  b189              CBZ      r1,|L1.452|
0001a0  2904              CMP      r1,#4
0001a2  d011              BEQ      |L1.456|
0001a4  2908              CMP      r1,#8
0001a6  d11a              BNE      |L1.478|
;;;677      {
;;;678        case 0x00:  /* HSI used as system clock */
;;;679          RCC_Clocks->SYSCLK_Frequency = HSI_Value;
;;;680          break;
;;;681    
;;;682        case 0x04:  /* HSE used as system clock */
;;;683          RCC_Clocks->SYSCLK_Frequency = HSE_Value;
;;;684          break;
;;;685    
;;;686        case 0x08:  /* PLL used as system clock */
;;;687          /* Get PLL clock source and multiplication factor ----------------------*/
;;;688          pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
0001a8  6851              LDR      r1,[r2,#4]
0001aa  f401f401          AND      r1,r1,#0x3c0000
;;;689          pllmull = ( pllmull >> 18) + 2;
0001ae  2402              MOVS     r4,#2
0001b0  eb04eb04          ADD      r1,r4,r1,LSR #18
;;;690    
;;;691          pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
0001b4  6854              LDR      r4,[r2,#4]
0001b6  f404f404          AND      r4,r4,#0x10000
;;;692    
;;;693          if (pllsource == 0x00)
0001ba  4d48              LDR      r5,|L1.732|
0001bc  b934              CBNZ     r4,|L1.460|
;;;694          {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;695            RCC_Clocks->SYSCLK_Frequency = (HSI_Value >> 1) * pllmull;
0001be  4369              MULS     r1,r5,r1
0001c0  6001              STR      r1,[r0,#0]
0001c2  e00d              B        |L1.480|
                  |L1.452|
0001c4  6003              STR      r3,[r0,#0]            ;679
0001c6  e00b              B        |L1.480|
                  |L1.456|
0001c8  6003              STR      r3,[r0,#0]            ;683
0001ca  e009              B        |L1.480|
                  |L1.460|
;;;696          }
;;;697          else
;;;698          {/* HSE selected as PLL clock entry */
;;;699    
;;;700            if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (u32)RESET)
0001cc  6854              LDR      r4,[r2,#4]
0001ce  03a4              LSLS     r4,r4,#14
0001d0  d502              BPL      |L1.472|
;;;701            {/* HSE oscillator clock divided by 2 */
;;;702    
;;;703              RCC_Clocks->SYSCLK_Frequency = (HSE_Value >> 1) * pllmull;
0001d2  4369              MULS     r1,r5,r1
0001d4  6001              STR      r1,[r0,#0]
0001d6  e003              B        |L1.480|
                  |L1.472|
;;;704            }
;;;705            else
;;;706            {
;;;707              RCC_Clocks->SYSCLK_Frequency = HSE_Value * pllmull;
0001d8  4359              MULS     r1,r3,r1
0001da  6001              STR      r1,[r0,#0]
0001dc  e000              B        |L1.480|
                  |L1.478|
;;;708            }
;;;709          }
;;;710          break;
;;;711    
;;;712        default:
;;;713          RCC_Clocks->SYSCLK_Frequency = HSI_Value;
0001de  6003              STR      r3,[r0,#0]
                  |L1.480|
;;;714          break;
;;;715      }
;;;716    
;;;717      /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
;;;718      /* Get HCLK prescaler */
;;;719      tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
0001e0  6851              LDR      r1,[r2,#4]
0001e2  f001f001          AND      r1,r1,#0xf0
;;;720      tmp = tmp >> 4;
0001e6  0909              LSRS     r1,r1,#4
;;;721      presc = APBAHBPrescTable[tmp];
0001e8  4b3d              LDR      r3,|L1.736|
0001ea  5c5c              LDRB     r4,[r3,r1]
;;;722    
;;;723      /* HCLK clock frequency */
;;;724      RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
0001ec  6801              LDR      r1,[r0,#0]
0001ee  40e1              LSRS     r1,r1,r4
0001f0  6041              STR      r1,[r0,#4]
;;;725    
;;;726      /* Get PCLK1 prescaler */
;;;727      tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
0001f2  6854              LDR      r4,[r2,#4]
0001f4  f404f404          AND      r4,r4,#0x700
;;;728      tmp = tmp >> 8;
0001f8  0a24              LSRS     r4,r4,#8
;;;729      presc = APBAHBPrescTable[tmp];
0001fa  5d1c              LDRB     r4,[r3,r4]
;;;730    
;;;731      /* PCLK1 clock frequency */
;;;732      RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
0001fc  fa21fa21          LSR      r4,r1,r4
000200  6084              STR      r4,[r0,#8]
;;;733    
;;;734      /* Get PCLK2 prescaler */
;;;735      tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
000202  6854              LDR      r4,[r2,#4]
000204  f404f404          AND      r4,r4,#0x3800
;;;736      tmp = tmp >> 11;
000208  0ae4              LSRS     r4,r4,#11
;;;737      presc = APBAHBPrescTable[tmp];
00020a  5d1b              LDRB     r3,[r3,r4]
;;;738    
;;;739      /* PCLK2 clock frequency */
;;;740      RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
00020c  40d9              LSRS     r1,r1,r3
00020e  60c1              STR      r1,[r0,#0xc]
;;;741    
;;;742      /* Get ADCCLK prescaler */
;;;743      tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
000210  6852              LDR      r2,[r2,#4]
000212  f402f402          AND      r2,r2,#0xc000
;;;744      tmp = tmp >> 14;
000216  0b92              LSRS     r2,r2,#14
;;;745      presc = ADCPrescTable[tmp];
000218  4b31              LDR      r3,|L1.736|
00021a  1f1b              SUBS     r3,r3,#4
00021c  5c9a              LDRB     r2,[r3,r2]
;;;746    
;;;747      /* ADCCLK clock frequency */
;;;748      RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
00021e  fbb1fbb1          UDIV     r1,r1,r2
000222  6101              STR      r1,[r0,#0x10]
;;;749    }
000224  bd30              POP      {r4,r5,pc}
;;;750    
                          ENDP

                  RCC_AHBPeriphClockCmd PROC
;;;774    
;;;775      if (NewState != DISABLE)
000226  4a26              LDR      r2,|L1.704|
000228  b119              CBZ      r1,|L1.562|
;;;776      {
;;;777        RCC->AHBENR |= RCC_AHBPeriph;
00022a  6951              LDR      r1,[r2,#0x14]
00022c  4301              ORRS     r1,r1,r0
00022e  6151              STR      r1,[r2,#0x14]
;;;778      }
;;;779      else
;;;780      {
;;;781        RCC->AHBENR &= ~RCC_AHBPeriph;
;;;782      }
;;;783    }
000230  4770              BX       lr
                  |L1.562|
000232  6951              LDR      r1,[r2,#0x14]         ;781
000234  4381              BICS     r1,r1,r0              ;781
000236  6151              STR      r1,[r2,#0x14]         ;781
000238  4770              BX       lr
;;;784    
                          ENDP

                  RCC_APB2PeriphClockCmd PROC
;;;807    
;;;808      if (NewState != DISABLE)
00023a  4a21              LDR      r2,|L1.704|
00023c  b119              CBZ      r1,|L1.582|
;;;809      {
;;;810        RCC->APB2ENR |= RCC_APB2Periph;
00023e  6991              LDR      r1,[r2,#0x18]
000240  4301              ORRS     r1,r1,r0
000242  6191              STR      r1,[r2,#0x18]
;;;811      }
;;;812      else
;;;813      {
;;;814        RCC->APB2ENR &= ~RCC_APB2Periph;
;;;815      }
;;;816    }
000244  4770              BX       lr
                  |L1.582|
000246  6991              LDR      r1,[r2,#0x18]         ;814
000248  4381              BICS     r1,r1,r0              ;814
00024a  6191              STR      r1,[r2,#0x18]         ;814
00024c  4770              BX       lr
;;;817    
                          ENDP

                  RCC_APB1PeriphClockCmd PROC
;;;841    
;;;842      if (NewState != DISABLE)
00024e  4a1c              LDR      r2,|L1.704|
000250  b119              CBZ      r1,|L1.602|
;;;843      {
;;;844        RCC->APB1ENR |= RCC_APB1Periph;
000252  69d1              LDR      r1,[r2,#0x1c]
000254  4301              ORRS     r1,r1,r0
000256  61d1              STR      r1,[r2,#0x1c]
;;;845      }
;;;846      else
;;;847      {
;;;848        RCC->APB1ENR &= ~RCC_APB1Periph;
;;;849      }
;;;850    }
000258  4770              BX       lr
                  |L1.602|
00025a  69d1              LDR      r1,[r2,#0x1c]         ;848
00025c  4381              BICS     r1,r1,r0              ;848
00025e  61d1              STR      r1,[r2,#0x1c]         ;848
000260  4770              BX       lr
;;;851    
                          ENDP

                  RCC_APB2PeriphResetCmd PROC
;;;873    
;;;874      if (NewState != DISABLE)
000262  4a17              LDR      r2,|L1.704|
000264  b119              CBZ      r1,|L1.622|
;;;875      {
;;;876        RCC->APB2RSTR |= RCC_APB2Periph;
000266  68d1              LDR      r1,[r2,#0xc]
000268  4301              ORRS     r1,r1,r0
00026a  60d1              STR      r1,[r2,#0xc]
;;;877      }
;;;878      else
;;;879      {
;;;880        RCC->APB2RSTR &= ~RCC_APB2Periph;
;;;881      }
;;;882    }
00026c  4770              BX       lr
                  |L1.622|
00026e  68d1              LDR      r1,[r2,#0xc]          ;880
000270  4381              BICS     r1,r1,r0              ;880
000272  60d1              STR      r1,[r2,#0xc]          ;880
000274  4770              BX       lr
;;;883    
                          ENDP

                  RCC_APB1PeriphResetCmd PROC
;;;906    
;;;907      if (NewState != DISABLE)
000276  4a12              LDR      r2,|L1.704|
000278  b119              CBZ      r1,|L1.642|
;;;908      {
;;;909        RCC->APB1RSTR |= RCC_APB1Periph;
00027a  6911              LDR      r1,[r2,#0x10]
00027c  4301              ORRS     r1,r1,r0
00027e  6111              STR      r1,[r2,#0x10]
;;;910      }
;;;911      else
;;;912      {
;;;913        RCC->APB1RSTR &= ~RCC_APB1Periph;
;;;914      }
;;;915    }
000280  4770              BX       lr
                  |L1.642|
000282  6911              LDR      r1,[r2,#0x10]         ;913
000284  4381              BICS     r1,r1,r0              ;913
000286  6111              STR      r1,[r2,#0x10]         ;913
000288  4770              BX       lr
;;;916    
                          ENDP

                  RCC_BackupResetCmd PROC
;;;929    
;;;930      *(vu32 *) BDCR_BDRST_BB = (u32)NewState;
00028a  4912              LDR      r1,|L1.724|
00028c  3940              SUBS     r1,r1,#0x40
00028e  6008              STR      r0,[r1,#0]
;;;931    }
000290  4770              BX       lr
;;;932    
                          ENDP

                  RCC_ClockSecuritySystemCmd PROC
;;;945    
;;;946      *(vu32 *) CR_CSSON_BB = (u32)NewState;
000292  490f              LDR      r1,|L1.720|
000294  64c8              STR      r0,[r1,#0x4c]
;;;947    }
000296  4770              BX       lr
;;;948    
                          ENDP

                  RCC_MCOConfig PROC
;;;967      /* Perform Byte access to MCO[2:0] bits to select the MCO source */
;;;968      *(vu8 *) CFGR_BYTE4_ADDRESS = RCC_MCO;
000298  4909              LDR      r1,|L1.704|
00029a  71c8              STRB     r0,[r1,#7]
;;;969    }
00029c  4770              BX       lr
;;;970    
                          ENDP

                  RCC_ClearFlag PROC
;;;1043     /* Set RMVF bit to clear the reset flags */
;;;1044     RCC->CSR |= CSR_RMVF_Set;
00029e  4808              LDR      r0,|L1.704|
0002a0  6a41              LDR      r1,[r0,#0x24]
0002a2  f041f041          ORR      r1,r1,#0x1000000
0002a6  6241              STR      r1,[r0,#0x24]
;;;1045   }
0002a8  4770              BX       lr
;;;1046   
                          ENDP

                  RCC_GetITStatus PROC
;;;1061   ITStatus RCC_GetITStatus(u8 RCC_IT)
;;;1062   {
0002aa  4602              MOV      r2,r0
;;;1063     ITStatus bitstatus = RESET;
0002ac  2000              MOVS     r0,#0
;;;1064   
;;;1065     /* Check the parameters */
;;;1066     assert_param(IS_RCC_GET_IT(RCC_IT));
;;;1067   
;;;1068     /* Check the status of the specified RCC interrupt */
;;;1069     if ((RCC->CIR & RCC_IT) != (u32)RESET)
0002ae  4904              LDR      r1,|L1.704|
0002b0  6889              LDR      r1,[r1,#8]
0002b2  4211              TST      r1,r2
0002b4  d000              BEQ      |L1.696|
;;;1070     {
;;;1071       bitstatus = SET;
0002b6  2001              MOVS     r0,#1
                  |L1.696|
;;;1072     }
;;;1073     else
;;;1074     {
;;;1075       bitstatus = RESET;
;;;1076     }
;;;1077   
;;;1078     /* Return the RCC_IT status */
;;;1079     return  bitstatus;
;;;1080   }
0002b8  4770              BX       lr
;;;1081   
                          ENDP

                  RCC_ClearITPendingBit PROC
;;;1102        pending bits */
;;;1103     *(vu8 *) CIR_BYTE3_ADDRESS = RCC_IT;
0002ba  4901              LDR      r1,|L1.704|
0002bc  7288              STRB     r0,[r1,#0xa]
;;;1104   }
0002be  4770              BX       lr
;;;1105   
                          ENDP

                  |L1.704|
0002c0  40021000          DCD      0x40021000
                  |L1.708|
0002c4  f8ff0000          DCD      0xf8ff0000
                  |L1.712|
0002c8  fef6ffff          DCD      0xfef6ffff
                  |L1.716|
0002cc  00000000          DCD      ||.data||
                  |L1.720|
0002d0  42420000          DCD      0x42420000
                  |L1.724|
0002d4  42420480          DCD      0x42420480
                  |L1.728|
0002d8  007a1200          DCD      0x007a1200
                  |L1.732|
0002dc  003d0900          DCD      0x003d0900
                  |L1.736|
0002e0  00000004          DCD      ||.constdata||+0x4

                          AREA ||.data||, DATA, ALIGN=2

                  HSEStatus
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  StartUpCounter
000004  00000000          DCD      0x00000000

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  ADCPrescTable
000000  02040608          DCB      0x02,0x04,0x06,0x08
                  APBAHBPrescTable
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  01020304          DCB      0x01,0x02,0x03,0x04
000010  06070809          DCB      0x06,0x07,0x08,0x09
