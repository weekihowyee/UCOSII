; generated by ARM/Thumb C/C++ Compiler with , RVCT3.1 [Build 919] for uVision
; commandline ArmCC [--debug -c --asm --interleave -o.\output\os_time.o --depend=.\output\os_time.d --device=DARMSTM --apcs=interwork -O1 -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -IC:\Keil\ARM\INC\ST\STM32F10x --omf_browse=.\output\os_time.crf ..\..\..\..\..\uCOS-II\Source\os_time.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  OSTimeDly PROC
;;;44     void  OSTimeDly (INT16U ticks)
;;;45     {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;46         INT8U      y;
;;;47     #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;48         OS_CPU_SR  cpu_sr = 0;
;;;49     #endif
;;;50     
;;;51     
;;;52     
;;;53         if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
000004  4852              LDR      r0,|L1.336|
000006  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000008  2800              CMP      r0,#0
00000a  d11c              BNE      |L1.70|
;;;54             return;
;;;55         }
;;;56         if (ticks > 0) {                             /* 0 means no delay!                                  */
00000c  2c00              CMP      r4,#0
00000e  d01a              BEQ      |L1.70|
;;;57             OS_ENTER_CRITICAL();
000010  f7fff7ff          BL       OS_CPU_SR_Save
;;;58             y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
000014  494f              LDR      r1,|L1.340|
000016  680a              LDR      r2,[r1,#0]  ; OSTCBCur
000018  f892f892          LDRB     r1,[r2,#0x34]
;;;59             OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
00001c  4b4e              LDR      r3,|L1.344|
00001e  f892f892          LDRB     r6,[r2,#0x35]
000022  5c5d              LDRB     r5,[r3,r1]
000024  43b5              BICS     r5,r5,r6
000026  545d              STRB     r5,[r3,r1]
;;;60             if (OSRdyTbl[y] == 0) {
000028  5c59              LDRB     r1,[r3,r1]
00002a  b929              CBNZ     r1,|L1.56|
;;;61                 OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
00002c  4b4b              LDR      r3,|L1.348|
00002e  f892f892          LDRB     r5,[r2,#0x36]
000032  7819              LDRB     r1,[r3,#0]  ; OSRdyGrp
000034  43a9              BICS     r1,r1,r5
000036  7019              STRB     r1,[r3,#0]  ; OSRdyGrp
                  |L1.56|
;;;62             }
;;;63             OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
000038  85d4              STRH     r4,[r2,#0x2e]
;;;64             OS_EXIT_CRITICAL();
00003a  f7fff7ff          BL       OS_CPU_SR_Restore
;;;65             OS_Sched();                              /* Find next task to run!                             */
00003e  e8bde8bd          POP      {r4-r6,lr}
000042  f7fff7ff          B.W      OS_Sched
                  |L1.70|
;;;66         }
;;;67     }
000046  bd70              POP      {r4-r6,pc}
;;;68     /*$PAGE*/
                          ENDP

                  OSTimeDlyHMSM PROC
;;;96     INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
;;;97     {
000048  b570              PUSH     {r4-r6,lr}
;;;98         INT32U ticks;
;;;99         INT16U loops;
;;;100    
;;;101    
;;;102        if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
00004a  4c41              LDR      r4,|L1.336|
00004c  7824              LDRB     r4,[r4,#0]  ; OSIntNesting
00004e  b10c              CBZ      r4,|L1.84|
;;;103            return (OS_ERR_TIME_DLY_ISR);
000050  2055              MOVS     r0,#0x55
;;;104        }
;;;105    #if OS_ARG_CHK_EN > 0
;;;106        if (hours == 0) {
;;;107            if (minutes == 0) {
;;;108                if (seconds == 0) {
;;;109                    if (ms == 0) {
;;;110                        return (OS_ERR_TIME_ZERO_DLY);
;;;111                    }
;;;112                }
;;;113            }
;;;114        }
;;;115        if (minutes > 59) {
;;;116            return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
;;;117        }
;;;118        if (seconds > 59) {
;;;119            return (OS_ERR_TIME_INVALID_SECONDS);
;;;120        }
;;;121        if (ms > 999) {
;;;122            return (OS_ERR_TIME_INVALID_MS);
;;;123        }
;;;124    #endif
;;;125                                                     /* Compute the total number of clock ticks required.. */
;;;126                                                     /* .. (rounded to the nearest tick)                   */
;;;127        ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
;;;128              + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
;;;129        loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
;;;130        ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
;;;131        OSTimeDly((INT16U)ticks);
;;;132        while (loops > 0) {
;;;133            OSTimeDly((INT16U)32768u);
;;;134            OSTimeDly((INT16U)32768u);
;;;135            loops--;
;;;136        }
;;;137        return (OS_ERR_NONE);
;;;138    }
000052  bd70              POP      {r4-r6,pc}
                  |L1.84|
000054  f44ff44f          MOV      r4,#0x3e8             ;127
000058  4363              MULS     r3,r4,r3              ;127
00005a  fbb3fbb3          UDIV     r3,r3,r4              ;127
00005e  f44ff44f          MOV      r4,#0xe10             ;127
000062  4360              MULS     r0,r4,r0              ;127
000064  ebc1ebc1          RSB      r1,r1,r1,LSL #4       ;127
000068  eb00eb00          ADD      r0,r0,r1,LSL #2       ;127
00006c  4410              ADD      r0,r0,r2              ;127
00006e  217d              MOVS     r1,#0x7d              ;127
000070  4348              MULS     r0,r1,r0              ;127
000072  eb03eb03          ADD      r0,r3,r0,LSL #3       ;127
000076  0c04              LSRS     r4,r0,#16             ;129
000078  b280              UXTH     r0,r0                 ;130
00007a  f7fff7ff          BL       OSTimeDly
00007e  f44ff44f          MOV      r5,#0x8000            ;132
000082  e007              B        |L1.148|
                  |L1.132|
000084  4628              MOV      r0,r5                 ;133
000086  f7fff7ff          BL       OSTimeDly
00008a  4628              MOV      r0,r5                 ;134
00008c  f7fff7ff          BL       OSTimeDly
000090  1e64              SUBS     r4,r4,#1              ;135
000092  b2a4              UXTH     r4,r4                 ;135
                  |L1.148|
000094  2c00              CMP      r4,#0                 ;132
000096  d1f5              BNE      |L1.132|
000098  2000              MOVS     r0,#0                 ;137
00009a  bd70              POP      {r4-r6,pc}
;;;139    #endif
                          ENDP

                  OSTimeDlyResume PROC
;;;167    INT8U  OSTimeDlyResume (INT8U prio)
;;;168    {
00009c  b510              PUSH     {r4,lr}
00009e  4604              MOV      r4,r0
;;;169        OS_TCB    *ptcb;
;;;170    #if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
;;;171        OS_CPU_SR  cpu_sr = 0;
;;;172    #endif
;;;173    
;;;174    
;;;175    
;;;176        if (prio >= OS_LOWEST_PRIO) {
0000a0  2c1f              CMP      r4,#0x1f
0000a2  d301              BCC      |L1.168|
;;;177            return (OS_ERR_PRIO_INVALID);
0000a4  202a              MOVS     r0,#0x2a
;;;178        }
;;;179        OS_ENTER_CRITICAL();
;;;180        ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
;;;181        if (ptcb == (OS_TCB *)0) {
;;;182            OS_EXIT_CRITICAL();
;;;183            return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
;;;184        }
;;;185        if (ptcb == OS_TCB_RESERVED) {
;;;186            OS_EXIT_CRITICAL();
;;;187            return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
;;;188        }
;;;189        if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
;;;190            OS_EXIT_CRITICAL();
;;;191            return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
;;;192        }
;;;193    
;;;194        ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
;;;195        if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
;;;196            ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
;;;197            ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
;;;198        } else {
;;;199            ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
;;;200        }
;;;201        if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
;;;202            OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
;;;203            OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
;;;204            OS_EXIT_CRITICAL();
;;;205            OS_Sched();                                            /* See if this is new highest priority  */
;;;206        } else {
;;;207            OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
;;;208        }
;;;209        return (OS_ERR_NONE);
;;;210    }
0000a6  bd10              POP      {r4,pc}
                  |L1.168|
0000a8  f7fff7ff          BL       OS_CPU_SR_Save
0000ac  492c              LDR      r1,|L1.352|
0000ae  f851f851          LDR      r1,[r1,r4,LSL #2]     ;180
0000b2  b919              CBNZ     r1,|L1.188|
0000b4  f7fff7ff          BL       OS_CPU_SR_Restore
0000b8  2043              MOVS     r0,#0x43              ;183
0000ba  bd10              POP      {r4,pc}
                  |L1.188|
0000bc  2901              CMP      r1,#1                 ;185
0000be  d103              BNE      |L1.200|
0000c0  f7fff7ff          BL       OS_CPU_SR_Restore
0000c4  2043              MOVS     r0,#0x43              ;187
0000c6  bd10              POP      {r4,pc}
                  |L1.200|
0000c8  8dca              LDRH     r2,[r1,#0x2e]         ;189
0000ca  b91a              CBNZ     r2,|L1.212|
0000cc  f7fff7ff          BL       OS_CPU_SR_Restore
0000d0  2050              MOVS     r0,#0x50              ;191
0000d2  bd10              POP      {r4,pc}
                  |L1.212|
0000d4  2300              MOVS     r3,#0                 ;194
0000d6  85cb              STRH     r3,[r1,#0x2e]         ;194
0000d8  f891f891          LDRB     r2,[r1,#0x30]         ;195
0000dc  f012f012          TST      r2,#0x37              ;195
0000e0  d007              BEQ      |L1.242|
0000e2  f022f022          BIC      r2,r2,#0x37           ;196
0000e6  f881f881          STRB     r2,[r1,#0x30]         ;196
0000ea  2201              MOVS     r2,#1                 ;197
0000ec  f881f881          STRB     r2,[r1,#0x31]         ;197
0000f0  e001              B        |L1.246|
                  |L1.242|
0000f2  f881f881          STRB     r3,[r1,#0x31]         ;199
                  |L1.246|
0000f6  f891f891          LDRB     r2,[r1,#0x30]         ;201
0000fa  0712              LSLS     r2,r2,#28             ;201
0000fc  d410              BMI      |L1.288|
0000fe  4b17              LDR      r3,|L1.348|
000100  3134              ADDS     r1,r1,#0x34           ;202
000102  788a              LDRB     r2,[r1,#2]            ;202
000104  781c              LDRB     r4,[r3,#0]            ;202  ; OSRdyGrp
000106  4322              ORRS     r2,r2,r4              ;202
000108  701a              STRB     r2,[r3,#0]            ;202  ; OSRdyGrp
00010a  780a              LDRB     r2,[r1,#0]            ;203
00010c  4b12              LDR      r3,|L1.344|
00010e  7849              LDRB     r1,[r1,#1]            ;203
000110  5c9c              LDRB     r4,[r3,r2]            ;203
000112  430c              ORRS     r4,r4,r1              ;203
000114  549c              STRB     r4,[r3,r2]            ;203
000116  f7fff7ff          BL       OS_CPU_SR_Restore
00011a  f7fff7ff          BL       OS_Sched
00011e  e001              B        |L1.292|
                  |L1.288|
000120  f7fff7ff          BL       OS_CPU_SR_Restore
                  |L1.292|
000124  2000              MOVS     r0,#0                 ;209
000126  bd10              POP      {r4,pc}
;;;211    #endif
                          ENDP

                  OSTimeGet PROC
;;;227    INT32U  OSTimeGet (void)
;;;228    {
000128  b510              PUSH     {r4,lr}
;;;229        INT32U     ticks;
;;;230    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;231        OS_CPU_SR  cpu_sr = 0;
;;;232    #endif
;;;233    
;;;234    
;;;235    
;;;236        OS_ENTER_CRITICAL();
00012a  f7fff7ff          BL       OS_CPU_SR_Save
;;;237        ticks = OSTime;
00012e  490d              LDR      r1,|L1.356|
000130  680c              LDR      r4,[r1,#0]  ; OSTime
;;;238        OS_EXIT_CRITICAL();
000132  f7fff7ff          BL       OS_CPU_SR_Restore
;;;239        return (ticks);
000136  4620              MOV      r0,r4
;;;240    }
000138  bd10              POP      {r4,pc}
;;;241    #endif
                          ENDP

                  OSTimeSet PROC
;;;256    void  OSTimeSet (INT32U ticks)
;;;257    {
00013a  b510              PUSH     {r4,lr}
00013c  4604              MOV      r4,r0
;;;258    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;259        OS_CPU_SR  cpu_sr = 0;
;;;260    #endif
;;;261    
;;;262    
;;;263    
;;;264        OS_ENTER_CRITICAL();
00013e  f7fff7ff          BL       OS_CPU_SR_Save
;;;265        OSTime = ticks;
000142  4908              LDR      r1,|L1.356|
000144  600c              STR      r4,[r1,#0]  ; OSTime
;;;266        OS_EXIT_CRITICAL();
000146  e8bde8bd          POP      {r4,lr}
00014a  f7fff7ff          B.W      OS_CPU_SR_Restore
;;;267    }
;;;268    #endif
                          ENDP

00014e  0000              DCW      0x0000
                  |L1.336|
000150  00000000          DCD      OSIntNesting
                  |L1.340|
000154  00000000          DCD      OSTCBCur
                  |L1.344|
000158  00000000          DCD      OSRdyTbl
                  |L1.348|
00015c  00000000          DCD      OSRdyGrp
                  |L1.352|
000160  00000000          DCD      OSTCBPrioTbl
                  |L1.356|
000164  00000000          DCD      OSTime
