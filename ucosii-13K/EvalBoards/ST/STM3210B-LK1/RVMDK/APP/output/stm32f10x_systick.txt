; generated by ARM/Thumb C/C++ Compiler with , RVCT3.1 [Build 919] for uVision
; commandline ArmCC [--debug -c --asm --interleave -o.\output\stm32f10x_systick.o --depend=.\output\stm32f10x_systick.d --device=DARMSTM --apcs=interwork -O1 -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -IC:\Keil\ARM\INC\ST\STM32F10x --omf_browse=.\output\stm32f10x_systick.crf ..\..\..\..\..\CPU\ST\STM32\src\stm32f10x_systick.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=1

                  SysTick_CLKSourceConfig PROC
;;;49     
;;;50       if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
000000  f04ff04f          MOV      r1,#0xe000e000
000004  2804              CMP      r0,#4
000006  d104              BNE      |L1.18|
;;;51       {
;;;52         SysTick->CTRL |= SysTick_CLKSource_HCLK;
000008  6908              LDR      r0,[r1,#0x10]
00000a  f040f040          ORR      r0,r0,#4
00000e  6108              STR      r0,[r1,#0x10]
;;;53       }
;;;54       else
;;;55       {
;;;56         SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
;;;57       }
;;;58     }
000010  4770              BX       lr
                  |L1.18|
000012  6908              LDR      r0,[r1,#0x10]         ;56
000014  f020f020          BIC      r0,r0,#4              ;56
000018  6108              STR      r0,[r1,#0x10]         ;56
00001a  4770              BX       lr
;;;59     
                          ENDP

                  SysTick_SetReload PROC
;;;72     
;;;73       SysTick->LOAD = Reload;
00001c  f04ff04f          MOV      r1,#0xe000e000
000020  6148              STR      r0,[r1,#0x14]
;;;74     }
000022  4770              BX       lr
;;;75     
                          ENDP

                  SysTick_CounterCmd PROC
;;;91     
;;;92       if (SysTick_Counter == SysTick_Counter_Enable)
000024  f04ff04f          MOV      r1,#0xe000e000
000028  2801              CMP      r0,#1
00002a  d104              BNE      |L1.54|
;;;93       {
;;;94         SysTick->CTRL |= SysTick_Counter_Enable;
00002c  6908              LDR      r0,[r1,#0x10]
00002e  f040f040          ORR      r0,r0,#1
000032  6108              STR      r0,[r1,#0x10]
;;;95       }
;;;96       else if (SysTick_Counter == SysTick_Counter_Disable) 
;;;97       {
;;;98         SysTick->CTRL &= SysTick_Counter_Disable;
;;;99       }
;;;100      else /* SysTick_Counter == SysTick_Counter_Clear */
;;;101      {
;;;102        SysTick->VAL = SysTick_Counter_Clear;
;;;103      }    
;;;104    }
000034  4770              BX       lr
                  |L1.54|
000036  1c80              ADDS     r0,r0,#2              ;96
000038  d104              BNE      |L1.68|
00003a  6908              LDR      r0,[r1,#0x10]         ;98
00003c  f020f020          BIC      r0,r0,#1              ;98
000040  6108              STR      r0,[r1,#0x10]         ;98
000042  4770              BX       lr
                  |L1.68|
000044  2000              MOVS     r0,#0                 ;102
000046  6188              STR      r0,[r1,#0x18]         ;102
000048  4770              BX       lr
;;;105    
                          ENDP

                  SysTick_ITConfig PROC
;;;118    
;;;119      if (NewState != DISABLE)
00004a  f04ff04f          MOV      r1,#0xe000e000
00004e  b120              CBZ      r0,|L1.90|
;;;120      {
;;;121        SysTick->CTRL |= CTRL_TICKINT_Set;
000050  6908              LDR      r0,[r1,#0x10]
000052  f040f040          ORR      r0,r0,#2
000056  6108              STR      r0,[r1,#0x10]
;;;122      }
;;;123      else
;;;124      {
;;;125        SysTick->CTRL &= CTRL_TICKINT_Reset;
;;;126      }
;;;127    }
000058  4770              BX       lr
                  |L1.90|
00005a  6908              LDR      r0,[r1,#0x10]         ;125
00005c  f020f020          BIC      r0,r0,#2              ;125
000060  6108              STR      r0,[r1,#0x10]         ;125
000062  4770              BX       lr
;;;128    
                          ENDP

                  SysTick_GetCounter PROC
;;;137    {
;;;138      return(SysTick->VAL);
000064  f04ff04f          MOV      r0,#0xe000e000
000068  6980              LDR      r0,[r0,#0x18]
;;;139    }
00006a  4770              BX       lr
;;;140    
                          ENDP

                  SysTick_GetFlagStatus PROC
;;;152    FlagStatus SysTick_GetFlagStatus(u8 SysTick_FLAG)
;;;153    {
00006c  4602              MOV      r2,r0
;;;154      u32 statusreg = 0, tmp = 0 ;
;;;155      FlagStatus bitstatus = RESET;
00006e  2000              MOVS     r0,#0
;;;156    
;;;157      /* Check the parameters */
;;;158      assert_param(IS_SYSTICK_FLAG(SysTick_FLAG));
;;;159    
;;;160      /* Get the SysTick register index */
;;;161      tmp = SysTick_FLAG >> 3;
000070  08d1              LSRS     r1,r2,#3
;;;162    
;;;163      if (tmp == 2) /* The flag to check is in CTRL register */
000072  f04ff04f          MOV      r3,#0xe000e000
000076  2902              CMP      r1,#2
000078  d101              BNE      |L1.126|
;;;164      {
;;;165        statusreg = SysTick->CTRL;
00007a  6919              LDR      r1,[r3,#0x10]
00007c  e000              B        |L1.128|
                  |L1.126|
;;;166      }
;;;167      else          /* The flag to check is in CALIB register */
;;;168      {
;;;169        statusreg = SysTick->CALIB;
00007e  69d9              LDR      r1,[r3,#0x1c]
                  |L1.128|
;;;170      }
;;;171    
;;;172      if ((statusreg & ((u32)1 << SysTick_FLAG)) != (u32)RESET)
000080  2301              MOVS     r3,#1
000082  4093              LSLS     r3,r3,r2
000084  420b              TST      r3,r1
000086  d000              BEQ      |L1.138|
;;;173      {
;;;174        bitstatus = SET;
000088  2001              MOVS     r0,#1
                  |L1.138|
;;;175      }
;;;176      else
;;;177      {
;;;178        bitstatus = RESET;
;;;179      }
;;;180      return bitstatus;
;;;181    }
00008a  4770              BX       lr
;;;182    
                          ENDP

