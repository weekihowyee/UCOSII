; generated by ARM/Thumb C/C++ Compiler with , RVCT3.1 [Build 919] for uVision
; commandline ArmCC [--debug -c --asm --interleave -o.\output\os_flag.o --depend=.\output\os_flag.d --device=DARMSTM --apcs=interwork -O1 -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -IC:\Keil\ARM\INC\ST\STM32F10x --omf_browse=.\output\os_flag.crf ..\..\..\..\..\uCOS-II\Source\os_flag.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  OSFlagAccept PROC
;;;92     OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
;;;93     {
000000  e92de92d          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461e              MOV      r6,r3
;;;94         OS_FLAGS      flags_rdy;
;;;95         INT8U         result;
;;;96         BOOLEAN       consume;
;;;97     #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;98         OS_CPU_SR     cpu_sr = 0;
;;;99     #endif
;;;100    
;;;101    
;;;102    
;;;103    #if OS_ARG_CHK_EN > 0
;;;104        if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
;;;105            return ((OS_FLAGS)0);
;;;106        }
;;;107        if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
;;;108            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;109            return ((OS_FLAGS)0);
;;;110        }
;;;111    #endif
;;;112        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
00000c  7828              LDRB     r0,[r5,#0]
00000e  2805              CMP      r0,#5
000010  d004              BEQ      |L1.28|
;;;113            *perr = OS_ERR_EVENT_TYPE;
000012  2001              MOVS     r0,#1
000014  7030              STRB     r0,[r6,#0]
;;;114            return ((OS_FLAGS)0);
000016  2000              MOVS     r0,#0
                  |L1.24|
;;;115        }
;;;116        result = (INT8U)(wait_type & OS_FLAG_CONSUME);
;;;117        if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
;;;118            wait_type &= ~OS_FLAG_CONSUME;
;;;119            consume    = OS_TRUE;
;;;120        } else {
;;;121            consume    = OS_FALSE;
;;;122        }
;;;123    /*$PAGE*/
;;;124        *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
;;;125        OS_ENTER_CRITICAL();
;;;126        switch (wait_type) {
;;;127            case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
;;;128                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
;;;129                 if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
;;;130                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;131                         pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
;;;132                     }
;;;133                 } else {
;;;134                     *perr = OS_ERR_FLAG_NOT_RDY;
;;;135                 }
;;;136                 OS_EXIT_CRITICAL();
;;;137                 break;
;;;138    
;;;139            case OS_FLAG_WAIT_SET_ANY:
;;;140                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
;;;141                 if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
;;;142                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;143                         pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
;;;144                     }
;;;145                 } else {
;;;146                     *perr = OS_ERR_FLAG_NOT_RDY;
;;;147                 }
;;;148                 OS_EXIT_CRITICAL();
;;;149                 break;
;;;150    
;;;151    #if OS_FLAG_WAIT_CLR_EN > 0
;;;152            case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
;;;153                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
;;;154                 if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
;;;155                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;156                         pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
;;;157                     }
;;;158                 } else {
;;;159                     *perr = OS_ERR_FLAG_NOT_RDY;
;;;160                 }
;;;161                 OS_EXIT_CRITICAL();
;;;162                 break;
;;;163    
;;;164            case OS_FLAG_WAIT_CLR_ANY:
;;;165                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
;;;166                 if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
;;;167                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;168                         pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
;;;169                     }
;;;170                 } else {
;;;171                     *perr = OS_ERR_FLAG_NOT_RDY;
;;;172                 }
;;;173                 OS_EXIT_CRITICAL();
;;;174                 break;
;;;175    #endif
;;;176    
;;;177            default:
;;;178                 OS_EXIT_CRITICAL();
;;;179                 flags_rdy = (OS_FLAGS)0;
;;;180                 *perr     = OS_ERR_FLAG_WAIT_TYPE;
;;;181                 break;
;;;182        }
;;;183        return (flags_rdy);
;;;184    }
000018  e8bde8bd          POP      {r4-r8,pc}
                  |L1.28|
00001c  f004f004          AND      r0,r4,#0x80           ;116
000020  b120              CBZ      r0,|L1.44|
000022  f024f024          BIC      r4,r4,#0x80           ;118
000026  f04ff04f          MOV      r8,#1                 ;119
00002a  e001              B        |L1.48|
                  |L1.44|
00002c  f04ff04f          MOV      r8,#0                 ;121
                  |L1.48|
000030  2000              MOVS     r0,#0                 ;124
000032  7030              STRB     r0,[r6,#0]            ;124
000034  f7fff7ff          BL       OS_CPU_SR_Save
000038  2270              MOVS     r2,#0x70              ;126
00003a  b314              CBZ      r4,|L1.130|
00003c  2c01              CMP      r4,#1                 ;126
00003e  d02f              BEQ      |L1.160|
000040  2c02              CMP      r4,#2                 ;126
000042  d00b              BEQ      |L1.92|
000044  2c03              CMP      r4,#3                 ;126
000046  d139              BNE      |L1.188|
000048  8929              LDRH     r1,[r5,#8]            ;140
00004a  ea01ea01          AND      r4,r1,r7              ;140
00004e  b1a4              CBZ      r4,|L1.122|
000050  f1b8f1b8          CMP      r8,#1                 ;142
000054  d112              BNE      |L1.124|
000056  43a1              BICS     r1,r1,r4              ;143
000058  8129              STRH     r1,[r5,#8]            ;143
00005a  e00f              B        |L1.124|
                  |L1.92|
00005c  8929              LDRH     r1,[r5,#8]            ;128
00005e  ea01ea01          AND      r4,r1,r7              ;128
000062  42bc              CMP      r4,r7                 ;129
000064  d105              BNE      |L1.114|
000066  f1b8f1b8          CMP      r8,#1                 ;130
00006a  d103              BNE      |L1.116|
00006c  43a1              BICS     r1,r1,r4              ;131
00006e  8129              STRH     r1,[r5,#8]            ;131
000070  e000              B        |L1.116|
                  |L1.114|
000072  7032              STRB     r2,[r6,#0]            ;134
                  |L1.116|
000074  f7fff7ff          BL       OS_CPU_SR_Restore
000078  e025              B        |L1.198|
                  |L1.122|
00007a  7032              STRB     r2,[r6,#0]            ;146
                  |L1.124|
00007c  f7fff7ff          BL       OS_CPU_SR_Restore
000080  e021              B        |L1.198|
                  |L1.130|
000082  8929              LDRH     r1,[r5,#8]            ;153
000084  ea27ea27          BIC      r4,r7,r1              ;153
000088  42bc              CMP      r4,r7                 ;154
00008a  d105              BNE      |L1.152|
00008c  f1b8f1b8          CMP      r8,#1                 ;155
000090  d103              BNE      |L1.154|
000092  4321              ORRS     r1,r1,r4              ;156
000094  8129              STRH     r1,[r5,#8]            ;156
000096  e000              B        |L1.154|
                  |L1.152|
000098  7032              STRB     r2,[r6,#0]            ;159
                  |L1.154|
00009a  f7fff7ff          BL       OS_CPU_SR_Restore
00009e  e012              B        |L1.198|
                  |L1.160|
0000a0  8929              LDRH     r1,[r5,#8]            ;165
0000a2  ea27ea27          BIC      r4,r7,r1              ;165
0000a6  b12c              CBZ      r4,|L1.180|
0000a8  f1b8f1b8          CMP      r8,#1                 ;167
0000ac  d103              BNE      |L1.182|
0000ae  4321              ORRS     r1,r1,r4              ;168
0000b0  8129              STRH     r1,[r5,#8]            ;168
0000b2  e000              B        |L1.182|
                  |L1.180|
0000b4  7032              STRB     r2,[r6,#0]            ;171
                  |L1.182|
0000b6  f7fff7ff          BL       OS_CPU_SR_Restore
0000ba  e004              B        |L1.198|
                  |L1.188|
0000bc  f7fff7ff          BL       OS_CPU_SR_Restore
0000c0  2400              MOVS     r4,#0                 ;179
0000c2  206f              MOVS     r0,#0x6f              ;180
0000c4  7030              STRB     r0,[r6,#0]            ;180
                  |L1.198|
0000c6  4620              MOV      r0,r4                 ;183
0000c8  e7a6              B        |L1.24|
;;;185    #endif
                          ENDP

                  OSFlagCreate PROC
;;;208    OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
;;;209    {
0000ca  b570              PUSH     {r4-r6,lr}
0000cc  4606              MOV      r6,r0
0000ce  460d              MOV      r5,r1
;;;210        OS_FLAG_GRP *pgrp;
;;;211    #if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
;;;212        OS_CPU_SR    cpu_sr = 0;
;;;213    #endif
;;;214    
;;;215    
;;;216    
;;;217    #if OS_ARG_CHK_EN > 0
;;;218        if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
;;;219            return ((OS_FLAG_GRP *)0);
;;;220        }
;;;221    #endif
;;;222        if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
0000d0  48f6              LDR      r0,|L1.1196|
0000d2  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
0000d4  b118              CBZ      r0,|L1.222|
;;;223            *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
0000d6  2010              MOVS     r0,#0x10
0000d8  7028              STRB     r0,[r5,#0]
;;;224            return ((OS_FLAG_GRP *)0);
0000da  2000              MOVS     r0,#0
;;;225        }
;;;226        OS_ENTER_CRITICAL();
;;;227        pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
;;;228        if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
;;;229                                                        /* Adjust free list                                */
;;;230            OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
;;;231            pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
;;;232            pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
;;;233            pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
;;;234    #if OS_FLAG_NAME_SIZE > 1
;;;235            pgrp->OSFlagName[0]  = '?';
;;;236            pgrp->OSFlagName[1]  = OS_ASCII_NUL;
;;;237    #endif
;;;238            OS_EXIT_CRITICAL();
;;;239            *perr                = OS_ERR_NONE;
;;;240        } else {
;;;241            OS_EXIT_CRITICAL();
;;;242            *perr                = OS_ERR_FLAG_GRP_DEPLETED;
;;;243        }
;;;244        return (pgrp);                                  /* Return pointer to event flag group              */
;;;245    }
0000dc  bd70              POP      {r4-r6,pc}
                  |L1.222|
0000de  f7fff7ff          BL       OS_CPU_SR_Save
0000e2  49f3              LDR      r1,|L1.1200|
0000e4  680c              LDR      r4,[r1,#0]            ;227  ; OSFlagFreeList
0000e6  b16c              CBZ      r4,|L1.260|
0000e8  6862              LDR      r2,[r4,#4]            ;230
0000ea  600a              STR      r2,[r1,#0]            ;230  ; OSFlagFreeList
0000ec  2105              MOVS     r1,#5                 ;231
0000ee  7021              STRB     r1,[r4,#0]            ;231
0000f0  8126              STRH     r6,[r4,#8]            ;232
0000f2  2600              MOVS     r6,#0                 ;233
0000f4  6066              STR      r6,[r4,#4]            ;233
0000f6  213f              MOVS     r1,#0x3f              ;235
0000f8  72a1              STRB     r1,[r4,#0xa]          ;235
0000fa  72e6              STRB     r6,[r4,#0xb]          ;236
0000fc  f7fff7ff          BL       OS_CPU_SR_Restore
000100  702e              STRB     r6,[r5,#0]            ;239
000102  e003              B        |L1.268|
                  |L1.260|
000104  f7fff7ff          BL       OS_CPU_SR_Restore
000108  2072              MOVS     r0,#0x72              ;242
00010a  7028              STRB     r0,[r5,#0]            ;242
                  |L1.268|
00010c  4620              MOV      r0,r4                 ;244
00010e  bd70              POP      {r4-r6,pc}
;;;246    
                          ENDP

                  OS_FlagUnlink PROC
;;;1154   
;;;1155       pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
000110  6842              LDR      r2,[r0,#4]
;;;1156       pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
000112  6801              LDR      r1,[r0,#0]
;;;1157       if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
000114  2300              MOVS     r3,#0
000116  b922              CBNZ     r2,|L1.290|
;;;1158           pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
000118  68c2              LDR      r2,[r0,#0xc]
;;;1159           pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
00011a  6051              STR      r1,[r2,#4]
;;;1160           if (pnode_next != (OS_FLAG_NODE *)0) {
00011c  b121              CBZ      r1,|L1.296|
;;;1161               pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
00011e  604b              STR      r3,[r1,#4]
000120  e002              B        |L1.296|
                  |L1.290|
;;;1162           }
;;;1163       } else {                                                    /* No,  A node somewhere in the list   */
;;;1164           pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
000122  6011              STR      r1,[r2,#0]
;;;1165           if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
000124  b101              CBZ      r1,|L1.296|
;;;1166               pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
000126  604a              STR      r2,[r1,#4]
                  |L1.296|
;;;1167           }
;;;1168       }
;;;1169   #if OS_TASK_DEL_EN > 0
;;;1170       ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
000128  6880              LDR      r0,[r0,#8]
;;;1171       ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
00012a  6283              STR      r3,[r0,#0x28]
;;;1172   #endif
;;;1173   }
00012c  4770              BX       lr
;;;1174   #endif
                          ENDP

                  OS_FlagTaskRdy PROC
;;;1101   static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
;;;1102   {
00012e  b510              PUSH     {r4,lr}
;;;1103       OS_TCB   *ptcb;
;;;1104       BOOLEAN   sched;
;;;1105   
;;;1106   
;;;1107       ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
000130  6882              LDR      r2,[r0,#8]
;;;1108       ptcb->OSTCBDly       = 0;
000132  2300              MOVS     r3,#0
000134  322c              ADDS     r2,r2,#0x2c
000136  8053              STRH     r3,[r2,#2]
;;;1109       ptcb->OSTCBFlagsRdy  = flags_rdy;
000138  8011              STRH     r1,[r2,#0]
;;;1110       ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
00013a  7911              LDRB     r1,[r2,#4]
00013c  f021f021          BIC      r1,r1,#0x20
000140  7111              STRB     r1,[r2,#4]
;;;1111       ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
000142  7153              STRB     r3,[r2,#5]
;;;1112       if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
000144  7911              LDRB     r1,[r2,#4]
000146  3a2c              SUBS     r2,r2,#0x2c
000148  b969              CBNZ     r1,|L1.358|
;;;1113           OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
00014a  4bda              LDR      r3,|L1.1204|
00014c  3234              ADDS     r2,r2,#0x34
00014e  7891              LDRB     r1,[r2,#2]
000150  781c              LDRB     r4,[r3,#0]  ; OSRdyGrp
000152  4321              ORRS     r1,r1,r4
000154  7019              STRB     r1,[r3,#0]  ; OSRdyGrp
;;;1114           OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
000156  7811              LDRB     r1,[r2,#0]
000158  4bd7              LDR      r3,|L1.1208|
00015a  7852              LDRB     r2,[r2,#1]
00015c  5c5c              LDRB     r4,[r3,r1]
00015e  4314              ORRS     r4,r4,r2
000160  545c              STRB     r4,[r3,r1]
;;;1115           sched                   = OS_TRUE;
000162  2401              MOVS     r4,#1
000164  e000              B        |L1.360|
                  |L1.358|
;;;1116       } else {
;;;1117           sched                   = OS_FALSE;
000166  2400              MOVS     r4,#0
                  |L1.360|
;;;1118       }
;;;1119       OS_FlagUnlink(pnode);
000168  f7fff7ff          BL       OS_FlagUnlink
;;;1120       return (sched);
00016c  4620              MOV      r0,r4
;;;1121   }
00016e  bd10              POP      {r4,pc}
;;;1122   
                          ENDP

                  OSFlagDel PROC
;;;285    OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
;;;286    {
000170  e92de92d          PUSH     {r4-r12,lr}
000174  4604              MOV      r4,r0
000176  4689              MOV      r9,r1
000178  4616              MOV      r6,r2
;;;287        BOOLEAN       tasks_waiting;
;;;288        OS_FLAG_NODE *pnode;
;;;289        OS_FLAG_GRP  *pgrp_return;
;;;290    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;291        OS_CPU_SR     cpu_sr = 0;
;;;292    #endif
;;;293    
;;;294    
;;;295    
;;;296    #if OS_ARG_CHK_EN > 0
;;;297        if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
;;;298            return (pgrp);
;;;299        }
;;;300        if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
;;;301            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;302            return (pgrp);
;;;303        }
;;;304    #endif
;;;305        if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
00017a  48cc              LDR      r0,|L1.1196|
00017c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00017e  b120              CBZ      r0,|L1.394|
;;;306            *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
000180  200f              MOVS     r0,#0xf
000182  7030              STRB     r0,[r6,#0]
;;;307            return (pgrp);
000184  4620              MOV      r0,r4
                  |L1.390|
;;;308        }
;;;309        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
;;;310            *perr = OS_ERR_EVENT_TYPE;
;;;311            return (pgrp);
;;;312        }
;;;313        OS_ENTER_CRITICAL();
;;;314        if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
;;;315            tasks_waiting = OS_TRUE;                           /* Yes                                      */
;;;316        } else {
;;;317            tasks_waiting = OS_FALSE;                          /* No                                       */
;;;318        }
;;;319        switch (opt) {
;;;320            case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
;;;321                 if (tasks_waiting == OS_FALSE) {
;;;322    #if OS_FLAG_NAME_SIZE > 1
;;;323                     pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
;;;324                     pgrp->OSFlagName[1]  = OS_ASCII_NUL;
;;;325    #endif
;;;326                     pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
;;;327                     pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
;;;328                     pgrp->OSFlagFlags    = (OS_FLAGS)0;
;;;329                     OSFlagFreeList       = pgrp;
;;;330                     OS_EXIT_CRITICAL();
;;;331                     *perr                = OS_ERR_NONE;
;;;332                     pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
;;;333                 } else {
;;;334                     OS_EXIT_CRITICAL();
;;;335                     *perr                = OS_ERR_TASK_WAITING;
;;;336                     pgrp_return          = pgrp;
;;;337                 }
;;;338                 break;
;;;339    
;;;340            case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
;;;341                 pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
;;;342                 while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
;;;343                     (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
;;;344                     pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
;;;345                 }
;;;346    #if OS_FLAG_NAME_SIZE > 1
;;;347                 pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
;;;348                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
;;;349    #endif
;;;350                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
;;;351                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
;;;352                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
;;;353                 OSFlagFreeList       = pgrp;
;;;354                 OS_EXIT_CRITICAL();
;;;355                 if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
;;;356                     OS_Sched();                               /* Find highest priority task ready to run  */
;;;357                 }
;;;358                 *perr = OS_ERR_NONE;
;;;359                 pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
;;;360                 break;
;;;361    
;;;362            default:
;;;363                 OS_EXIT_CRITICAL();
;;;364                 *perr                = OS_ERR_INVALID_OPT;
;;;365                 pgrp_return          = pgrp;
;;;366                 break;
;;;367        }
;;;368        return (pgrp_return);
;;;369    }
000186  e8bde8bd          POP      {r4-r12,pc}
                  |L1.394|
00018a  7820              LDRB     r0,[r4,#0]            ;309
00018c  2805              CMP      r0,#5                 ;309
00018e  d003              BEQ      |L1.408|
000190  2001              MOVS     r0,#1                 ;310
000192  7030              STRB     r0,[r6,#0]            ;310
000194  4620              MOV      r0,r4                 ;311
000196  e7f6              B        |L1.390|
                  |L1.408|
000198  f7fff7ff          BL       OS_CPU_SR_Save
00019c  4680              MOV      r8,r0                 ;313
00019e  6865              LDR      r5,[r4,#4]            ;314
0001a0  b10d              CBZ      r5,|L1.422|
0001a2  2701              MOVS     r7,#1                 ;315
0001a4  e000              B        |L1.424|
                  |L1.422|
0001a6  2700              MOVS     r7,#0                 ;317
                  |L1.424|
0001a8  ea5fea5f          MOVS     r0,r9                 ;319
0001ac  f8dff8df          LDR      r10,|L1.1200|
0001b0  f04ff04f          MOV      r9,#0x3f              ;319
0001b4  f04ff04f          MOV      r11,#0                ;319
0001b8  d002              BEQ      |L1.448|
0001ba  2801              CMP      r0,#1                 ;319
0001bc  d13b              BNE      |L1.566|
0001be  e020              B        |L1.514|
                  |L1.448|
0001c0  b99f              CBNZ     r7,|L1.490|
0001c2  f884f884          STRB     r9,[r4,#0xa]          ;323
0001c6  f884f884          STRB     r11,[r4,#0xb]         ;324
0001ca  f884f884          STRB     r11,[r4,#0]           ;326
0001ce  f8daf8da          LDR      r0,[r10,#0]           ;327  ; OSFlagFreeList
0001d2  6060              STR      r0,[r4,#4]            ;327
0001d4  f8a4f8a4          STRH     r11,[r4,#8]           ;328
0001d8  f8caf8ca          STR      r4,[r10,#0]           ;329  ; OSFlagFreeList
0001dc  4640              MOV      r0,r8                 ;330
0001de  f7fff7ff          BL       OS_CPU_SR_Restore
0001e2  f886f886          STRB     r11,[r6,#0]           ;331
0001e6  2000              MOVS     r0,#0                 ;332
0001e8  e7cd              B        |L1.390|
                  |L1.490|
0001ea  4640              MOV      r0,r8                 ;334
0001ec  f7fff7ff          BL       OS_CPU_SR_Restore
0001f0  2049              MOVS     r0,#0x49              ;335
0001f2  7030              STRB     r0,[r6,#0]            ;335
0001f4  4620              MOV      r0,r4                 ;336
0001f6  e7c6              B        |L1.390|
                  |L1.504|
0001f8  2100              MOVS     r1,#0                 ;343
0001fa  4628              MOV      r0,r5                 ;343
0001fc  f7fff7ff          BL       OS_FlagTaskRdy
000200  682d              LDR      r5,[r5,#0]            ;344
                  |L1.514|
000202  2d00              CMP      r5,#0                 ;342
000204  d1f8              BNE      |L1.504|
000206  f884f884          STRB     r9,[r4,#0xa]          ;347
00020a  f884f884          STRB     r11,[r4,#0xb]         ;348
00020e  f884f884          STRB     r11,[r4,#0]           ;350
000212  f8daf8da          LDR      r0,[r10,#0]           ;351  ; OSFlagFreeList
000216  6060              STR      r0,[r4,#4]            ;351
000218  f8a4f8a4          STRH     r11,[r4,#8]           ;352
00021c  f8caf8ca          STR      r4,[r10,#0]           ;353  ; OSFlagFreeList
000220  4640              MOV      r0,r8                 ;354
000222  f7fff7ff          BL       OS_CPU_SR_Restore
000226  2f01              CMP      r7,#1                 ;355
000228  d101              BNE      |L1.558|
00022a  f7fff7ff          BL       OS_Sched
                  |L1.558|
00022e  f886f886          STRB     r11,[r6,#0]           ;358
000232  2000              MOVS     r0,#0                 ;359
000234  e7a7              B        |L1.390|
                  |L1.566|
000236  4640              MOV      r0,r8                 ;363
000238  f7fff7ff          BL       OS_CPU_SR_Restore
00023c  2007              MOVS     r0,#7                 ;364
00023e  7030              STRB     r0,[r6,#0]            ;364
000240  4620              MOV      r0,r4                 ;365
000242  e7a0              B        |L1.390|
;;;370    #endif
                          ENDP

                  OSFlagNameGet PROC
;;;396    INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
;;;397    {
000244  e92de92d          PUSH     {r4-r8,lr}
000248  4606              MOV      r6,r0
00024a  460f              MOV      r7,r1
00024c  4615              MOV      r5,r2
;;;398        INT8U      len;
;;;399    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;400        OS_CPU_SR  cpu_sr = 0;
;;;401    #endif
;;;402    
;;;403    
;;;404    
;;;405    #if OS_ARG_CHK_EN > 0
;;;406        if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
;;;407            return (0);
;;;408        }
;;;409        if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
;;;410            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;411            return (0);
;;;412        }
;;;413        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;414            *perr = OS_ERR_PNAME_NULL;
;;;415            return (0);
;;;416        }
;;;417    #endif
;;;418        if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
00024e  4897              LDR      r0,|L1.1196|
000250  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000252  b118              CBZ      r0,|L1.604|
;;;419            *perr = OS_ERR_NAME_GET_ISR;
000254  2011              MOVS     r0,#0x11
000256  7028              STRB     r0,[r5,#0]
;;;420            return (0);
000258  2000              MOVS     r0,#0
;;;421        }
;;;422        OS_ENTER_CRITICAL();
;;;423        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
;;;424            OS_EXIT_CRITICAL();
;;;425            *perr = OS_ERR_EVENT_TYPE;
;;;426            return (0);
;;;427        }
;;;428        len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
;;;429        OS_EXIT_CRITICAL();
;;;430        *perr = OS_ERR_NONE;
;;;431        return (len);
;;;432    }
00025a  e6dd              B        |L1.24|
                  |L1.604|
00025c  f7fff7ff          BL       OS_CPU_SR_Save
000260  4604              MOV      r4,r0                 ;422
000262  7830              LDRB     r0,[r6,#0]            ;423
000264  2805              CMP      r0,#5                 ;423
000266  d006              BEQ      |L1.630|
000268  4620              MOV      r0,r4                 ;424
00026a  f7fff7ff          BL       OS_CPU_SR_Restore
00026e  2001              MOVS     r0,#1                 ;425
000270  7028              STRB     r0,[r5,#0]            ;425
000272  2000              MOVS     r0,#0                 ;426
000274  e6d0              B        |L1.24|
                  |L1.630|
000276  f106f106          ADD      r1,r6,#0xa            ;428
00027a  4638              MOV      r0,r7                 ;428
00027c  f7fff7ff          BL       OS_StrCopy
000280  4606              MOV      r6,r0                 ;428
000282  4620              MOV      r0,r4                 ;429
000284  f7fff7ff          BL       OS_CPU_SR_Restore
000288  2000              MOVS     r0,#0                 ;430
00028a  7028              STRB     r0,[r5,#0]            ;430
00028c  4630              MOV      r0,r6                 ;431
00028e  e6c3              B        |L1.24|
;;;433    #endif
                          ENDP

                  OSFlagNameSet PROC
;;;460    void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
;;;461    {
000290  e92de92d          PUSH     {r4-r8,lr}
000294  4605              MOV      r5,r0
000296  460f              MOV      r7,r1
000298  4614              MOV      r4,r2
;;;462        INT8U      len;
;;;463    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;464        OS_CPU_SR  cpu_sr = 0;
;;;465    #endif
;;;466    
;;;467    
;;;468    
;;;469    #if OS_ARG_CHK_EN > 0
;;;470        if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
;;;471            return;
;;;472        }
;;;473        if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
;;;474            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;475            return;
;;;476        }
;;;477        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;478            *perr = OS_ERR_PNAME_NULL;
;;;479            return;
;;;480        }
;;;481    #endif
;;;482        if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
00029a  4884              LDR      r0,|L1.1196|
00029c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00029e  b110              CBZ      r0,|L1.678|
;;;483            *perr = OS_ERR_NAME_SET_ISR;
0002a0  2012              MOVS     r0,#0x12
0002a2  7020              STRB     r0,[r4,#0]
;;;484            return;
;;;485        }
;;;486        OS_ENTER_CRITICAL();
;;;487        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
;;;488            OS_EXIT_CRITICAL();
;;;489            *perr = OS_ERR_EVENT_TYPE;
;;;490            return;
;;;491        }
;;;492        len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
;;;493        if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
;;;494            OS_EXIT_CRITICAL();
;;;495            *perr = OS_ERR_FLAG_NAME_TOO_LONG;
;;;496            return;
;;;497        }
;;;498        (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
;;;499        OS_EXIT_CRITICAL();
;;;500        *perr = OS_ERR_NONE;
;;;501        return;
;;;502    }
0002a4  e6b8              B        |L1.24|
                  |L1.678|
0002a6  f7fff7ff          BL       OS_CPU_SR_Save
0002aa  4606              MOV      r6,r0                 ;486
0002ac  7828              LDRB     r0,[r5,#0]            ;487
0002ae  2805              CMP      r0,#5                 ;487
0002b0  d005              BEQ      |L1.702|
0002b2  4630              MOV      r0,r6                 ;488
0002b4  f7fff7ff          BL       OS_CPU_SR_Restore
0002b8  2001              MOVS     r0,#1                 ;489
0002ba  7020              STRB     r0,[r4,#0]            ;489
0002bc  e6ac              B        |L1.24|
                  |L1.702|
0002be  4638              MOV      r0,r7                 ;492
0002c0  f7fff7ff          BL       OS_StrLen
0002c4  280f              CMP      r0,#0xf               ;493
0002c6  d905              BLS      |L1.724|
0002c8  4630              MOV      r0,r6                 ;494
0002ca  f7fff7ff          BL       OS_CPU_SR_Restore
0002ce  2073              MOVS     r0,#0x73              ;495
0002d0  7020              STRB     r0,[r4,#0]            ;495
0002d2  e6a1              B        |L1.24|
                  |L1.724|
0002d4  4639              MOV      r1,r7                 ;498
0002d6  f105f105          ADD      r0,r5,#0xa            ;498
0002da  f7fff7ff          BL       OS_StrCopy
0002de  4630              MOV      r0,r6                 ;499
0002e0  f7fff7ff          BL       OS_CPU_SR_Restore
0002e4  2000              MOVS     r0,#0                 ;500
0002e6  7020              STRB     r0,[r4,#0]            ;500
0002e8  e696              B        |L1.24|
;;;503    #endif
                          ENDP

                  OS_FlagBlock PROC
;;;988    static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
;;;989    {
0002ea  b5f0              PUSH     {r4-r7,lr}
0002ec  9f05              LDR      r7,[sp,#0x14]
;;;990        OS_FLAG_NODE  *pnode_next;
;;;991        INT8U          y;
;;;992    
;;;993    
;;;994        OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
0002ee  4d73              LDR      r5,|L1.1212|
0002f0  682c              LDR      r4,[r5,#0]  ; OSTCBCur
0002f2  3428              ADDS     r4,r4,#0x28
0002f4  7a26              LDRB     r6,[r4,#8]
0002f6  f046f046          ORR      r6,r6,#0x20
0002fa  7226              STRB     r6,[r4,#8]
;;;995        OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
0002fc  2600              MOVS     r6,#0
0002fe  7266              STRB     r6,[r4,#9]
;;;996        OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
000300  80e7              STRH     r7,[r4,#6]
;;;997    #if OS_TASK_DEL_EN > 0
;;;998        OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
000302  f844f844          STR      r1,[r4],#-0x28
;;;999    #endif
;;;1000       pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
000306  820a              STRH     r2,[r1,#0x10]
;;;1001       pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
000308  748b              STRB     r3,[r1,#0x12]
;;;1002       pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
00030a  608c              STR      r4,[r1,#8]
;;;1003       pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
00030c  6842              LDR      r2,[r0,#4]
00030e  600a              STR      r2,[r1,#0]
;;;1004       pnode->OSFlagNodePrev     = (void *)0;
000310  604e              STR      r6,[r1,#4]
;;;1005       pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
000312  60c8              STR      r0,[r1,#0xc]
;;;1006       pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
000314  6842              LDR      r2,[r0,#4]
;;;1007       if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
000316  b102              CBZ      r2,|L1.794|
;;;1008           pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
000318  6051              STR      r1,[r2,#4]
                  |L1.794|
;;;1009       }
;;;1010       pgrp->OSFlagWaitList = (void *)pnode;
00031a  6041              STR      r1,[r0,#4]
;;;1011   
;;;1012       y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
00031c  6829              LDR      r1,[r5,#0]  ; OSTCBCur
00031e  f891f891          LDRB     r0,[r1,#0x34]
;;;1013       OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
000322  4a65              LDR      r2,|L1.1208|
000324  f891f891          LDRB     r4,[r1,#0x35]
000328  5c13              LDRB     r3,[r2,r0]
00032a  43a3              BICS     r3,r3,r4
00032c  5413              STRB     r3,[r2,r0]
;;;1014       if (OSRdyTbl[y] == 0x00) {
00032e  5c10              LDRB     r0,[r2,r0]
000330  2800              CMP      r0,#0
000332  d105              BNE      |L1.832|
;;;1015           OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
000334  f891f891          LDRB     r2,[r1,#0x36]
000338  495e              LDR      r1,|L1.1204|
00033a  7808              LDRB     r0,[r1,#0]  ; OSRdyGrp
00033c  4390              BICS     r0,r0,r2
00033e  7008              STRB     r0,[r1,#0]  ; OSRdyGrp
                  |L1.832|
;;;1016       }
;;;1017   }
000340  bdf0              POP      {r4-r7,pc}
;;;1018   
                          ENDP

                  OSFlagPend PROC
;;;560    OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
;;;561    {
000342  e92de92d          PUSH     {r0-r11,lr}
000346  b087              SUB      sp,sp,#0x1c
000348  9d14              LDR      r5,[sp,#0x50]
00034a  4604              MOV      r4,r0
00034c  460f              MOV      r7,r1
00034e  4691              MOV      r9,r2
;;;562        OS_FLAG_NODE  node;
;;;563        OS_FLAGS      flags_rdy;
;;;564        INT8U         result;
;;;565        INT8U         pend_stat;
;;;566        BOOLEAN       consume;
;;;567    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;568        OS_CPU_SR     cpu_sr = 0;
;;;569    #endif
;;;570    
;;;571    
;;;572    
;;;573    #if OS_ARG_CHK_EN > 0
;;;574        if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
;;;575            return ((OS_FLAGS)0);
;;;576        }
;;;577        if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
;;;578            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;579            return ((OS_FLAGS)0);
;;;580        }
;;;581    #endif
;;;582        if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
000350  4856              LDR      r0,|L1.1196|
000352  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000354  b128              CBZ      r0,|L1.866|
;;;583            *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
000356  2002              MOVS     r0,#2
000358  7028              STRB     r0,[r5,#0]
;;;584            return ((OS_FLAGS)0);
00035a  2000              MOVS     r0,#0
                  |L1.860|
;;;585        }
;;;586        if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
;;;587            *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
;;;588            return ((OS_FLAGS)0);
;;;589        }
;;;590        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
;;;591            *perr = OS_ERR_EVENT_TYPE;
;;;592            return ((OS_FLAGS)0);
;;;593        }
;;;594        result = (INT8U)(wait_type & OS_FLAG_CONSUME);
;;;595        if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
;;;596            wait_type &= ~(INT8U)OS_FLAG_CONSUME;
;;;597            consume    = OS_TRUE;
;;;598        } else {
;;;599            consume    = OS_FALSE;
;;;600        }
;;;601    /*$PAGE*/
;;;602        OS_ENTER_CRITICAL();
;;;603        switch (wait_type) {
;;;604            case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
;;;605                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
;;;606                 if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
;;;607                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;608                         pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
;;;609                     }
;;;610                     OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
;;;611                     OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
;;;612                     *perr                   = OS_ERR_NONE;
;;;613                     return (flags_rdy);
;;;614                 } else {                                      /* Block task until events occur or timeout */
;;;615                     OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
;;;616                     OS_EXIT_CRITICAL();
;;;617                 }
;;;618                 break;
;;;619    
;;;620            case OS_FLAG_WAIT_SET_ANY:
;;;621                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
;;;622                 if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
;;;623                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;624                         pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
;;;625                     }
;;;626                     OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
;;;627                     OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
;;;628                     *perr                   = OS_ERR_NONE;
;;;629                     return (flags_rdy);
;;;630                 } else {                                      /* Block task until events occur or timeout */
;;;631                     OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
;;;632                     OS_EXIT_CRITICAL();
;;;633                 }
;;;634                 break;
;;;635    
;;;636    #if OS_FLAG_WAIT_CLR_EN > 0
;;;637            case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
;;;638                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
;;;639                 if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
;;;640                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;641                         pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
;;;642                     }
;;;643                     OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
;;;644                     OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
;;;645                     *perr                   = OS_ERR_NONE;
;;;646                     return (flags_rdy);
;;;647                 } else {                                      /* Block task until events occur or timeout */
;;;648                     OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
;;;649                     OS_EXIT_CRITICAL();
;;;650                 }
;;;651                 break;
;;;652    
;;;653            case OS_FLAG_WAIT_CLR_ANY:
;;;654                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
;;;655                 if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
;;;656                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;657                         pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
;;;658                     }
;;;659                     OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
;;;660                     OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
;;;661                     *perr                   = OS_ERR_NONE;
;;;662                     return (flags_rdy);
;;;663                 } else {                                      /* Block task until events occur or timeout */
;;;664                     OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
;;;665                     OS_EXIT_CRITICAL();
;;;666                 }
;;;667                 break;
;;;668    #endif
;;;669    
;;;670            default:
;;;671                 OS_EXIT_CRITICAL();
;;;672                 flags_rdy = (OS_FLAGS)0;
;;;673                 *perr      = OS_ERR_FLAG_WAIT_TYPE;
;;;674                 return (flags_rdy);
;;;675        }
;;;676    /*$PAGE*/
;;;677        OS_Sched();                                            /* Find next HPT ready to run               */
;;;678        OS_ENTER_CRITICAL();
;;;679        if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
;;;680            pend_stat                = OSTCBCur->OSTCBStatPend;
;;;681            OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;682            OS_FlagUnlink(&node);
;;;683            OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
;;;684            OS_EXIT_CRITICAL();
;;;685            flags_rdy                = (OS_FLAGS)0;
;;;686            switch (pend_stat) {
;;;687                case OS_STAT_PEND_ABORT:
;;;688                     *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
;;;689                     break;
;;;690    
;;;691                case OS_STAT_PEND_TO:
;;;692                default:
;;;693                     *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
;;;694                     break;
;;;695            }
;;;696            return (flags_rdy);
;;;697        }
;;;698        flags_rdy = OSTCBCur->OSTCBFlagsRdy;
;;;699        if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
;;;700            switch (wait_type) {
;;;701                case OS_FLAG_WAIT_SET_ALL:
;;;702                case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
;;;703                     pgrp->OSFlagFlags &= ~flags_rdy;
;;;704                     break;
;;;705    
;;;706    #if OS_FLAG_WAIT_CLR_EN > 0
;;;707                case OS_FLAG_WAIT_CLR_ALL:
;;;708                case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
;;;709                     pgrp->OSFlagFlags |=  flags_rdy;
;;;710                     break;
;;;711    #endif
;;;712                default:
;;;713                     OS_EXIT_CRITICAL();
;;;714                     *perr = OS_ERR_FLAG_WAIT_TYPE;
;;;715                     return ((OS_FLAGS)0);
;;;716            }
;;;717        }
;;;718        OS_EXIT_CRITICAL();
;;;719        *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
;;;720        return (flags_rdy);
;;;721    }
00035c  b00b              ADD      sp,sp,#0x2c
00035e  e8bde8bd          POP      {r4-r11,pc}
                  |L1.866|
000362  4857              LDR      r0,|L1.1216|
000364  7800              LDRB     r0,[r0,#0]            ;586  ; OSLockNesting
000366  b118              CBZ      r0,|L1.880|
000368  200d              MOVS     r0,#0xd               ;587
00036a  7028              STRB     r0,[r5,#0]            ;587
00036c  2000              MOVS     r0,#0                 ;588
00036e  e7f5              B        |L1.860|
                  |L1.880|
000370  7820              LDRB     r0,[r4,#0]            ;590
000372  2805              CMP      r0,#5                 ;590
000374  d003              BEQ      |L1.894|
000376  2001              MOVS     r0,#1                 ;591
000378  7028              STRB     r0,[r5,#0]            ;591
00037a  2000              MOVS     r0,#0                 ;592
00037c  e7ee              B        |L1.860|
                  |L1.894|
00037e  f009f009          AND      r0,r9,#0x80           ;594
000382  b118              CBZ      r0,|L1.908|
000384  f029f029          BIC      r9,r9,#0x80           ;596
000388  2601              MOVS     r6,#1                 ;597
00038a  e000              B        |L1.910|
                  |L1.908|
00038c  2600              MOVS     r6,#0                 ;599
                  |L1.910|
00038e  f7fff7ff          BL       OS_CPU_SR_Save
000392  9001              STR      r0,[sp,#4]            ;602
000394  f8dff8df          LDR      r11,|L1.1212|
000398  f04ff04f          MOV      r10,#0                ;603
00039c  f1b9f1b9          CMP      r9,#0                 ;603
0003a0  d04b              BEQ      |L1.1082|
0003a2  f1b9f1b9          CMP      r9,#1                 ;603
0003a6  d069              BEQ      |L1.1148|
0003a8  f1b9f1b9          CMP      r9,#2                 ;603
0003ac  d018              BEQ      |L1.992|
0003ae  f1b9f1b9          CMP      r9,#3                 ;603
0003b2  d179              BNE      |L1.1192|
0003b4  8920              LDRH     r0,[r4,#8]            ;621
0003b6  ea00ea00          AND      r8,r0,r7              ;621
0003ba  f1b8f1b8          CMP      r8,#0                 ;622
0003be  d030              BEQ      |L1.1058|
0003c0  2e01              CMP      r6,#1                 ;623
0003c2  d102              BNE      |L1.970|
0003c4  ea20ea20          BIC      r0,r0,r8              ;624
0003c8  8120              STRH     r0,[r4,#8]            ;624
                  |L1.970|
0003ca  f8dbf8db          LDR      r0,[r11,#0]           ;626  ; OSTCBCur
0003ce  f8a0f8a0          STRH     r8,[r0,#0x2c]         ;626
0003d2  9801              LDR      r0,[sp,#4]            ;627
0003d4  f7fff7ff          BL       OS_CPU_SR_Restore
0003d8  f885f885          STRB     r10,[r5,#0]           ;628
0003dc  4640              MOV      r0,r8                 ;629
0003de  e7bd              B        |L1.860|
                  |L1.992|
0003e0  8920              LDRH     r0,[r4,#8]            ;605
0003e2  ea00ea00          AND      r8,r0,r7              ;605
0003e6  45b8              CMP      r8,r7                 ;606
0003e8  d10f              BNE      |L1.1034|
0003ea  2e01              CMP      r6,#1                 ;607
0003ec  d102              BNE      |L1.1012|
0003ee  ea20ea20          BIC      r0,r0,r8              ;608
0003f2  8120              STRH     r0,[r4,#8]            ;608
                  |L1.1012|
0003f4  f8dbf8db          LDR      r0,[r11,#0]           ;610  ; OSTCBCur
0003f8  f8a0f8a0          STRH     r8,[r0,#0x2c]         ;610
0003fc  9801              LDR      r0,[sp,#4]            ;611
0003fe  f7fff7ff          BL       OS_CPU_SR_Restore
000402  f885f885          STRB     r10,[r5,#0]           ;612
000406  4640              MOV      r0,r8                 ;613
000408  e7a8              B        |L1.860|
                  |L1.1034|
00040a  9b0a              LDR      r3,[sp,#0x28]         ;615
00040c  9300              STR      r3,[sp,#0]            ;615
00040e  464b              MOV      r3,r9                 ;615
000410  463a              MOV      r2,r7                 ;615
000412  a902              ADD      r1,sp,#8              ;615
000414  4620              MOV      r0,r4                 ;615
000416  f7fff7ff          BL       OS_FlagBlock
00041a  9801              LDR      r0,[sp,#4]            ;616
00041c  f7fff7ff          BL       OS_CPU_SR_Restore
000420  e05b              B        |L1.1242|
                  |L1.1058|
000422  9b0a              LDR      r3,[sp,#0x28]         ;631
000424  9300              STR      r3,[sp,#0]            ;631
000426  464b              MOV      r3,r9                 ;631
000428  463a              MOV      r2,r7                 ;631
00042a  a902              ADD      r1,sp,#8              ;631
00042c  4620              MOV      r0,r4                 ;631
00042e  f7fff7ff          BL       OS_FlagBlock
000432  9801              LDR      r0,[sp,#4]            ;632
000434  f7fff7ff          BL       OS_CPU_SR_Restore
000438  e04f              B        |L1.1242|
                  |L1.1082|
00043a  8920              LDRH     r0,[r4,#8]            ;638
00043c  ea27ea27          BIC      r8,r7,r0              ;638
000440  45b8              CMP      r8,r7                 ;639
000442  d10f              BNE      |L1.1124|
000444  2e01              CMP      r6,#1                 ;640
000446  d102              BNE      |L1.1102|
000448  ea40ea40          ORR      r0,r0,r8              ;641
00044c  8120              STRH     r0,[r4,#8]            ;641
                  |L1.1102|
00044e  f8dbf8db          LDR      r0,[r11,#0]           ;643  ; OSTCBCur
000452  f8a0f8a0          STRH     r8,[r0,#0x2c]         ;643
000456  9801              LDR      r0,[sp,#4]            ;644
000458  f7fff7ff          BL       OS_CPU_SR_Restore
00045c  f885f885          STRB     r10,[r5,#0]           ;645
000460  4640              MOV      r0,r8                 ;646
000462  e77b              B        |L1.860|
                  |L1.1124|
000464  9b0a              LDR      r3,[sp,#0x28]         ;648
000466  9300              STR      r3,[sp,#0]            ;648
000468  464b              MOV      r3,r9                 ;648
00046a  463a              MOV      r2,r7                 ;648
00046c  a902              ADD      r1,sp,#8              ;648
00046e  4620              MOV      r0,r4                 ;648
000470  f7fff7ff          BL       OS_FlagBlock
000474  9801              LDR      r0,[sp,#4]            ;649
000476  f7fff7ff          BL       OS_CPU_SR_Restore
00047a  e02e              B        |L1.1242|
                  |L1.1148|
00047c  8920              LDRH     r0,[r4,#8]            ;654
00047e  ea27ea27          BIC      r8,r7,r0              ;654
000482  f1b8f1b8          CMP      r8,#0                 ;655
000486  d01d              BEQ      |L1.1220|
000488  2e01              CMP      r6,#1                 ;656
00048a  d102              BNE      |L1.1170|
00048c  ea40ea40          ORR      r0,r0,r8              ;657
000490  8120              STRH     r0,[r4,#8]            ;657
                  |L1.1170|
000492  f8dbf8db          LDR      r0,[r11,#0]           ;659  ; OSTCBCur
000496  f8a0f8a0          STRH     r8,[r0,#0x2c]         ;659
00049a  9801              LDR      r0,[sp,#4]            ;660
00049c  f7fff7ff          BL       OS_CPU_SR_Restore
0004a0  f885f885          STRB     r10,[r5,#0]           ;661
0004a4  4640              MOV      r0,r8                 ;662
0004a6  e759              B        |L1.860|
                  |L1.1192|
0004a8  e036              B        |L1.1304|
0004aa  0000              DCW      0x0000
                  |L1.1196|
0004ac  00000000          DCD      OSIntNesting
                  |L1.1200|
0004b0  00000000          DCD      OSFlagFreeList
                  |L1.1204|
0004b4  00000000          DCD      OSRdyGrp
                  |L1.1208|
0004b8  00000000          DCD      OSRdyTbl
                  |L1.1212|
0004bc  00000000          DCD      OSTCBCur
                  |L1.1216|
0004c0  00000000          DCD      OSLockNesting
                  |L1.1220|
0004c4  9b0a              LDR      r3,[sp,#0x28]         ;664
0004c6  9300              STR      r3,[sp,#0]            ;664
0004c8  464b              MOV      r3,r9                 ;664
0004ca  463a              MOV      r2,r7                 ;664
0004cc  a902              ADD      r1,sp,#8              ;664
0004ce  4620              MOV      r0,r4                 ;664
0004d0  f7fff7ff          BL       OS_FlagBlock
0004d4  9801              LDR      r0,[sp,#4]            ;665
0004d6  f7fff7ff          BL       OS_CPU_SR_Restore
                  |L1.1242|
0004da  f7fff7ff          BL       OS_Sched
0004de  f7fff7ff          BL       OS_CPU_SR_Save
0004e2  4607              MOV      r7,r0                 ;678
0004e4  f8dbf8db          LDR      r0,[r11,#0]           ;679  ; OSTCBCur
0004e8  f890f890          LDRB     r8,[r0,#0x31]         ;679
0004ec  f1b8f1b8          CMP      r8,#0                 ;679
0004f0  d01c              BEQ      |L1.1324|
0004f2  f880f880          STRB     r10,[r0,#0x31]        ;681
0004f6  a802              ADD      r0,sp,#8              ;682
0004f8  f7fff7ff          BL       OS_FlagUnlink
0004fc  f8dbf8db          LDR      r0,[r11,#0]           ;683  ; OSTCBCur
000500  f880f880          STRB     r10,[r0,#0x30]        ;683
000504  4638              MOV      r0,r7                 ;684
000506  f7fff7ff          BL       OS_CPU_SR_Restore
00050a  2000              MOVS     r0,#0                 ;685
00050c  f1b8f1b8          CMP      r8,#2                 ;686
000510  d109              BNE      |L1.1318|
000512  210e              MOVS     r1,#0xe               ;688
000514  7029              STRB     r1,[r5,#0]            ;688
000516  e721              B        |L1.860|
                  |L1.1304|
000518  9801              LDR      r0,[sp,#4]            ;671
00051a  f7fff7ff          BL       OS_CPU_SR_Restore
00051e  2000              MOVS     r0,#0                 ;672
000520  216f              MOVS     r1,#0x6f              ;673
000522  7029              STRB     r1,[r5,#0]            ;673
000524  e71a              B        |L1.860|
                  |L1.1318|
000526  210a              MOVS     r1,#0xa               ;693
000528  7029              STRB     r1,[r5,#0]            ;693
00052a  e717              B        |L1.860|
                  |L1.1324|
00052c  f8b0f8b0          LDRH     r8,[r0,#0x2c]         ;698
000530  2e01              CMP      r6,#1                 ;699
000532  d114              BNE      |L1.1374|
000534  f1b9f1b9          CMP      r9,#0                 ;700
000538  d00d              BEQ      |L1.1366|
00053a  f1b9f1b9          CMP      r9,#1                 ;700
00053e  d00a              BEQ      |L1.1366|
000540  f1b9f1b9          CMP      r9,#2                 ;700
000544  d002              BEQ      |L1.1356|
000546  f1b9f1b9          CMP      r9,#3                 ;700
00054a  d10f              BNE      |L1.1388|
                  |L1.1356|
00054c  8920              LDRH     r0,[r4,#8]            ;703
00054e  ea20ea20          BIC      r0,r0,r8              ;703
000552  8120              STRH     r0,[r4,#8]            ;703
000554  e003              B        |L1.1374|
                  |L1.1366|
000556  8920              LDRH     r0,[r4,#8]            ;709
000558  ea40ea40          ORR      r0,r0,r8              ;709
00055c  8120              STRH     r0,[r4,#8]            ;709
                  |L1.1374|
00055e  4638              MOV      r0,r7                 ;718
000560  f7fff7ff          BL       OS_CPU_SR_Restore
000564  f885f885          STRB     r10,[r5,#0]           ;719
000568  4640              MOV      r0,r8                 ;720
00056a  e6f7              B        |L1.860|
                  |L1.1388|
00056c  4638              MOV      r0,r7                 ;713
00056e  f7fff7ff          BL       OS_CPU_SR_Restore
000572  206f              MOVS     r0,#0x6f              ;714
000574  7028              STRB     r0,[r5,#0]            ;714
000576  2000              MOVS     r0,#0                 ;715
000578  e6f0              B        |L1.860|
;;;722    /*$PAGE*/
                          ENDP

                  OSFlagPendGetFlagsRdy PROC
;;;738    OS_FLAGS  OSFlagPendGetFlagsRdy (void)
;;;739    {
00057a  b510              PUSH     {r4,lr}
;;;740        OS_FLAGS      flags;
;;;741    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;742        OS_CPU_SR     cpu_sr = 0;
;;;743    #endif
;;;744    
;;;745    
;;;746    
;;;747        OS_ENTER_CRITICAL();
00057c  f7fff7ff          BL       OS_CPU_SR_Save
;;;748        flags = OSTCBCur->OSTCBFlagsRdy;
000580  4955              LDR      r1,|L1.1752|
000582  6809              LDR      r1,[r1,#0]  ; OSTCBCur
000584  8d8c              LDRH     r4,[r1,#0x2c]
;;;749        OS_EXIT_CRITICAL();
000586  f7fff7ff          BL       OS_CPU_SR_Restore
;;;750        return (flags);
00058a  4620              MOV      r0,r4
;;;751    }
00058c  bd10              POP      {r4,pc}
;;;752    
                          ENDP

                  OSFlagPost PROC
;;;795    OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
;;;796    {
00058e  e92de92d          PUSH     {r4-r8,lr}
000592  4605              MOV      r5,r0
000594  460e              MOV      r6,r1
000596  4614              MOV      r4,r2
000598  461f              MOV      r7,r3
;;;797        OS_FLAG_NODE *pnode;
;;;798        BOOLEAN       sched;
;;;799        OS_FLAGS      flags_cur;
;;;800        OS_FLAGS      flags_rdy;
;;;801        BOOLEAN       rdy;
;;;802    #if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
;;;803        OS_CPU_SR     cpu_sr = 0;
;;;804    #endif
;;;805    
;;;806    
;;;807    
;;;808    #if OS_ARG_CHK_EN > 0
;;;809        if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
;;;810            return ((OS_FLAGS)0);
;;;811        }
;;;812        if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
;;;813            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;814            return ((OS_FLAGS)0);
;;;815        }
;;;816    #endif
;;;817        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
00059a  7828              LDRB     r0,[r5,#0]
00059c  2805              CMP      r0,#5
00059e  d003              BEQ      |L1.1448|
;;;818            *perr = OS_ERR_EVENT_TYPE;
0005a0  2001              MOVS     r0,#1
0005a2  7038              STRB     r0,[r7,#0]
;;;819            return ((OS_FLAGS)0);
0005a4  2000              MOVS     r0,#0
;;;820        }
;;;821    /*$PAGE*/
;;;822        OS_ENTER_CRITICAL();
;;;823        switch (opt) {
;;;824            case OS_FLAG_CLR:
;;;825                 pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
;;;826                 break;
;;;827    
;;;828            case OS_FLAG_SET:
;;;829                 pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
;;;830                 break;
;;;831    
;;;832            default:
;;;833                 OS_EXIT_CRITICAL();                     /* INVALID option                                 */
;;;834                 *perr = OS_ERR_FLAG_INVALID_OPT;
;;;835                 return ((OS_FLAGS)0);
;;;836        }
;;;837        sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
;;;838        pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
;;;839        while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
;;;840            switch (pnode->OSFlagNodeWaitType) {
;;;841                case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
;;;842                     flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
;;;843                     if (flags_rdy == pnode->OSFlagNodeFlags) {
;;;844                         rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
;;;845                         if (rdy == OS_TRUE) {
;;;846                             sched = OS_TRUE;                     /* When done we will reschedule          */
;;;847                         }
;;;848                     }
;;;849                     break;
;;;850    
;;;851                case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
;;;852                     flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
;;;853                     if (flags_rdy != (OS_FLAGS)0) {
;;;854                         rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
;;;855                         if (rdy == OS_TRUE) {
;;;856                             sched = OS_TRUE;                     /* When done we will reschedule          */
;;;857                         }
;;;858                     }
;;;859                     break;
;;;860    
;;;861    #if OS_FLAG_WAIT_CLR_EN > 0
;;;862                case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
;;;863                     flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
;;;864                     if (flags_rdy == pnode->OSFlagNodeFlags) {
;;;865                         rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
;;;866                         if (rdy == OS_TRUE) {
;;;867                             sched = OS_TRUE;                     /* When done we will reschedule          */
;;;868                         }
;;;869                     }
;;;870                     break;
;;;871    
;;;872                case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
;;;873                     flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
;;;874                     if (flags_rdy != (OS_FLAGS)0) {
;;;875                         rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
;;;876                         if (rdy == OS_TRUE) {
;;;877                             sched = OS_TRUE;                     /* When done we will reschedule          */
;;;878                         }
;;;879                     }
;;;880                     break;
;;;881    #endif
;;;882                default:
;;;883                     OS_EXIT_CRITICAL();
;;;884                     *perr = OS_ERR_FLAG_WAIT_TYPE;
;;;885                     return ((OS_FLAGS)0);
;;;886            }
;;;887            pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
;;;888        }
;;;889        OS_EXIT_CRITICAL();
;;;890        if (sched == OS_TRUE) {
;;;891            OS_Sched();
;;;892        }
;;;893        OS_ENTER_CRITICAL();
;;;894        flags_cur = pgrp->OSFlagFlags;
;;;895        OS_EXIT_CRITICAL();
;;;896        *perr     = OS_ERR_NONE;
;;;897        return (flags_cur);
;;;898    }
0005a6  e537              B        |L1.24|
                  |L1.1448|
0005a8  f7fff7ff          BL       OS_CPU_SR_Save
0005ac  4680              MOV      r8,r0                 ;822
0005ae  b12c              CBZ      r4,|L1.1468|
0005b0  2c01              CMP      r4,#1                 ;823
0005b2  d109              BNE      |L1.1480|
0005b4  8928              LDRH     r0,[r5,#8]            ;829
0005b6  4330              ORRS     r0,r0,r6              ;829
0005b8  8128              STRH     r0,[r5,#8]            ;829
0005ba  e002              B        |L1.1474|
                  |L1.1468|
0005bc  8928              LDRH     r0,[r5,#8]            ;825
0005be  43b0              BICS     r0,r0,r6              ;825
0005c0  8128              STRH     r0,[r5,#8]            ;825
                  |L1.1474|
0005c2  2600              MOVS     r6,#0                 ;837
0005c4  686c              LDR      r4,[r5,#4]            ;838
0005c6  e03d              B        |L1.1604|
                  |L1.1480|
0005c8  4640              MOV      r0,r8                 ;833
0005ca  f7fff7ff          BL       OS_CPU_SR_Restore
0005ce  2071              MOVS     r0,#0x71              ;834
0005d0  7038              STRB     r0,[r7,#0]            ;834
0005d2  2000              MOVS     r0,#0                 ;835
0005d4  e520              B        |L1.24|
                  |L1.1494|
0005d6  7ca1              LDRB     r1,[r4,#0x12]         ;840
0005d8  b1e1              CBZ      r1,|L1.1556|
0005da  2901              CMP      r1,#1                 ;840
0005dc  d027              BEQ      |L1.1582|
0005de  2902              CMP      r1,#2                 ;840
0005e0  d00c              BEQ      |L1.1532|
0005e2  2903              CMP      r1,#3                 ;840
0005e4  d140              BNE      |L1.1640|
0005e6  8929              LDRH     r1,[r5,#8]            ;852
0005e8  8a20              LDRH     r0,[r4,#0x10]         ;852
0005ea  4001              ANDS     r1,r1,r0              ;852
0005ec  b349              CBZ      r1,|L1.1602|
0005ee  4620              MOV      r0,r4                 ;854
0005f0  f7fff7ff          BL       OS_FlagTaskRdy
0005f4  2801              CMP      r0,#1                 ;855
0005f6  d124              BNE      |L1.1602|
0005f8  2601              MOVS     r6,#1                 ;856
0005fa  e022              B        |L1.1602|
                  |L1.1532|
0005fc  8929              LDRH     r1,[r5,#8]            ;842
0005fe  8a20              LDRH     r0,[r4,#0x10]         ;842
000600  4001              ANDS     r1,r1,r0              ;842
000602  4288              CMP      r0,r1                 ;843
000604  d11d              BNE      |L1.1602|
000606  4620              MOV      r0,r4                 ;844
000608  f7fff7ff          BL       OS_FlagTaskRdy
00060c  2801              CMP      r0,#1                 ;845
00060e  d118              BNE      |L1.1602|
000610  2601              MOVS     r6,#1                 ;846
000612  e016              B        |L1.1602|
                  |L1.1556|
000614  8a20              LDRH     r0,[r4,#0x10]         ;863
000616  8929              LDRH     r1,[r5,#8]            ;863
000618  ea20ea20          BIC      r1,r0,r1              ;863
00061c  4288              CMP      r0,r1                 ;864
00061e  d110              BNE      |L1.1602|
000620  4620              MOV      r0,r4                 ;865
000622  f7fff7ff          BL       OS_FlagTaskRdy
000626  2801              CMP      r0,#1                 ;866
000628  d10b              BNE      |L1.1602|
00062a  2601              MOVS     r6,#1                 ;867
00062c  e009              B        |L1.1602|
                  |L1.1582|
00062e  8a21              LDRH     r1,[r4,#0x10]         ;873
000630  8928              LDRH     r0,[r5,#8]            ;873
000632  4381              BICS     r1,r1,r0              ;873
000634  b129              CBZ      r1,|L1.1602|
000636  4620              MOV      r0,r4                 ;875
000638  f7fff7ff          BL       OS_FlagTaskRdy
00063c  2801              CMP      r0,#1                 ;876
00063e  d100              BNE      |L1.1602|
000640  2601              MOVS     r6,#1                 ;877
                  |L1.1602|
000642  6824              LDR      r4,[r4,#0]            ;887
                  |L1.1604|
000644  2c00              CMP      r4,#0                 ;839
000646  d1c6              BNE      |L1.1494|
000648  4640              MOV      r0,r8                 ;889
00064a  f7fff7ff          BL       OS_CPU_SR_Restore
00064e  2e01              CMP      r6,#1                 ;890
000650  d101              BNE      |L1.1622|
000652  f7fff7ff          BL       OS_Sched
                  |L1.1622|
000656  f7fff7ff          BL       OS_CPU_SR_Save
00065a  892c              LDRH     r4,[r5,#8]            ;894
00065c  f7fff7ff          BL       OS_CPU_SR_Restore
000660  2000              MOVS     r0,#0                 ;896
000662  7038              STRB     r0,[r7,#0]            ;896
000664  4620              MOV      r0,r4                 ;897
000666  e4d7              B        |L1.24|
                  |L1.1640|
000668  4640              MOV      r0,r8                 ;883
00066a  f7fff7ff          BL       OS_CPU_SR_Restore
00066e  206f              MOVS     r0,#0x6f              ;884
000670  7038              STRB     r0,[r7,#0]            ;884
000672  2000              MOVS     r0,#0                 ;885
000674  e4d0              B        |L1.24|
;;;899    /*$PAGE*/
                          ENDP

                  OSFlagQuery PROC
;;;920    OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
;;;921    {
000676  b570              PUSH     {r4-r6,lr}
000678  4605              MOV      r5,r0
00067a  460c              MOV      r4,r1
;;;922        OS_FLAGS   flags;
;;;923    #if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
;;;924        OS_CPU_SR  cpu_sr = 0;
;;;925    #endif
;;;926    
;;;927    
;;;928    
;;;929    #if OS_ARG_CHK_EN > 0
;;;930        if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
;;;931            return ((OS_FLAGS)0);
;;;932        }
;;;933        if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
;;;934            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;935            return ((OS_FLAGS)0);
;;;936        }
;;;937    #endif
;;;938        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
00067c  7828              LDRB     r0,[r5,#0]
00067e  2805              CMP      r0,#5
000680  d003              BEQ      |L1.1674|
;;;939            *perr = OS_ERR_EVENT_TYPE;
000682  2001              MOVS     r0,#1
000684  7020              STRB     r0,[r4,#0]
;;;940            return ((OS_FLAGS)0);
000686  2000              MOVS     r0,#0
;;;941        }
;;;942        OS_ENTER_CRITICAL();
;;;943        flags = pgrp->OSFlagFlags;
;;;944        OS_EXIT_CRITICAL();
;;;945        *perr = OS_ERR_NONE;
;;;946        return (flags);                               /* Return the current value of the event flags       */
;;;947    }
000688  bd70              POP      {r4-r6,pc}
                  |L1.1674|
00068a  f7fff7ff          BL       OS_CPU_SR_Save
00068e  892d              LDRH     r5,[r5,#8]            ;943
000690  f7fff7ff          BL       OS_CPU_SR_Restore
000694  2000              MOVS     r0,#0                 ;945
000696  7020              STRB     r0,[r4,#0]            ;945
000698  4628              MOV      r0,r5                 ;946
00069a  bd70              POP      {r4-r6,pc}
;;;948    #endif
                          ENDP

                  OS_FlagInit PROC
;;;1035   void  OS_FlagInit (void)
;;;1036   {
00069c  b510              PUSH     {r4,lr}
;;;1037   #if OS_MAX_FLAGS == 1
;;;1038       OSFlagFreeList                 = (OS_FLAG_GRP *)&OSFlagTbl[0];  /* Only ONE event flag group!      */
;;;1039       OSFlagFreeList->OSFlagType     = OS_EVENT_TYPE_UNUSED;
;;;1040       OSFlagFreeList->OSFlagWaitList = (void *)0;
;;;1041       OSFlagFreeList->OSFlagFlags    = (OS_FLAGS)0;
;;;1042   #if OS_FLAG_NAME_SIZE > 1
;;;1043       OSFlagFreeList->OSFlagName[0]  = '?';
;;;1044       OSFlagFreeList->OSFlagName[1]  = OS_ASCII_NUL;
;;;1045   #endif
;;;1046   #endif
;;;1047   
;;;1048   #if OS_MAX_FLAGS >= 2
;;;1049       INT16U       i;
;;;1050       OS_FLAG_GRP *pgrp1;
;;;1051       OS_FLAG_GRP *pgrp2;
;;;1052   
;;;1053   
;;;1054       OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
00069e  218c              MOVS     r1,#0x8c
0006a0  480e              LDR      r0,|L1.1756|
0006a2  f7fff7ff          BL       OS_MemClr
;;;1055       pgrp1 = &OSFlagTbl[0];
0006a6  480d              LDR      r0,|L1.1756|
;;;1056       pgrp2 = &OSFlagTbl[1];
0006a8  f100f100          ADD      r2,r0,#0x1c
;;;1057       for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
0006ac  2100              MOVS     r1,#0
0006ae  2300              MOVS     r3,#0
0006b0  243f              MOVS     r4,#0x3f
                  |L1.1714|
;;;1058           pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
0006b2  7003              STRB     r3,[r0,#0]
;;;1059           pgrp1->OSFlagWaitList = (void *)pgrp2;
0006b4  6042              STR      r2,[r0,#4]
;;;1060   #if OS_FLAG_NAME_SIZE > 1
;;;1061           pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
0006b6  7284              STRB     r4,[r0,#0xa]
;;;1062           pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
0006b8  72c3              STRB     r3,[r0,#0xb]
;;;1063   #endif
;;;1064           pgrp1++;
0006ba  301c              ADDS     r0,r0,#0x1c
;;;1065           pgrp2++;
0006bc  321c              ADDS     r2,r2,#0x1c
0006be  1c49              ADDS     r1,r1,#1              ;1057
0006c0  b289              UXTH     r1,r1                 ;1057
0006c2  2904              CMP      r1,#4                 ;1057
0006c4  d3f5              BCC      |L1.1714|
;;;1066       }
;;;1067       pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
0006c6  7003              STRB     r3,[r0,#0]
;;;1068       pgrp1->OSFlagWaitList = (void *)0;
0006c8  6043              STR      r3,[r0,#4]
;;;1069   #if OS_FLAG_NAME_SIZE > 1
;;;1070       pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
0006ca  7284              STRB     r4,[r0,#0xa]
;;;1071       pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
0006cc  72c3              STRB     r3,[r0,#0xb]
;;;1072   #endif
;;;1073       OSFlagFreeList        = &OSFlagTbl[0];
0006ce  4904              LDR      r1,|L1.1760|
0006d0  4802              LDR      r0,|L1.1756|
0006d2  6008              STR      r0,[r1,#0]  ; OSFlagFreeList
;;;1074   #endif
;;;1075   }
0006d4  bd10              POP      {r4,pc}
;;;1076   
                          ENDP

0006d6  0000              DCW      0x0000
                  |L1.1752|
0006d8  00000000          DCD      OSTCBCur
                  |L1.1756|
0006dc  00000000          DCD      OSFlagTbl
                  |L1.1760|
0006e0  00000000          DCD      OSFlagFreeList
