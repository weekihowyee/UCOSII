; generated by ARM/Thumb C/C++ Compiler with , RVCT3.1 [Build 919] for uVision
; commandline ArmCC [--debug -c --asm --interleave -o.\output\os_core.o --depend=.\output\os_core.d --device=DARMSTM --apcs=interwork -O1 -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -IC:\Keil\ARM\INC\ST\STM32F10x --omf_browse=.\output\os_core.crf ..\..\..\..\..\uCOS-II\Source\os_core.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  OS_StrCopy PROC
;;;1700   
;;;1701       len = 0;
000000  2200              MOVS     r2,#0
;;;1702       while (*psrc != OS_ASCII_NUL) {
000002  e004              B        |L1.14|
                  |L1.4|
;;;1703           *pdest++ = *psrc++;
000004  f800f800          STRB     r3,[r0],#1
000008  1c49              ADDS     r1,r1,#1
;;;1704           len++;
00000a  1c52              ADDS     r2,r2,#1
00000c  b2d2              UXTB     r2,r2
                  |L1.14|
00000e  780b              LDRB     r3,[r1,#0]            ;1702
000010  2b00              CMP      r3,#0                 ;1702
000012  d1f7              BNE      |L1.4|
;;;1705       }
;;;1706       *pdest = OS_ASCII_NUL;
000014  2100              MOVS     r1,#0
000016  7001              STRB     r1,[r0,#0]
;;;1707       return (len);
000018  4610              MOV      r0,r2
;;;1708   }
00001a  4770              BX       lr
;;;1709   #endif
                          ENDP

                  OSEventNameGet PROC
;;;109    INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
;;;110    {
00001c  e92de92d          PUSH     {r4-r8,lr}
000020  4605              MOV      r5,r0
000022  460e              MOV      r6,r1
000024  4614              MOV      r4,r2
;;;111        INT8U      len;
;;;112    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;113        OS_CPU_SR  cpu_sr = 0;
;;;114    #endif
;;;115    
;;;116    
;;;117    
;;;118    #if OS_ARG_CHK_EN > 0
;;;119        if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
;;;120            return (0);
;;;121        }
;;;122        if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
;;;123            *perr = OS_ERR_PEVENT_NULL;
;;;124            return (0);
;;;125        }
;;;126        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;127            *perr = OS_ERR_PNAME_NULL;
;;;128            return (0);
;;;129        }
;;;130    #endif
;;;131        if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
000026  48ff              LDR      r0,|L1.1060|
000028  7880              LDRB     r0,[r0,#2]  ; OSIntNesting
00002a  b120              CBZ      r0,|L1.54|
;;;132            *perr  = OS_ERR_NAME_GET_ISR;
00002c  2011              MOVS     r0,#0x11
00002e  7020              STRB     r0,[r4,#0]
;;;133            return (0);
000030  2000              MOVS     r0,#0
                  |L1.50|
;;;134        }
;;;135        switch (pevent->OSEventType) {
;;;136            case OS_EVENT_TYPE_SEM:
;;;137            case OS_EVENT_TYPE_MUTEX:
;;;138            case OS_EVENT_TYPE_MBOX:
;;;139            case OS_EVENT_TYPE_Q:
;;;140                 break;
;;;141    
;;;142            default:
;;;143                 *perr = OS_ERR_EVENT_TYPE;
;;;144                 return (0);
;;;145        }
;;;146        OS_ENTER_CRITICAL();
;;;147        len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
;;;148        OS_EXIT_CRITICAL();
;;;149        *perr = OS_ERR_NONE;
;;;150        return (len);
;;;151    }
000032  e8bde8bd          POP      {r4-r8,pc}
                  |L1.54|
000036  7828              LDRB     r0,[r5,#0]            ;135
000038  2801              CMP      r0,#1                 ;135
00003a  d005              BEQ      |L1.72|
00003c  2802              CMP      r0,#2                 ;135
00003e  d003              BEQ      |L1.72|
000040  2803              CMP      r0,#3                 ;135
000042  d001              BEQ      |L1.72|
000044  2804              CMP      r0,#4                 ;135
000046  d10f              BNE      |L1.104|
                  |L1.72|
000048  f7fff7ff          BL       OS_CPU_SR_Save
00004c  4607              MOV      r7,r0                 ;146
00004e  f105f105          ADD      r1,r5,#0xf            ;147
000052  4630              MOV      r0,r6                 ;147
000054  f7fff7ff          BL       OS_StrCopy
000058  4605              MOV      r5,r0                 ;147
00005a  4638              MOV      r0,r7                 ;148
00005c  f7fff7ff          BL       OS_CPU_SR_Restore
000060  2000              MOVS     r0,#0                 ;149
000062  7020              STRB     r0,[r4,#0]            ;149
000064  4628              MOV      r0,r5                 ;150
000066  e7e4              B        |L1.50|
                  |L1.104|
000068  2001              MOVS     r0,#1                 ;143
00006a  7020              STRB     r0,[r4,#0]            ;143
00006c  2000              MOVS     r0,#0                 ;144
00006e  e7e0              B        |L1.50|
;;;152    #endif
                          ENDP

                  OS_StrLen PROC
;;;1732   
;;;1733       len = 0;
000070  2100              MOVS     r1,#0
;;;1734       while (*psrc != OS_ASCII_NUL) {
000072  e002              B        |L1.122|
                  |L1.116|
;;;1735           psrc++;
000074  1c40              ADDS     r0,r0,#1
;;;1736           len++;
000076  1c49              ADDS     r1,r1,#1
000078  b2c9              UXTB     r1,r1
                  |L1.122|
00007a  7802              LDRB     r2,[r0,#0]            ;1734
00007c  2a00              CMP      r2,#0                 ;1734
00007e  d1f9              BNE      |L1.116|
;;;1737       }
;;;1738       return (len);
000080  4608              MOV      r0,r1
;;;1739   }
000082  4770              BX       lr
;;;1740   #endif
                          ENDP

                  OSEventNameSet PROC
;;;183    void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
;;;184    {
000084  e92de92d          PUSH     {r4-r8,lr}
000088  4605              MOV      r5,r0
00008a  460e              MOV      r6,r1
00008c  4614              MOV      r4,r2
;;;185        INT8U      len;
;;;186    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;187        OS_CPU_SR  cpu_sr = 0;
;;;188    #endif
;;;189    
;;;190    
;;;191    
;;;192    #if OS_ARG_CHK_EN > 0
;;;193        if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
;;;194            return;
;;;195        }
;;;196        if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
;;;197            *perr = OS_ERR_PEVENT_NULL;
;;;198            return;
;;;199        }
;;;200        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;201            *perr = OS_ERR_PNAME_NULL;
;;;202            return;
;;;203        }
;;;204    #endif
;;;205        if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
00008e  48e5              LDR      r0,|L1.1060|
000090  7880              LDRB     r0,[r0,#2]  ; OSIntNesting
000092  b110              CBZ      r0,|L1.154|
;;;206            *perr = OS_ERR_NAME_SET_ISR;
000094  2012              MOVS     r0,#0x12
000096  7020              STRB     r0,[r4,#0]
;;;207            return;
;;;208        }
;;;209        switch (pevent->OSEventType) {
;;;210            case OS_EVENT_TYPE_SEM:
;;;211            case OS_EVENT_TYPE_MUTEX:
;;;212            case OS_EVENT_TYPE_MBOX:
;;;213            case OS_EVENT_TYPE_Q:
;;;214                 break;
;;;215    
;;;216            default:
;;;217                 *perr = OS_ERR_EVENT_TYPE;
;;;218                 return;
;;;219        }
;;;220        OS_ENTER_CRITICAL();
;;;221        len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
;;;222        if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
;;;223            OS_EXIT_CRITICAL();
;;;224            *perr = OS_ERR_EVENT_NAME_TOO_LONG;
;;;225            return;
;;;226        }
;;;227        (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
;;;228        OS_EXIT_CRITICAL();
;;;229        *perr = OS_ERR_NONE;
;;;230    }
000098  e7cb              B        |L1.50|
                  |L1.154|
00009a  7828              LDRB     r0,[r5,#0]            ;209
00009c  2801              CMP      r0,#1                 ;209
00009e  d005              BEQ      |L1.172|
0000a0  2802              CMP      r0,#2                 ;209
0000a2  d003              BEQ      |L1.172|
0000a4  2803              CMP      r0,#3                 ;209
0000a6  d001              BEQ      |L1.172|
0000a8  2804              CMP      r0,#4                 ;209
0000aa  d10d              BNE      |L1.200|
                  |L1.172|
0000ac  f7fff7ff          BL       OS_CPU_SR_Save
0000b0  4607              MOV      r7,r0                 ;220
0000b2  4630              MOV      r0,r6                 ;221
0000b4  f7fff7ff          BL       OS_StrLen
0000b8  280f              CMP      r0,#0xf               ;222
0000ba  d908              BLS      |L1.206|
0000bc  4638              MOV      r0,r7                 ;223
0000be  f7fff7ff          BL       OS_CPU_SR_Restore
0000c2  200b              MOVS     r0,#0xb               ;224
0000c4  7020              STRB     r0,[r4,#0]            ;224
0000c6  e7b4              B        |L1.50|
                  |L1.200|
0000c8  2001              MOVS     r0,#1                 ;217
0000ca  7020              STRB     r0,[r4,#0]            ;217
0000cc  e7b1              B        |L1.50|
                  |L1.206|
0000ce  4631              MOV      r1,r6                 ;227
0000d0  f105f105          ADD      r0,r5,#0xf            ;227
0000d4  f7fff7ff          BL       OS_StrCopy
0000d8  4638              MOV      r0,r7                 ;228
0000da  f7fff7ff          BL       OS_CPU_SR_Restore
0000de  2000              MOVS     r0,#0                 ;229
0000e0  7020              STRB     r0,[r4,#0]            ;229
0000e2  e7a6              B        |L1.50|
;;;231    #endif
                          ENDP

                  OS_EventTaskRemoveMulti PROC
;;;1165                                  OS_EVENT **pevents_multi)
;;;1166   {
0000e4  b570              PUSH     {r4-r6,lr}
;;;1167       OS_EVENT **pevents;
;;;1168       OS_EVENT  *pevent;
;;;1169       INT8U      y;
;;;1170   #if (OS_LOWEST_PRIO <= 63)
;;;1171       INT8U      bity;
;;;1172       INT8U      bitx;
;;;1173   #else
;;;1174       INT16U     bity;
;;;1175       INT16U     bitx;
;;;1176   #endif
;;;1177   
;;;1178   
;;;1179       y       =  ptcb->OSTCBY;
0000e6  f810f810          LDRB     r4,[r0,#0x34]!
;;;1180       bity    =  ptcb->OSTCBBitY;
0000ea  7885              LDRB     r5,[r0,#2]
;;;1181       bitx    =  ptcb->OSTCBBitX;
0000ec  7846              LDRB     r6,[r0,#1]
;;;1182       pevents =  pevents_multi;
;;;1183       pevent  = *pevents;
0000ee  6808              LDR      r0,[r1,#0]
;;;1184       while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
0000f0  e00a              B        |L1.264|
                  |L1.242|
;;;1185           pevent->OSEventTbl[y]  &= ~bitx;
0000f2  1902              ADDS     r2,r0,r4
0000f4  7ad3              LDRB     r3,[r2,#0xb]
0000f6  43b3              BICS     r3,r3,r6
0000f8  72d3              STRB     r3,[r2,#0xb]
;;;1186           if (pevent->OSEventTbl[y] == 0) {
0000fa  7ad2              LDRB     r2,[r2,#0xb]
0000fc  b912              CBNZ     r2,|L1.260|
;;;1187               pevent->OSEventGrp &= ~bity;
0000fe  7a82              LDRB     r2,[r0,#0xa]
000100  43aa              BICS     r2,r2,r5
000102  7282              STRB     r2,[r0,#0xa]
                  |L1.260|
;;;1188           }
;;;1189           pevents++;
;;;1190           pevent = *pevents;
000104  f851f851          LDR      r0,[r1,#4]!
                  |L1.264|
000108  2800              CMP      r0,#0                 ;1184
00010a  d1f2              BNE      |L1.242|
;;;1191       }
;;;1192   }
00010c  bd70              POP      {r4-r6,pc}
;;;1193   #endif
                          ENDP

                  OS_SchedNew PROC
;;;1653   
;;;1654       y             = OSUnMapTbl[OSRdyGrp];
00010e  49c5              LDR      r1,|L1.1060|
000110  4ac5              LDR      r2,|L1.1064|
000112  7988              LDRB     r0,[r1,#6]  ; OSRdyGrp
000114  5c10              LDRB     r0,[r2,r0]
;;;1655       OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
000116  f101f101          ADD      r3,r1,#0x1c
00011a  5c1b              LDRB     r3,[r3,r0]
00011c  5cd2              LDRB     r2,[r2,r3]
00011e  eb02eb02          ADD      r0,r2,r0,LSL #3
000122  7148              STRB     r0,[r1,#5]  ; OSPrioHighRdy
;;;1656   #else                                            /* We support up to 256 tasks                         */
;;;1657       INT8U   y;
;;;1658       INT16U *ptbl;
;;;1659   
;;;1660   
;;;1661       if ((OSRdyGrp & 0xFF) != 0) {
;;;1662           y = OSUnMapTbl[OSRdyGrp & 0xFF];
;;;1663       } else {
;;;1664           y = OSUnMapTbl[(OSRdyGrp >> 8) & 0xFF] + 8;
;;;1665       }
;;;1666       ptbl = &OSRdyTbl[y];
;;;1667       if ((*ptbl & 0xFF) != 0) {
;;;1668           OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
;;;1669       } else {
;;;1670           OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
;;;1671       }
;;;1672   #endif
;;;1673   }
000124  4770              BX       lr
;;;1674   
                          ENDP

                  OS_Sched PROC
;;;1606   void  OS_Sched (void)
;;;1607   {
000126  b570              PUSH     {r4-r6,lr}
;;;1608   #if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
;;;1609       OS_CPU_SR  cpu_sr = 0;
;;;1610   #endif
;;;1611   
;;;1612   
;;;1613   
;;;1614       OS_ENTER_CRITICAL();
000128  f7fff7ff          BL       OS_CPU_SR_Save
00012c  4605              MOV      r5,r0
;;;1615       if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
00012e  4cbd              LDR      r4,|L1.1060|
000130  78a0              LDRB     r0,[r4,#2]  ; OSIntNesting
000132  b998              CBNZ     r0,|L1.348|
;;;1616           if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
000134  78e0              LDRB     r0,[r4,#3]  ; OSLockNesting
000136  b988              CBNZ     r0,|L1.348|
;;;1617               OS_SchedNew();
000138  f7fff7ff          BL       OS_SchedNew
;;;1618               if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
00013c  7961              LDRB     r1,[r4,#5]  ; OSPrioHighRdy
00013e  7920              LDRB     r0,[r4,#4]  ; OSPrioCur
000140  4281              CMP      r1,r0
000142  d00b              BEQ      |L1.348|
;;;1619                   OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
000144  48b9              LDR      r0,|L1.1068|
000146  f850f850          LDR      r1,[r0,r1,LSL #2]
00014a  62e1              STR      r1,[r4,#0x2c]  ; OSTCBHighRdy
;;;1620   #if OS_TASK_PROFILE_EN > 0
;;;1621                   OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
00014c  6b88              LDR      r0,[r1,#0x38]
00014e  1c40              ADDS     r0,r0,#1
000150  6388              STR      r0,[r1,#0x38]
;;;1622   #endif
;;;1623                   OSCtxSwCtr++;                          /* Increment context switch counter             */
000152  68e0              LDR      r0,[r4,#0xc]  ; OSCtxSwCtr
000154  1c40              ADDS     r0,r0,#1
000156  60e0              STR      r0,[r4,#0xc]  ; OSCtxSwCtr
;;;1624                   OS_TASK_SW();                          /* Perform a context switch                     */
000158  f7fff7ff          BL       OSCtxSw
                  |L1.348|
;;;1625               }
;;;1626           }
;;;1627       }
;;;1628       OS_EXIT_CRITICAL();
00015c  4628              MOV      r0,r5
00015e  e8bde8bd          POP      {r4-r6,lr}
000162  f7fff7ff          B.W      OS_CPU_SR_Restore
;;;1629   }
;;;1630   
                          ENDP

                  OS_EventTaskWaitMulti PROC
;;;1091   void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
;;;1092   {
000166  b570              PUSH     {r4-r6,lr}
;;;1093       OS_EVENT **pevents;
;;;1094       OS_EVENT  *pevent;
;;;1095       INT8U      y;
;;;1096   
;;;1097   
;;;1098       OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
000168  4dae              LDR      r5,|L1.1060|
00016a  2200              MOVS     r2,#0
00016c  6a69              LDR      r1,[r5,#0x24]  ; OSTCBCur
00016e  61ca              STR      r2,[r1,#0x1c]
;;;1099       OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
000170  6208              STR      r0,[r1,#0x20]
;;;1100   
;;;1101       pevents =  pevents_wait;
;;;1102       pevent  = *pevents;
000172  6801              LDR      r1,[r0,#0]
;;;1103       while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
000174  e010              B        |L1.408|
                  |L1.374|
;;;1104           pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
000176  6a6b              LDR      r3,[r5,#0x24]  ; OSTCBCur
000178  f101f101          ADD      r2,r1,#0xb
00017c  f813f813          LDRB     r4,[r3,#0x34]!
000180  785b              LDRB     r3,[r3,#1]
000182  5ca6              LDRB     r6,[r4,r2]
000184  431e              ORRS     r6,r6,r3
000186  54a6              STRB     r6,[r4,r2]
;;;1105           pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
000188  6a6b              LDR      r3,[r5,#0x24]  ; OSTCBCur
00018a  7a8a              LDRB     r2,[r1,#0xa]
00018c  f893f893          LDRB     r3,[r3,#0x36]
000190  431a              ORRS     r2,r2,r3
000192  728a              STRB     r2,[r1,#0xa]
;;;1106           pevents++;
;;;1107           pevent = *pevents;
000194  f850f850          LDR      r1,[r0,#4]!
                  |L1.408|
000198  2900              CMP      r1,#0                 ;1103
00019a  d1ec              BNE      |L1.374|
;;;1108       }
;;;1109   
;;;1110       y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
00019c  6a69              LDR      r1,[r5,#0x24]  ; OSTCBCur
00019e  f891f891          LDRB     r0,[r1,#0x34]
;;;1111       OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
0001a2  4aa0              LDR      r2,|L1.1060|
0001a4  f891f891          LDRB     r4,[r1,#0x35]
0001a8  321c              ADDS     r2,r2,#0x1c
0001aa  5c13              LDRB     r3,[r2,r0]
0001ac  43a3              BICS     r3,r3,r4
0001ae  5413              STRB     r3,[r2,r0]
;;;1112       if (OSRdyTbl[y] == 0) {
0001b0  5c10              LDRB     r0,[r2,r0]
0001b2  2800              CMP      r0,#0
0001b4  d104              BNE      |L1.448|
;;;1113           OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
0001b6  f891f891          LDRB     r1,[r1,#0x36]
0001ba  79a8              LDRB     r0,[r5,#6]  ; OSRdyGrp
0001bc  4388              BICS     r0,r0,r1
0001be  71a8              STRB     r0,[r5,#6]  ; OSRdyGrp
                  |L1.448|
;;;1114       }
;;;1115   }
0001c0  bd70              POP      {r4-r6,pc}
;;;1116   #endif
                          ENDP

                  OSEventPendMulti PROC
;;;306    INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
;;;307    {
0001c2  e92de92d          PUSH     {r0-r12,lr}
0001c6  f8ddf8dd          LDR      r8,[sp,#0x38]
0001ca  460d              MOV      r5,r1
0001cc  4616              MOV      r6,r2
;;;308        OS_EVENT  **pevents;
;;;309        OS_EVENT   *pevent;
;;;310    #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
;;;311        OS_Q       *pq;
;;;312    #endif
;;;313        BOOLEAN     events_rdy;
;;;314        INT16U      events_rdy_nbr;
;;;315        INT8U       events_stat;
;;;316    #if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
;;;317        OS_CPU_SR   cpu_sr = 0;
;;;318    #endif
;;;319    
;;;320    
;;;321    
;;;322    #if (OS_ARG_CHK_EN > 0)
;;;323        if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
;;;324            return (0);
;;;325        }
;;;326        if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
;;;327           *perr =  OS_ERR_PEVENT_NULL;
;;;328            return (0);
;;;329        }
;;;330        if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
;;;331           *perr =  OS_ERR_PEVENT_NULL;
;;;332            return (0);
;;;333        }
;;;334        if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
;;;335           *perr =  OS_ERR_PEVENT_NULL;
;;;336            return (0);
;;;337        }
;;;338    #endif
;;;339    
;;;340       *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
0001ce  f04ff04f          MOV      r9,#0
0001d2  f8c5f8c5          STR      r9,[r5,#0]
;;;341    
;;;342        pevents     =  pevents_pend;
0001d6  9800              LDR      r0,[sp,#0]
;;;343        pevent      = *pevents;
0001d8  6801              LDR      r1,[r0,#0]
;;;344        while  (pevent != (OS_EVENT *)0) {
0001da  f04ff04f          MOV      r11,#1
0001de  e00c              B        |L1.506|
                  |L1.480|
;;;345            switch (pevent->OSEventType) {                  /* Validate event block types                  */
0001e0  7809              LDRB     r1,[r1,#0]
0001e2  2901              CMP      r1,#1
0001e4  d007              BEQ      |L1.502|
0001e6  2903              CMP      r1,#3
0001e8  d005              BEQ      |L1.502|
;;;346    #if (OS_SEM_EN  > 0)
;;;347                case OS_EVENT_TYPE_SEM:
;;;348                     break;
;;;349    #endif
;;;350    #if (OS_MBOX_EN > 0)
;;;351                case OS_EVENT_TYPE_MBOX:
;;;352                     break;
;;;353    #endif
;;;354    #if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
;;;355                case OS_EVENT_TYPE_Q:
;;;356                     break;
;;;357    #endif
;;;358    
;;;359                case OS_EVENT_TYPE_MUTEX:                                            
;;;360                case OS_EVENT_TYPE_FLAG:
;;;361                default:           
;;;362                    *perr = OS_ERR_EVENT_TYPE;
0001ea  f888f888          STRB     r11,[r8,#0]
;;;363                     return (0);
0001ee  2000              MOVS     r0,#0
                  |L1.496|
;;;364            }
;;;365            pevents++;
;;;366            pevent = *pevents;
;;;367        }
;;;368    
;;;369        if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
;;;370           *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
;;;371            return (0);
;;;372        }
;;;373        if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
;;;374           *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
;;;375            return (0);
;;;376        }
;;;377    
;;;378    /*$PAGE*/
;;;379        OS_ENTER_CRITICAL();
;;;380        events_rdy     =  OS_FALSE;
;;;381        events_rdy_nbr =  0;
;;;382        events_stat    =  OS_STAT_RDY;
;;;383        pevents        =  pevents_pend;
;;;384        pevent         = *pevents;
;;;385        while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
;;;386            switch (pevent->OSEventType) {
;;;387    #if (OS_SEM_EN > 0)
;;;388                case OS_EVENT_TYPE_SEM:
;;;389                     if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
;;;390                         pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
;;;391                        *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
;;;392                          events_rdy   =  OS_TRUE;
;;;393                        *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
;;;394                          events_rdy_nbr++;
;;;395    
;;;396                     } else {
;;;397                          events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
;;;398                     }
;;;399                     break;
;;;400    #endif
;;;401    
;;;402    #if (OS_MBOX_EN > 0)
;;;403                case OS_EVENT_TYPE_MBOX:
;;;404                     if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
;;;405                                                            /* ... return available message,           ... */
;;;406                        *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
;;;407                         pevent->OSEventPtr  = (void *)0;
;;;408                        *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
;;;409                          events_rdy         =  OS_TRUE;
;;;410                          events_rdy_nbr++;
;;;411    
;;;412                     } else {
;;;413                          events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
;;;414                     }
;;;415                     break;
;;;416    #endif
;;;417    
;;;418    #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
;;;419                case OS_EVENT_TYPE_Q:
;;;420                     pq = (OS_Q *)pevent->OSEventPtr;
;;;421                     if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
;;;422                                                            /* ... return available message,           ... */
;;;423                        *pmsgs_rdy++ = (void *)*pq->OSQOut++;
;;;424                         if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
;;;425                             pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
;;;426                         }
;;;427                         pq->OSQEntries--;                  /* Update number of queue entries              */
;;;428                        *pevents_rdy++ = pevent;            /* ... and return available queue event        */
;;;429                          events_rdy   = OS_TRUE;
;;;430                          events_rdy_nbr++;
;;;431    
;;;432                     } else {
;;;433                          events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
;;;434                     }
;;;435                     break;
;;;436    #endif
;;;437    
;;;438                case OS_EVENT_TYPE_MUTEX:                                            
;;;439                case OS_EVENT_TYPE_FLAG:
;;;440                default:           
;;;441                     OS_EXIT_CRITICAL();
;;;442                    *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
;;;443                    *perr        =  OS_ERR_EVENT_TYPE;
;;;444                     return (events_rdy_nbr);
;;;445            }
;;;446            pevents++;
;;;447            pevent = *pevents;
;;;448        }
;;;449    
;;;450        if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
;;;451           *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
;;;452            OS_EXIT_CRITICAL();
;;;453           *perr        =  OS_ERR_NONE;
;;;454            return (events_rdy_nbr);
;;;455        }
;;;456    /*$PAGE*/
;;;457                                                            /* Otherwise, must wait until any event occurs */
;;;458        OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
;;;459                                   OS_STAT_MULTI;           /* ... pend on multiple events                 */
;;;460        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;461        OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
;;;462        OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
;;;463    
;;;464        OS_EXIT_CRITICAL();
;;;465        OS_Sched();                                         /* Find next highest priority task ready       */
;;;466        OS_ENTER_CRITICAL();
;;;467    
;;;468        switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
;;;469            case OS_STAT_PEND_OK:
;;;470            case OS_STAT_PEND_ABORT:
;;;471                 pevent = OSTCBCur->OSTCBEventPtr;
;;;472                 if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
;;;473                    *pevents_rdy++ =  pevent;               /* ... return available event ...              */
;;;474                    *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
;;;475                      events_rdy_nbr++;
;;;476    
;;;477                 } else {                                   /* Else NO event available, handle as timeout  */
;;;478                     OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
;;;479                     OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
;;;480                 }
;;;481    			 break;
;;;482    
;;;483            case OS_STAT_PEND_TO:                           /* If events timed out, ...                    */
;;;484            default:                                        /* ... remove task from events' wait lists     */
;;;485                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
;;;486                 break;
;;;487        }
;;;488    
;;;489        switch (OSTCBCur->OSTCBStatPend) {
;;;490            case OS_STAT_PEND_OK:
;;;491                 switch (pevent->OSEventType) {             /* Return event's message                      */
;;;492    #if (OS_SEM_EN > 0)
;;;493                     case OS_EVENT_TYPE_SEM:
;;;494                         *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
;;;495                          break;
;;;496    #endif
;;;497    
;;;498    #if ((OS_MBOX_EN > 0) ||                 \
;;;499        ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
;;;500                     case OS_EVENT_TYPE_MBOX:
;;;501                     case OS_EVENT_TYPE_Q:
;;;502                         *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
;;;503                          break;
;;;504    #endif
;;;505    
;;;506                     case OS_EVENT_TYPE_MUTEX:                                       
;;;507                     case OS_EVENT_TYPE_FLAG:
;;;508                     default:           
;;;509                          OS_EXIT_CRITICAL();
;;;510                         *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
;;;511                         *perr        =  OS_ERR_EVENT_TYPE;
;;;512                          return (events_rdy_nbr);
;;;513                 }
;;;514                *perr = OS_ERR_NONE;
;;;515                 break;
;;;516    
;;;517            case OS_STAT_PEND_ABORT:
;;;518                *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
;;;519                *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
;;;520                 break;
;;;521                                                            
;;;522            case OS_STAT_PEND_TO:                                                
;;;523            default:        
;;;524                *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
;;;525                *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
;;;526                 break;
;;;527        }
;;;528    
;;;529        OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
;;;530        OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
;;;531        OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
;;;532        OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
;;;533        OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
;;;534        OS_EXIT_CRITICAL();
;;;535    
;;;536        return (events_rdy_nbr);
;;;537    }
0001f0  b004              ADD      sp,sp,#0x10
0001f2  e8bde8bd          POP      {r4-r12,pc}
                  |L1.502|
0001f6  f850f850          LDR      r1,[r0,#4]!           ;366
                  |L1.506|
0001fa  2900              CMP      r1,#0                 ;344
0001fc  d1f0              BNE      |L1.480|
0001fe  4889              LDR      r0,|L1.1060|
000200  7881              LDRB     r1,[r0,#2]            ;369  ; OSIntNesting
000202  b121              CBZ      r1,|L1.526|
000204  2002              MOVS     r0,#2                 ;370
000206  f888f888          STRB     r0,[r8,#0]            ;370
00020a  2000              MOVS     r0,#0                 ;371
00020c  e7f0              B        |L1.496|
                  |L1.526|
00020e  4885              LDR      r0,|L1.1060|
000210  78c0              LDRB     r0,[r0,#3]            ;373  ; OSLockNesting
000212  b120              CBZ      r0,|L1.542|
000214  200d              MOVS     r0,#0xd               ;374
000216  f888f888          STRB     r0,[r8,#0]            ;374
00021a  2000              MOVS     r0,#0                 ;375
00021c  e7e8              B        |L1.496|
                  |L1.542|
00021e  f7fff7ff          BL       OS_CPU_SR_Save
000222  4682              MOV      r10,r0                ;379
000224  2200              MOVS     r2,#0                 ;380
000226  2700              MOVS     r7,#0                 ;381
000228  2000              MOVS     r0,#0                 ;382
00022a  9900              LDR      r1,[sp,#0]            ;383
00022c  680c              LDR      r4,[r1,#0]            ;384
00022e  e020              B        |L1.626|
                  |L1.560|
000230  7823              LDRB     r3,[r4,#0]            ;386
000232  2b01              CMP      r3,#1                 ;386
000234  d00f              BEQ      |L1.598|
000236  2b03              CMP      r3,#3                 ;386
000238  d128              BNE      |L1.652|
00023a  8923              LDRH     r3,[r4,#8]            ;389
00023c  b143              CBZ      r3,|L1.592|
00023e  1e5b              SUBS     r3,r3,#1              ;390
000240  8123              STRH     r3,[r4,#8]            ;390
000242  c510              STM      r5!,{r4}              ;391
000244  2201              MOVS     r2,#1                 ;392
000246  f846f846          STR      r9,[r6],#4            ;393
00024a  1c7f              ADDS     r7,r7,#1              ;394
00024c  b2bf              UXTH     r7,r7                 ;394
00024e  e00e              B        |L1.622|
                  |L1.592|
000250  f040f040          ORR      r0,r0,#1              ;397
000254  e00b              B        |L1.622|
                  |L1.598|
000256  6863              LDR      r3,[r4,#4]            ;404
000258  b13b              CBZ      r3,|L1.618|
00025a  c608              STM      r6!,{r3}              ;406
00025c  f8c4f8c4          STR      r9,[r4,#4]            ;407
000260  c510              STM      r5!,{r4}              ;408
000262  2201              MOVS     r2,#1                 ;409
000264  1c7f              ADDS     r7,r7,#1              ;410
000266  b2bf              UXTH     r7,r7                 ;410
000268  e001              B        |L1.622|
                  |L1.618|
00026a  f040f040          ORR      r0,r0,#2              ;413
                  |L1.622|
00026e  f851f851          LDR      r4,[r1,#4]!           ;447
                  |L1.626|
000272  2c00              CMP      r4,#0                 ;385
000274  d1dc              BNE      |L1.560|
000276  2a01              CMP      r2,#1                 ;450
000278  d111              BNE      |L1.670|
00027a  f8c5f8c5          STR      r9,[r5,#0]            ;451
00027e  4650              MOV      r0,r10                ;452
000280  f7fff7ff          BL       OS_CPU_SR_Restore
000284  f888f888          STRB     r9,[r8,#0]            ;453
000288  4638              MOV      r0,r7                 ;454
00028a  e7b1              B        |L1.496|
                  |L1.652|
00028c  4650              MOV      r0,r10                ;441
00028e  f7fff7ff          BL       OS_CPU_SR_Restore
000292  f8c5f8c5          STR      r9,[r5,#0]            ;442
000296  f888f888          STRB     r11,[r8,#0]           ;443
00029a  4638              MOV      r0,r7                 ;444
00029c  e7a8              B        |L1.496|
                  |L1.670|
00029e  4961              LDR      r1,|L1.1060|
0002a0  f040f040          ORR      r0,r0,#0x80           ;458
0002a4  6a49              LDR      r1,[r1,#0x24]         ;458  ; OSTCBCur
0002a6  312e              ADDS     r1,r1,#0x2e           ;458
0002a8  788a              LDRB     r2,[r1,#2]            ;458
0002aa  4302              ORRS     r2,r2,r0              ;458
0002ac  708a              STRB     r2,[r1,#2]            ;458
0002ae  f881f881          STRB     r9,[r1,#3]            ;460
0002b2  9803              LDR      r0,[sp,#0xc]          ;461
0002b4  8008              STRH     r0,[r1,#0]            ;461
0002b6  9800              LDR      r0,[sp,#0]            ;462
0002b8  f7fff7ff          BL       OS_EventTaskWaitMulti
0002bc  4650              MOV      r0,r10                ;464
0002be  f7fff7ff          BL       OS_CPU_SR_Restore
0002c2  f7fff7ff          BL       OS_Sched
0002c6  f7fff7ff          BL       OS_CPU_SR_Save
0002ca  4682              MOV      r10,r0                ;466
0002cc  4855              LDR      r0,|L1.1060|
0002ce  6a40              LDR      r0,[r0,#0x24]         ;468  ; OSTCBCur
0002d0  f890f890          LDRB     r1,[r0,#0x31]         ;468
0002d4  b109              CBZ      r1,|L1.730|
0002d6  2902              CMP      r1,#2                 ;468
0002d8  d10d              BNE      |L1.758|
                  |L1.730|
0002da  69c4              LDR      r4,[r0,#0x1c]         ;471
0002dc  b12c              CBZ      r4,|L1.746|
0002de  602c              STR      r4,[r5,#0]            ;473
0002e0  f845f845          STR      r9,[r5,#4]!           ;474
0002e4  1c7f              ADDS     r7,r7,#1              ;475
0002e6  b2bf              UXTH     r7,r7                 ;475
0002e8  e008              B        |L1.764|
                  |L1.746|
0002ea  f880f880          STRB     r11,[r0,#0x31]        ;478
0002ee  9900              LDR      r1,[sp,#0]            ;479
0002f0  f7fff7ff          BL       OS_EventTaskRemoveMulti
0002f4  e002              B        |L1.764|
                  |L1.758|
0002f6  9900              LDR      r1,[sp,#0]            ;485
0002f8  f7fff7ff          BL       OS_EventTaskRemoveMulti
                  |L1.764|
0002fc  4a49              LDR      r2,|L1.1060|
0002fe  6a51              LDR      r1,[r2,#0x24]         ;489  ; OSTCBCur
000300  f891f891          LDRB     r0,[r1,#0x31]         ;489
000304  b138              CBZ      r0,|L1.790|
000306  2802              CMP      r0,#2                 ;489
000308  d11d              BNE      |L1.838|
00030a  f8c6f8c6          STR      r9,[r6,#0]            ;518
00030e  200e              MOVS     r0,#0xe               ;519
000310  f888f888          STRB     r0,[r8,#0]            ;519
000314  e01c              B        |L1.848|
                  |L1.790|
000316  7820              LDRB     r0,[r4,#0]            ;491
000318  2801              CMP      r0,#1                 ;491
00031a  d006              BEQ      |L1.810|
00031c  2802              CMP      r0,#2                 ;491
00031e  d004              BEQ      |L1.810|
000320  2803              CMP      r0,#3                 ;491
000322  d107              BNE      |L1.820|
000324  f8c6f8c6          STR      r9,[r6,#0]            ;494
000328  e001              B        |L1.814|
                  |L1.810|
00032a  6a48              LDR      r0,[r1,#0x24]         ;502
00032c  6030              STR      r0,[r6,#0]            ;502
                  |L1.814|
00032e  f888f888          STRB     r9,[r8,#0]            ;514
000332  e00d              B        |L1.848|
                  |L1.820|
000334  4650              MOV      r0,r10                ;509
000336  f7fff7ff          BL       OS_CPU_SR_Restore
00033a  f8c5f8c5          STR      r9,[r5,#0]            ;510
00033e  f888f888          STRB     r11,[r8,#0]           ;511
000342  4638              MOV      r0,r7                 ;512
000344  e754              B        |L1.496|
                  |L1.838|
000346  f8c6f8c6          STR      r9,[r6,#0]            ;524
00034a  200a              MOVS     r0,#0xa               ;525
00034c  f888f888          STRB     r0,[r8,#0]            ;525
                  |L1.848|
000350  6a50              LDR      r0,[r2,#0x24]         ;529  ; OSTCBCur
000352  f880f880          STRB     r9,[r0,#0x30]         ;529
000356  f880f880          STRB     r9,[r0,#0x31]         ;530
00035a  f8c0f8c0          STR      r9,[r0,#0x1c]         ;531
00035e  f8c0f8c0          STR      r9,[r0,#0x20]         ;532
000362  f8c0f8c0          STR      r9,[r0,#0x24]         ;533
000366  4650              MOV      r0,r10                ;534
000368  f7fff7ff          BL       OS_CPU_SR_Restore
00036c  4638              MOV      r0,r7                 ;536
00036e  e73f              B        |L1.496|
;;;538    #endif
                          ENDP

                  OS_TaskStatStkChk PROC
;;;1850   void  OS_TaskStatStkChk (void)
;;;1851   {
000370  b57c              PUSH     {r2-r6,lr}
;;;1852       OS_TCB      *ptcb;
;;;1853       OS_STK_DATA  stk_data;
;;;1854       INT8U        err;
;;;1855       INT8U        prio;
;;;1856   
;;;1857   
;;;1858       for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
000372  2400              MOVS     r4,#0
000374  4d2d              LDR      r5,|L1.1068|
                  |L1.886|
;;;1859           err = OSTaskStkChk(prio, &stk_data);
000376  4669              MOV      r1,sp
000378  4620              MOV      r0,r4
00037a  f7fff7ff          BL       OSTaskStkChk
;;;1860           if (err == OS_ERR_NONE) {
00037e  b958              CBNZ     r0,|L1.920|
;;;1861               ptcb = OSTCBPrioTbl[prio];
000380  f855f855          LDR      r0,[r5,r4,LSL #2]
;;;1862               if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
000384  b140              CBZ      r0,|L1.920|
;;;1863                   if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
000386  2801              CMP      r0,#1
000388  d006              BEQ      |L1.920|
;;;1864   #if OS_TASK_PROFILE_EN > 0
;;;1865                       #if OS_STK_GROWTH == 1
;;;1866                       ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
00038a  e9d0e9d0          LDRD     r1,r2,[r0,#8]
00038e  eb01eb01          ADD      r1,r1,r2,LSL #2
000392  6441              STR      r1,[r0,#0x44]
;;;1867                       #else
;;;1868                       ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
;;;1869                       #endif
;;;1870                       ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
000394  9901              LDR      r1,[sp,#4]
000396  6481              STR      r1,[r0,#0x48]
                  |L1.920|
000398  1c64              ADDS     r4,r4,#1              ;1858
00039a  b2e4              UXTB     r4,r4                 ;1858
00039c  2c1f              CMP      r4,#0x1f              ;1858
00039e  d9ea              BLS      |L1.886|
;;;1871   #endif
;;;1872                   }
;;;1873               }
;;;1874           }
;;;1875       }
;;;1876   }
0003a0  bd7c              POP      {r2-r6,pc}
;;;1877   #endif
                          ENDP

                  OS_TaskStat PROC
;;;1805   void  OS_TaskStat (void *p_arg)
;;;1806   {
0003a2  b570              PUSH     {r4-r6,lr}
;;;1807   #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;1808       OS_CPU_SR  cpu_sr = 0;
;;;1809   #endif
;;;1810   
;;;1811   
;;;1812   
;;;1813       (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
;;;1814       while (OSStatRdy == OS_FALSE) {
0003a4  4c1f              LDR      r4,|L1.1060|
0003a6  e002              B        |L1.942|
                  |L1.936|
;;;1815           OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
0003a8  20c8              MOVS     r0,#0xc8
0003aa  f7fff7ff          BL       OSTimeDly
                  |L1.942|
0003ae  7860              LDRB     r0,[r4,#1]            ;1814  ; OSStatRdy
0003b0  2800              CMP      r0,#0                 ;1814
0003b2  d0f9              BEQ      |L1.936|
;;;1816       }
;;;1817       OSIdleCtrMax /= 100L;
0003b4  6960              LDR      r0,[r4,#0x14]  ; OSIdleCtrMax
0003b6  2164              MOVS     r1,#0x64
0003b8  fbb0fbb0          UDIV     r0,r0,r1
0003bc  6160              STR      r0,[r4,#0x14]  ; OSIdleCtrMax
;;;1818       if (OSIdleCtrMax == 0L) {
0003be  2500              MOVS     r5,#0
0003c0  b918              CBNZ     r0,|L1.970|
;;;1819           OSCPUUsage = 0;
0003c2  7025              STRB     r5,[r4,#0]  ; OSCPUUsage
;;;1820           (void)OSTaskSuspend(OS_PRIO_SELF);
0003c4  20ff              MOVS     r0,#0xff
0003c6  f7fff7ff          BL       OSTaskSuspend
                  |L1.970|
;;;1821       }
;;;1822       for (;;) {
;;;1823           OS_ENTER_CRITICAL();
0003ca  f7fff7ff          BL       OS_CPU_SR_Save
;;;1824           OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
0003ce  6a21              LDR      r1,[r4,#0x20]  ; OSIdleCtr
0003d0  61a1              STR      r1,[r4,#0x18]  ; OSIdleCtrRun
;;;1825           OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
0003d2  6225              STR      r5,[r4,#0x20]  ; OSIdleCtr
;;;1826           OS_EXIT_CRITICAL();
0003d4  f7fff7ff          BL       OS_CPU_SR_Restore
;;;1827           OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
0003d8  e9d4e9d4          LDRD     r1,r0,[r4,#0x14]
0003dc  fbb0fbb0          UDIV     r0,r0,r1
0003e0  f1c0f1c0          RSB      r0,r0,#0x64
0003e4  7020              STRB     r0,[r4,#0]  ; OSCPUUsage
;;;1828           OSTaskStatHook();                        /* Invoke user definable hook                         */
0003e6  f7fff7ff          BL       OSTaskStatHook
;;;1829   #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
;;;1830           OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
0003ea  f7fff7ff          BL       OS_TaskStatStkChk
;;;1831   #endif
;;;1832           OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
0003ee  2064              MOVS     r0,#0x64
0003f0  f7fff7ff          BL       OSTimeDly
0003f4  e7e9              B        |L1.970|
;;;1833       }
;;;1834   }
;;;1835   #endif
                          ENDP

                  OS_InitTaskStat PROC
;;;1434   static  void  OS_InitTaskStat (void)
;;;1435   {
0003f6  b500              PUSH     {lr}
0003f8  b087              SUB      sp,sp,#0x1c
;;;1436   #if OS_TASK_NAME_SIZE > 7
;;;1437       INT8U  err;
;;;1438   #endif
;;;1439   
;;;1440   
;;;1441   #if OS_TASK_CREATE_EXT_EN > 0
;;;1442       #if OS_STK_GROWTH == 1
;;;1443       (void)OSTaskCreateExt(OS_TaskStat,
0003fa  2303              MOVS     r3,#3
0003fc  2200              MOVS     r2,#0
0003fe  e9cde9cd          STRD     r2,r3,[sp,#0xc]
000402  480b              LDR      r0,|L1.1072|
000404  2180              MOVS     r1,#0x80
000406  e9cde9cd          STRD     r0,r1,[sp,#4]
00040a  f64ff64f          MOV      r3,#0xfffe
00040e  9300              STR      r3,[sp,#0]
000410  231e              MOVS     r3,#0x1e
000412  f500f500          ADD      r2,r0,#0x1fc
000416  2100              MOVS     r1,#0
000418  f2aff2af          ADR      r0,OS_TaskStat + 1
00041c  f7fff7ff          BL       OSTaskCreateExt
;;;1444                             (void *)0,                                   /* No args passed to OS_TaskStat()*/
;;;1445                             &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],   /* Set Top-Of-Stack               */
;;;1446                             OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
;;;1447                             OS_TASK_STAT_ID,
;;;1448                             &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
;;;1449                             OS_TASK_STAT_STK_SIZE,
;;;1450                             (void *)0,                                   /* No TCB extension               */
;;;1451                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
;;;1452       #else
;;;1453       (void)OSTaskCreateExt(OS_TaskStat,
;;;1454                             (void *)0,                                   /* No args passed to OS_TaskStat()*/
;;;1455                             &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
;;;1456                             OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
;;;1457                             OS_TASK_STAT_ID,
;;;1458                             &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],   /* Set Bottom-Of-Stack            */
;;;1459                             OS_TASK_STAT_STK_SIZE,
;;;1460                             (void *)0,                                   /* No TCB extension               */
;;;1461                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
;;;1462       #endif
;;;1463   #else
;;;1464       #if OS_STK_GROWTH == 1
;;;1465       (void)OSTaskCreate(OS_TaskStat,
;;;1466                          (void *)0,                                      /* No args passed to OS_TaskStat()*/
;;;1467                          &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],      /* Set Top-Of-Stack               */
;;;1468                          OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
;;;1469       #else
;;;1470       (void)OSTaskCreate(OS_TaskStat,
;;;1471                          (void *)0,                                      /* No args passed to OS_TaskStat()*/
;;;1472                          &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
;;;1473                          OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
;;;1474       #endif
;;;1475   #endif
;;;1476   
;;;1477   #if OS_TASK_NAME_SIZE > 14
;;;1478       OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
000420  aa06              ADD      r2,sp,#0x18
000422  e007              B        |L1.1076|
                  |L1.1060|
000424  00000000          DCD      ||.data||
                  |L1.1064|
000428  00000000          DCD      ||.constdata||
                  |L1.1068|
00042c  00000540          DCD      ||.bss||+0x540
                  |L1.1072|
000430  00000140          DCD      ||.bss||+0x140
                  |L1.1076|
000434  a1fe              ADR      r1,|L1.2096|
000436  201e              MOVS     r0,#0x1e
000438  f7fff7ff          BL       OSTaskNameSet
                  |L1.1084|
;;;1479   #else
;;;1480   #if OS_TASK_NAME_SIZE > 7
;;;1481       OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
;;;1482   #endif
;;;1483   #endif
;;;1484   }
00043c  b007              ADD      sp,sp,#0x1c
00043e  bd00              POP      {pc}
;;;1485   #endif
                          ENDP

                  OS_TaskIdle PROC
;;;1763   void  OS_TaskIdle (void *p_arg)
;;;1764   {
000440  b510              PUSH     {r4,lr}
000442  4cff              LDR      r4,|L1.2112|
                  |L1.1092|
;;;1765   #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;1766       OS_CPU_SR  cpu_sr = 0;
;;;1767   #endif
;;;1768   
;;;1769   
;;;1770   
;;;1771       (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
;;;1772       for (;;) {
;;;1773           OS_ENTER_CRITICAL();
000444  f7fff7ff          BL       OS_CPU_SR_Save
;;;1774           OSIdleCtr++;
000448  6a21              LDR      r1,[r4,#0x20]  ; OSIdleCtr
00044a  1c49              ADDS     r1,r1,#1
00044c  6221              STR      r1,[r4,#0x20]  ; OSIdleCtr
;;;1775           OS_EXIT_CRITICAL();
00044e  f7fff7ff          BL       OS_CPU_SR_Restore
;;;1776           OSTaskIdleHook();                        /* Call user definable HOOK                           */
000452  f7fff7ff          BL       OSTaskIdleHook
000456  e7f5              B        |L1.1092|
;;;1777       }
;;;1778   }
;;;1779   /*$PAGE*/
                          ENDP

                  OS_InitTaskIdle PROC
;;;1368   static  void  OS_InitTaskIdle (void)
;;;1369   {
000458  b500              PUSH     {lr}
00045a  b087              SUB      sp,sp,#0x1c
;;;1370   #if OS_TASK_NAME_SIZE > 7
;;;1371       INT8U  err;
;;;1372   #endif
;;;1373   
;;;1374   
;;;1375   #if OS_TASK_CREATE_EXT_EN > 0
;;;1376       #if OS_STK_GROWTH == 1
;;;1377       (void)OSTaskCreateExt(OS_TaskIdle,
00045c  2303              MOVS     r3,#3
00045e  2200              MOVS     r2,#0
000460  e9cde9cd          STRD     r2,r3,[sp,#0xc]
000464  48f7              LDR      r0,|L1.2116|
000466  2180              MOVS     r1,#0x80
000468  e9cde9cd          STRD     r0,r1,[sp,#4]
00046c  f64ff64f          MOV      r3,#0xffff
000470  9300              STR      r3,[sp,#0]
000472  231f              MOVS     r3,#0x1f
000474  f500f500          ADD      r2,r0,#0x1fc
000478  2100              MOVS     r1,#0
00047a  f2aff2af          ADR      r0,OS_TaskIdle + 1
00047e  f7fff7ff          BL       OSTaskCreateExt
;;;1378                             (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
;;;1379                             &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1], /* Set Top-Of-Stack                     */
;;;1380                             OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
;;;1381                             OS_TASK_IDLE_ID,
;;;1382                             &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
;;;1383                             OS_TASK_IDLE_STK_SIZE,
;;;1384                             (void *)0,                                 /* No TCB extension                     */
;;;1385                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
;;;1386       #else
;;;1387       (void)OSTaskCreateExt(OS_TaskIdle,
;;;1388                             (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
;;;1389                             &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
;;;1390                             OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
;;;1391                             OS_TASK_IDLE_ID,
;;;1392                             &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1], /* Set Bottom-Of-Stack                  */
;;;1393                             OS_TASK_IDLE_STK_SIZE,
;;;1394                             (void *)0,                                 /* No TCB extension                     */
;;;1395                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
;;;1396       #endif
;;;1397   #else
;;;1398       #if OS_STK_GROWTH == 1
;;;1399       (void)OSTaskCreate(OS_TaskIdle,
;;;1400                          (void *)0,
;;;1401                          &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1],
;;;1402                          OS_TASK_IDLE_PRIO);
;;;1403       #else
;;;1404       (void)OSTaskCreate(OS_TaskIdle,
;;;1405                          (void *)0,
;;;1406                          &OSTaskIdleStk[0],
;;;1407                          OS_TASK_IDLE_PRIO);
;;;1408       #endif
;;;1409   #endif
;;;1410   
;;;1411   #if OS_TASK_NAME_SIZE > 14
;;;1412       OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
000482  aa06              ADD      r2,sp,#0x18
000484  a1f0              ADR      r1,|L1.2120|
000486  201f              MOVS     r0,#0x1f
000488  f7fff7ff          BL       OSTaskNameSet
;;;1413   #else
;;;1414   #if OS_TASK_NAME_SIZE > 7
;;;1415       OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
;;;1416   #endif
;;;1417   #endif
;;;1418   }
00048c  e7d6              B        |L1.1084|
;;;1419   /*$PAGE*/
                          ENDP

                  OS_MemClr PROC
;;;1549   void  OS_MemClr (INT8U *pdest, INT16U size)
;;;1550   {
00048e  2200              MOVS     r2,#0
000490  e003              B        |L1.1178|
                  |L1.1170|
;;;1551       while (size > 0) {
;;;1552           *pdest++ = (INT8U)0;
000492  f800f800          STRB     r2,[r0],#1
;;;1553           size--;
000496  1e49              SUBS     r1,r1,#1
000498  b289              UXTH     r1,r1
                  |L1.1178|
00049a  2900              CMP      r1,#0                 ;1551
00049c  d1f9              BNE      |L1.1170|
;;;1554       }
;;;1555   }
00049e  4770              BX       lr
;;;1556   /*$PAGE*/
                          ENDP

                  OS_InitEventList PROC
;;;1241   static  void  OS_InitEventList (void)
;;;1242   {
0004a0  b510              PUSH     {r4,lr}
;;;1243   #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0)
;;;1244   #if (OS_MAX_EVENTS > 1)
;;;1245       INT16U     i;
;;;1246       OS_EVENT  *pevent1;
;;;1247       OS_EVENT  *pevent2;
;;;1248   
;;;1249   
;;;1250       OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
0004a2  f44ff44f          MOV      r1,#0x140
0004a6  48ec              LDR      r0,|L1.2136|
0004a8  f7fff7ff          BL       OS_MemClr
;;;1251       pevent1 = &OSEventTbl[0];
0004ac  48ea              LDR      r0,|L1.2136|
;;;1252       pevent2 = &OSEventTbl[1];
0004ae  f100f100          ADD      r2,r0,#0x20
;;;1253       for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
0004b2  2100              MOVS     r1,#0
0004b4  2300              MOVS     r3,#0
0004b6  243f              MOVS     r4,#0x3f
                  |L1.1208|
;;;1254           pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
0004b8  7003              STRB     r3,[r0,#0]
;;;1255           pevent1->OSEventPtr     = pevent2;
0004ba  6042              STR      r2,[r0,#4]
;;;1256   #if OS_EVENT_NAME_SIZE > 1
;;;1257           pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
0004bc  73c4              STRB     r4,[r0,#0xf]
;;;1258           pevent1->OSEventName[1] = OS_ASCII_NUL;
0004be  7403              STRB     r3,[r0,#0x10]
;;;1259   #endif
;;;1260           pevent1++;
0004c0  3020              ADDS     r0,r0,#0x20
;;;1261           pevent2++;
0004c2  3220              ADDS     r2,r2,#0x20
0004c4  1c49              ADDS     r1,r1,#1              ;1253
0004c6  b289              UXTH     r1,r1                 ;1253
0004c8  2909              CMP      r1,#9                 ;1253
0004ca  d3f5              BCC      |L1.1208|
;;;1262       }
;;;1263       pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
0004cc  7003              STRB     r3,[r0,#0]
;;;1264       pevent1->OSEventPtr             = (OS_EVENT *)0;
0004ce  6043              STR      r3,[r0,#4]
;;;1265   #if OS_EVENT_NAME_SIZE > 1
;;;1266       pevent1->OSEventName[0]         = '?';
0004d0  73c4              STRB     r4,[r0,#0xf]
;;;1267       pevent1->OSEventName[1]         = OS_ASCII_NUL;
0004d2  7403              STRB     r3,[r0,#0x10]
;;;1268   #endif
;;;1269       OSEventFreeList                 = &OSEventTbl[0];
0004d4  49da              LDR      r1,|L1.2112|
0004d6  48e0              LDR      r0,|L1.2136|
0004d8  6108              STR      r0,[r1,#0x10]  ; OSEventFreeList
;;;1270   #else
;;;1271       OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
;;;1272       OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;1273       OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
;;;1274   #if OS_EVENT_NAME_SIZE > 1
;;;1275       OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
;;;1276       OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
;;;1277   #endif
;;;1278   #endif
;;;1279   #endif
;;;1280   }
0004da  bd10              POP      {r4,pc}
;;;1281   /*$PAGE*/
                          ENDP

                  OS_InitTCBList PROC
;;;1500   static  void  OS_InitTCBList (void)
;;;1501   {
0004dc  b510              PUSH     {r4,lr}
;;;1502       INT8U    i;
;;;1503       OS_TCB  *ptcb1;
;;;1504       OS_TCB  *ptcb2;
;;;1505   
;;;1506   
;;;1507       OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
0004de  f44ff44f          MOV      r1,#0x7e8
0004e2  48de              LDR      r0,|L1.2140|
0004e4  f7fff7ff          BL       OS_MemClr
;;;1508       OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
0004e8  48dc              LDR      r0,|L1.2140|
0004ea  2180              MOVS     r1,#0x80
0004ec  3880              SUBS     r0,r0,#0x80
0004ee  f7fff7ff          BL       OS_MemClr
;;;1509       ptcb1 = &OSTCBTbl[0];
0004f2  48da              LDR      r0,|L1.2140|
;;;1510       ptcb2 = &OSTCBTbl[1];
0004f4  f100f100          ADD      r2,r0,#0x5c
;;;1511       for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
0004f8  2100              MOVS     r1,#0
0004fa  2400              MOVS     r4,#0
0004fc  233f              MOVS     r3,#0x3f
                  |L1.1278|
;;;1512           ptcb1->OSTCBNext = ptcb2;
0004fe  6142              STR      r2,[r0,#0x14]
;;;1513   #if OS_TASK_NAME_SIZE > 1
;;;1514           ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
000500  f880f880          STRB     r3,[r0,#0x4c]
;;;1515           ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
000504  f880f880          STRB     r4,[r0,#0x4d]
;;;1516   #endif
;;;1517           ptcb1++;
000508  305c              ADDS     r0,r0,#0x5c
;;;1518           ptcb2++;
00050a  325c              ADDS     r2,r2,#0x5c
00050c  1c49              ADDS     r1,r1,#1              ;1511
00050e  b2c9              UXTB     r1,r1                 ;1511
000510  2915              CMP      r1,#0x15              ;1511
000512  d3f4              BCC      |L1.1278|
;;;1519       }
;;;1520       ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
000514  6144              STR      r4,[r0,#0x14]
;;;1521   #if OS_TASK_NAME_SIZE > 1
;;;1522       ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
000516  f880f880          STRB     r3,[r0,#0x4c]
;;;1523       ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
00051a  f880f880          STRB     r4,[r0,#0x4d]
;;;1524   #endif
;;;1525       OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
00051e  48c8              LDR      r0,|L1.2112|
000520  6304              STR      r4,[r0,#0x30]  ; OSTCBList
;;;1526       OSTCBFreeList           = &OSTCBTbl[0];
000522  49ce              LDR      r1,|L1.2140|
000524  6281              STR      r1,[r0,#0x28]  ; OSTCBFreeList
;;;1527   }
000526  bd10              POP      {r4,pc}
;;;1528   /*$PAGE*/
                          ENDP

                  OS_InitRdyList PROC
;;;1340   
;;;1341       OSRdyGrp      = 0;                                     /* Clear the ready list                     */
000528  4bc5              LDR      r3,|L1.2112|
00052a  2200              MOVS     r2,#0
00052c  719a              STRB     r2,[r3,#6]  ; OSRdyGrp
;;;1342       prdytbl       = &OSRdyTbl[0];
00052e  f103f103          ADD      r0,r3,#0x1c
;;;1343       for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
000532  2100              MOVS     r1,#0
                  |L1.1332|
;;;1344           *prdytbl++ = 0;
000534  f800f800          STRB     r2,[r0],#1
000538  1c49              ADDS     r1,r1,#1              ;1343
00053a  b2c9              UXTB     r1,r1                 ;1343
00053c  2904              CMP      r1,#4                 ;1343
00053e  d3f9              BCC      |L1.1332|
;;;1345       }
;;;1346   
;;;1347       OSPrioCur     = 0;
000540  711a              STRB     r2,[r3,#4]  ; OSPrioCur
;;;1348       OSPrioHighRdy = 0;
000542  715a              STRB     r2,[r3,#5]  ; OSPrioHighRdy
;;;1349   
;;;1350       OSTCBHighRdy  = (OS_TCB *)0;
000544  62da              STR      r2,[r3,#0x2c]  ; OSTCBHighRdy
;;;1351       OSTCBCur      = (OS_TCB *)0;
000546  625a              STR      r2,[r3,#0x24]  ; OSTCBCur
;;;1352   }
000548  4770              BX       lr
;;;1353   
                          ENDP

                  OS_InitMisc PROC
;;;1297   #if OS_TIME_GET_SET_EN > 0
;;;1298       OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
00054a  49bd              LDR      r1,|L1.2112|
00054c  2000              MOVS     r0,#0
00054e  6348              STR      r0,[r1,#0x34]  ; OSTime
;;;1299   #endif
;;;1300   
;;;1301       OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
000550  7088              STRB     r0,[r1,#2]  ; OSIntNesting
;;;1302       OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
000552  70c8              STRB     r0,[r1,#3]  ; OSLockNesting
;;;1303   
;;;1304       OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
000554  7208              STRB     r0,[r1,#8]  ; OSTaskCtr
;;;1305   
;;;1306       OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
000556  71c8              STRB     r0,[r1,#7]  ; OSRunning
;;;1307   
;;;1308       OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
000558  60c8              STR      r0,[r1,#0xc]  ; OSCtxSwCtr
;;;1309       OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
00055a  6208              STR      r0,[r1,#0x20]  ; OSIdleCtr
;;;1310   
;;;1311   #if OS_TASK_STAT_EN > 0
;;;1312       OSIdleCtrRun  = 0L;
00055c  6188              STR      r0,[r1,#0x18]  ; OSIdleCtrRun
;;;1313       OSIdleCtrMax  = 0L;
00055e  6148              STR      r0,[r1,#0x14]  ; OSIdleCtrMax
;;;1314       OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
000560  7048              STRB     r0,[r1,#1]  ; OSStatRdy
;;;1315   #endif
;;;1316   }
000562  4770              BX       lr
;;;1317   /*$PAGE*/
                          ENDP

                  OSInit PROC
;;;554    void  OSInit (void)
;;;555    {
000564  b510              PUSH     {r4,lr}
;;;556        OSInitHookBegin();                                           /* Call port specific initialization code   */
000566  f7fff7ff          BL       OSInitHookBegin
;;;557    
;;;558        OS_InitMisc();                                               /* Initialize miscellaneous variables       */
00056a  f7fff7ff          BL       OS_InitMisc
;;;559    
;;;560        OS_InitRdyList();                                            /* Initialize the Ready List                */
00056e  f7fff7ff          BL       OS_InitRdyList
;;;561    
;;;562        OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
000572  f7fff7ff          BL       OS_InitTCBList
;;;563    
;;;564        OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
000576  f7fff7ff          BL       OS_InitEventList
;;;565    
;;;566    #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
;;;567        OS_FlagInit();                                               /* Initialize the event flag structures     */
00057a  f7fff7ff          BL       OS_FlagInit
;;;568    #endif
;;;569    
;;;570    #if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
;;;571        OS_MemInit();                                                /* Initialize the memory manager            */
;;;572    #endif
;;;573    
;;;574    #if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
;;;575        OS_QInit();                                                  /* Initialize the message queue structures  */
;;;576    #endif
;;;577    
;;;578        OS_InitTaskIdle();                                           /* Create the Idle Task                     */
00057e  f7fff7ff          BL       OS_InitTaskIdle
;;;579    #if OS_TASK_STAT_EN > 0
;;;580        OS_InitTaskStat();                                           /* Create the Statistic Task                */
000582  f7fff7ff          BL       OS_InitTaskStat
;;;581    #endif
;;;582    
;;;583    #if OS_TMR_EN > 0
;;;584        OSTmr_Init();                                                /* Initialize the Timer Manager             */
;;;585    #endif
;;;586    
;;;587        OSInitHookEnd();                                             /* Call port specific init. code            */
000586  e8bde8bd          POP      {r4,lr}
00058a  f7fff7ff          B.W      OSInitHookEnd
;;;588    
;;;589    #if OS_DEBUG_EN > 0
;;;590        OSDebugInit();
;;;591    #endif
;;;592    }
;;;593    /*$PAGE*/
                          ENDP

                  OSIntEnter PROC
;;;620    {
;;;621        if (OSRunning == OS_TRUE) {
00058e  49ac              LDR      r1,|L1.2112|
000590  79c8              LDRB     r0,[r1,#7]  ; OSRunning
000592  2801              CMP      r0,#1
000594  d104              BNE      |L1.1440|
;;;622            if (OSIntNesting < 255u) {
000596  7888              LDRB     r0,[r1,#2]  ; OSIntNesting
000598  28ff              CMP      r0,#0xff
00059a  d201              BCS      |L1.1440|
;;;623                OSIntNesting++;                      /* Increment ISR nesting level                        */
00059c  1c40              ADDS     r0,r0,#1
00059e  7088              STRB     r0,[r1,#2]  ; OSIntNesting
                  |L1.1440|
;;;624            }
;;;625        }
;;;626    }
0005a0  4770              BX       lr
;;;627    /*$PAGE*/
                          ENDP

                  OSIntExit PROC
;;;647    void  OSIntExit (void)
;;;648    {
0005a2  b570              PUSH     {r4-r6,lr}
;;;649    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;650        OS_CPU_SR  cpu_sr = 0;
;;;651    #endif
;;;652    
;;;653    
;;;654    
;;;655        if (OSRunning == OS_TRUE) {
0005a4  4ca6              LDR      r4,|L1.2112|
0005a6  79e0              LDRB     r0,[r4,#7]  ; OSRunning
0005a8  2801              CMP      r0,#1
0005aa  d122              BNE      |L1.1522|
;;;656            OS_ENTER_CRITICAL();
0005ac  f7fff7ff          BL       OS_CPU_SR_Save
0005b0  4605              MOV      r5,r0
;;;657            if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
0005b2  78a1              LDRB     r1,[r4,#2]  ; OSIntNesting
0005b4  b109              CBZ      r1,|L1.1466|
;;;658                OSIntNesting--;
0005b6  1e49              SUBS     r1,r1,#1
0005b8  70a1              STRB     r1,[r4,#2]  ; OSIntNesting
                  |L1.1466|
;;;659            }
;;;660            if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
0005ba  78a0              LDRB     r0,[r4,#2]  ; OSIntNesting
0005bc  b9a0              CBNZ     r0,|L1.1512|
;;;661                if (OSLockNesting == 0) {                      /* ... and not locked.                      */
0005be  78e0              LDRB     r0,[r4,#3]  ; OSLockNesting
0005c0  b990              CBNZ     r0,|L1.1512|
;;;662                    OS_SchedNew();
0005c2  f7fff7ff          BL       OS_SchedNew
;;;663                    if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
0005c6  7961              LDRB     r1,[r4,#5]  ; OSPrioHighRdy
0005c8  7920              LDRB     r0,[r4,#4]  ; OSPrioCur
0005ca  4281              CMP      r1,r0
0005cc  d00c              BEQ      |L1.1512|
;;;664                        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
0005ce  48a3              LDR      r0,|L1.2140|
0005d0  3880              SUBS     r0,r0,#0x80
0005d2  f850f850          LDR      r1,[r0,r1,LSL #2]
0005d6  62e1              STR      r1,[r4,#0x2c]  ; OSTCBHighRdy
;;;665    #if OS_TASK_PROFILE_EN > 0
;;;666                        OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
0005d8  6b88              LDR      r0,[r1,#0x38]
0005da  1c40              ADDS     r0,r0,#1
0005dc  6388              STR      r0,[r1,#0x38]
;;;667    #endif
;;;668                        OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
0005de  68e0              LDR      r0,[r4,#0xc]  ; OSCtxSwCtr
0005e0  1c40              ADDS     r0,r0,#1
0005e2  60e0              STR      r0,[r4,#0xc]  ; OSCtxSwCtr
;;;669                        OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
0005e4  f7fff7ff          BL       OSIntCtxSw
                  |L1.1512|
;;;670                    }
;;;671                }
;;;672            }
;;;673            OS_EXIT_CRITICAL();
0005e8  4628              MOV      r0,r5
0005ea  e8bde8bd          POP      {r4-r6,lr}
0005ee  f7fff7ff          B.W      OS_CPU_SR_Restore
                  |L1.1522|
;;;674        }
;;;675    }
0005f2  bd70              POP      {r4-r6,pc}
;;;676    /*$PAGE*/
                          ENDP

                  OSSchedLock PROC
;;;694    void  OSSchedLock (void)
;;;695    {
0005f4  b510              PUSH     {r4,lr}
;;;696    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;697        OS_CPU_SR  cpu_sr = 0;
;;;698    #endif
;;;699    
;;;700    
;;;701    
;;;702        if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
0005f6  4c92              LDR      r4,|L1.2112|
0005f8  79e0              LDRB     r0,[r4,#7]  ; OSRunning
0005fa  2801              CMP      r0,#1
0005fc  d10c              BNE      |L1.1560|
;;;703            OS_ENTER_CRITICAL();
0005fe  f7fff7ff          BL       OS_CPU_SR_Save
;;;704            if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
000602  78a1              LDRB     r1,[r4,#2]  ; OSIntNesting
000604  b921              CBNZ     r1,|L1.1552|
;;;705                if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
000606  78e1              LDRB     r1,[r4,#3]  ; OSLockNesting
000608  29ff              CMP      r1,#0xff
00060a  d201              BCS      |L1.1552|
;;;706                    OSLockNesting++;                 /* Increment lock nesting level                       */
00060c  1c49              ADDS     r1,r1,#1
00060e  70e1              STRB     r1,[r4,#3]  ; OSLockNesting
                  |L1.1552|
;;;707                }
;;;708            }
;;;709            OS_EXIT_CRITICAL();
000610  e8bde8bd          POP      {r4,lr}
000614  f7fff7ff          B.W      OS_CPU_SR_Restore
                  |L1.1560|
;;;710        }
;;;711    }
000618  bd10              POP      {r4,pc}
;;;712    #endif
                          ENDP

                  OSSchedUnlock PROC
;;;731    void  OSSchedUnlock (void)
;;;732    {
00061a  b510              PUSH     {r4,lr}
;;;733    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;734        OS_CPU_SR  cpu_sr = 0;
;;;735    #endif
;;;736    
;;;737    
;;;738    
;;;739        if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
00061c  4c88              LDR      r4,|L1.2112|
00061e  79e0              LDRB     r0,[r4,#7]  ; OSRunning
000620  2801              CMP      r0,#1
000622  d11a              BNE      |L1.1626|
;;;740            OS_ENTER_CRITICAL();
000624  f7fff7ff          BL       OS_CPU_SR_Save
;;;741            if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
000628  78e1              LDRB     r1,[r4,#3]  ; OSLockNesting
00062a  b191              CBZ      r1,|L1.1618|
;;;742                OSLockNesting--;                               /* Decrement lock nesting level             */
00062c  1e49              SUBS     r1,r1,#1
00062e  b2c9              UXTB     r1,r1
000630  70e1              STRB     r1,[r4,#3]  ; OSLockNesting
;;;743                if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
000632  b951              CBNZ     r1,|L1.1610|
;;;744                    if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
000634  78a1              LDRB     r1,[r4,#2]  ; OSIntNesting
000636  b921              CBNZ     r1,|L1.1602|
;;;745                        OS_EXIT_CRITICAL();
000638  f7fff7ff          BL       OS_CPU_SR_Restore
;;;746                        OS_Sched();                            /* See if a HPT is ready                    */
00063c  e8bde8bd          POP      {r4,lr}
000640  e7fe              B        OS_Sched
                  |L1.1602|
;;;747                    } else {
;;;748                        OS_EXIT_CRITICAL();
000642  e8bde8bd          POP      {r4,lr}
000646  f7fff7ff          B.W      OS_CPU_SR_Restore
                  |L1.1610|
;;;749                    }
;;;750                } else {
;;;751                    OS_EXIT_CRITICAL();
00064a  e8bde8bd          POP      {r4,lr}
00064e  f7fff7ff          B.W      OS_CPU_SR_Restore
                  |L1.1618|
;;;752                }
;;;753            } else {
;;;754                OS_EXIT_CRITICAL();
000652  e8bde8bd          POP      {r4,lr}
000656  f7fff7ff          B.W      OS_CPU_SR_Restore
                  |L1.1626|
;;;755            }
;;;756        }
;;;757    }
00065a  bd10              POP      {r4,pc}
;;;758    #endif
                          ENDP

                  OSStart PROC
;;;781    void  OSStart (void)
;;;782    {
00065c  b510              PUSH     {r4,lr}
;;;783        if (OSRunning == OS_FALSE) {
00065e  4c78              LDR      r4,|L1.2112|
000660  79e0              LDRB     r0,[r4,#7]  ; OSRunning
000662  2800              CMP      r0,#0
000664  d10d              BNE      |L1.1666|
;;;784            OS_SchedNew();                               /* Find highest priority's task priority number   */
000666  f7fff7ff          BL       OS_SchedNew
;;;785            OSPrioCur     = OSPrioHighRdy;
00066a  7960              LDRB     r0,[r4,#5]  ; OSPrioHighRdy
00066c  7120              STRB     r0,[r4,#4]  ; OSPrioCur
;;;786            OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
00066e  497b              LDR      r1,|L1.2140|
000670  3980              SUBS     r1,r1,#0x80
000672  f851f851          LDR      r0,[r1,r0,LSL #2]
000676  62e0              STR      r0,[r4,#0x2c]  ; OSTCBHighRdy
;;;787            OSTCBCur      = OSTCBHighRdy;
000678  6260              STR      r0,[r4,#0x24]  ; OSTCBCur
;;;788            OSStartHighRdy();                            /* Execute target specific code to start task     */
00067a  e8bde8bd          POP      {r4,lr}
00067e  f7fff7ff          B.W      OSStartHighRdy
                  |L1.1666|
;;;789        }
;;;790    }
000682  bd10              POP      {r4,pc}
;;;791    /*$PAGE*/
                          ENDP

                  OSStatInit PROC
;;;813    void  OSStatInit (void)
;;;814    {
000684  b510              PUSH     {r4,lr}
;;;815    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;816        OS_CPU_SR  cpu_sr = 0;
;;;817    #endif
;;;818    
;;;819    
;;;820    
;;;821        OSTimeDly(2);                                /* Synchronize with clock tick                        */
000686  2002              MOVS     r0,#2
000688  f7fff7ff          BL       OSTimeDly
;;;822        OS_ENTER_CRITICAL();
00068c  f7fff7ff          BL       OS_CPU_SR_Save
;;;823        OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
000690  4c6b              LDR      r4,|L1.2112|
000692  2100              MOVS     r1,#0
000694  6221              STR      r1,[r4,#0x20]  ; OSIdleCtr
;;;824        OS_EXIT_CRITICAL();
000696  f7fff7ff          BL       OS_CPU_SR_Restore
;;;825        OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
00069a  2064              MOVS     r0,#0x64
00069c  f7fff7ff          BL       OSTimeDly
;;;826        OS_ENTER_CRITICAL();
0006a0  f7fff7ff          BL       OS_CPU_SR_Save
;;;827        OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
0006a4  6a21              LDR      r1,[r4,#0x20]  ; OSIdleCtr
0006a6  6161              STR      r1,[r4,#0x14]  ; OSIdleCtrMax
;;;828        OSStatRdy    = OS_TRUE;
0006a8  2101              MOVS     r1,#1
0006aa  7061              STRB     r1,[r4,#1]  ; OSStatRdy
;;;829        OS_EXIT_CRITICAL();
0006ac  e8bde8bd          POP      {r4,lr}
0006b0  f7fff7ff          B.W      OS_CPU_SR_Restore
;;;830    }
;;;831    #endif
                          ENDP

                  OSTimeTick PROC
;;;847    void  OSTimeTick (void)
;;;848    {
0006b4  e92de92d          PUSH     {r4-r8,lr}
;;;849        OS_TCB    *ptcb;
;;;850    #if OS_TICK_STEP_EN > 0
;;;851        BOOLEAN    step;
;;;852    #endif
;;;853    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
;;;854        OS_CPU_SR  cpu_sr = 0;
;;;855    #endif
;;;856    
;;;857    
;;;858    
;;;859    #if OS_TIME_TICK_HOOK_EN > 0
;;;860        OSTimeTickHook();                                      /* Call user definable hook                     */
0006b8  f7fff7ff          BL       OSTimeTickHook
;;;861    #endif
;;;862    #if OS_TIME_GET_SET_EN > 0
;;;863        OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
0006bc  f7fff7ff          BL       OS_CPU_SR_Save
;;;864        OSTime++;
0006c0  4f5f              LDR      r7,|L1.2112|
0006c2  6b79              LDR      r1,[r7,#0x34]  ; OSTime
0006c4  1c49              ADDS     r1,r1,#1
0006c6  6379              STR      r1,[r7,#0x34]  ; OSTime
;;;865        OS_EXIT_CRITICAL();
0006c8  f7fff7ff          BL       OS_CPU_SR_Restore
;;;866    #endif
;;;867        if (OSRunning == OS_TRUE) {
0006cc  79f8              LDRB     r0,[r7,#7]  ; OSRunning
0006ce  2801              CMP      r0,#1
0006d0  d145              BNE      |L1.1886|
;;;868    #if OS_TICK_STEP_EN > 0
;;;869            switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
0006d2  7a78              LDRB     r0,[r7,#9]  ; OSTickStepState
0006d4  2501              MOVS     r5,#1
0006d6  2600              MOVS     r6,#0
0006d8  b130              CBZ      r0,|L1.1768|
0006da  2801              CMP      r0,#1
0006dc  d006              BEQ      |L1.1772|
0006de  2802              CMP      r0,#2
0006e0  d106              BNE      |L1.1776|
;;;870                case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
;;;871                     step = OS_TRUE;
;;;872                     break;
;;;873    
;;;874                case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
;;;875                     step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
;;;876                     break;
;;;877    
;;;878                case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
;;;879                     step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
0006e2  2001              MOVS     r0,#1
;;;880                     OSTickStepState = OS_TICK_STEP_WAIT;
0006e4  727d              STRB     r5,[r7,#9]  ; OSTickStepState
;;;881                     break;
0006e6  e005              B        |L1.1780|
                  |L1.1768|
0006e8  2001              MOVS     r0,#1                 ;871
0006ea  e003              B        |L1.1780|
                  |L1.1772|
0006ec  2000              MOVS     r0,#0                 ;875
0006ee  e001              B        |L1.1780|
                  |L1.1776|
;;;882    
;;;883                default:                                       /* Invalid case, correct situation              */
;;;884                     step            = OS_TRUE;
0006f0  2001              MOVS     r0,#1
;;;885                     OSTickStepState = OS_TICK_STEP_DIS;
0006f2  727e              STRB     r6,[r7,#9]  ; OSTickStepState
                  |L1.1780|
;;;886                     break;
;;;887            }
;;;888            if (step == OS_FALSE) {                            /* Return if waiting for step command           */
0006f4  2800              CMP      r0,#0
0006f6  d032              BEQ      |L1.1886|
;;;889                return;
;;;890            }
;;;891    #endif
;;;892            ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
0006f8  6b3c              LDR      r4,[r7,#0x30]  ; OSTCBList
;;;893            while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
0006fa  e02c              B        |L1.1878|
                  |L1.1788|
;;;894                OS_ENTER_CRITICAL();
0006fc  f7fff7ff          BL       OS_CPU_SR_Save
;;;895                if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
000700  8de1              LDRH     r1,[r4,#0x2e]
000702  b329              CBZ      r1,|L1.1872|
;;;896                    if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
000704  1e49              SUBS     r1,r1,#1
000706  0409              LSLS     r1,r1,#16
000708  0c09              LSRS     r1,r1,#16
00070a  85e1              STRH     r1,[r4,#0x2e]
00070c  d120              BNE      |L1.1872|
;;;897                                                               /* Check for timeout                            */
;;;898                        if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
00070e  f894f894          LDRB     r1,[r4,#0x30]
000712  f011f011          TST      r1,#0x37
000716  d006              BEQ      |L1.1830|
;;;899                            ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
000718  f021f021          BIC      r1,r1,#0x37
00071c  f884f884          STRB     r1,[r4,#0x30]
;;;900                            ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
000720  f884f884          STRB     r5,[r4,#0x31]
000724  e001              B        |L1.1834|
                  |L1.1830|
;;;901                        } else {
;;;902                            ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
000726  f884f884          STRB     r6,[r4,#0x31]
                  |L1.1834|
;;;903                        }
;;;904    
;;;905                        if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
00072a  f894f894          LDRB     r1,[r4,#0x30]
00072e  0709              LSLS     r1,r1,#28
000730  d40e              BMI      |L1.1872|
;;;906                            OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
000732  f894f894          LDRB     r1,[r4,#0x36]
000736  79ba              LDRB     r2,[r7,#6]  ; OSRdyGrp
000738  4311              ORRS     r1,r1,r2
00073a  71b9              STRB     r1,[r7,#6]  ; OSRdyGrp
;;;907                            OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00073c  4a40              LDR      r2,|L1.2112|
00073e  f894f894          LDRB     r1,[r4,#0x34]
000742  321c              ADDS     r2,r2,#0x1c
000744  5c53              LDRB     r3,[r2,r1]
000746  f894f894          LDRB     r12,[r4,#0x35]
00074a  ea43ea43          ORR      r3,r3,r12
00074e  5453              STRB     r3,[r2,r1]
                  |L1.1872|
;;;908                        }
;;;909                    }
;;;910                }
;;;911                ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
000750  6964              LDR      r4,[r4,#0x14]
;;;912                OS_EXIT_CRITICAL();
000752  f7fff7ff          BL       OS_CPU_SR_Restore
                  |L1.1878|
000756  f894f894          LDRB     r0,[r4,#0x32]         ;893
00075a  281f              CMP      r0,#0x1f              ;893
00075c  d1ce              BNE      |L1.1788|
                  |L1.1886|
;;;913            }
;;;914        }
;;;915    }
00075e  e468              B        |L1.50|
;;;916    
                          ENDP

                  OSVersion PROC
;;;933    {
;;;934        return (OS_VERSION);
000760  f44ff44f          MOV      r0,#0x11e
;;;935    }
000764  4770              BX       lr
;;;936    
                          ENDP

                  OS_Dummy PROC
;;;952    {
;;;953    }
000766  4770              BX       lr
;;;954    #endif
                          ENDP

                  OS_EventTaskRemove PROC
;;;1135                             OS_EVENT *pevent)
;;;1136   {
000768  b510              PUSH     {r4,lr}
;;;1137       INT8U  y;
;;;1138   
;;;1139   
;;;1140       y                       =  ptcb->OSTCBY;
00076a  f890f890          LDRB     r2,[r0,#0x34]
;;;1141       pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
00076e  f890f890          LDRB     r4,[r0,#0x35]
000772  440a              ADD      r2,r2,r1
000774  7ad3              LDRB     r3,[r2,#0xb]
000776  43a3              BICS     r3,r3,r4
000778  72d3              STRB     r3,[r2,#0xb]
;;;1142       if (pevent->OSEventTbl[y] == 0) {
00077a  7ad2              LDRB     r2,[r2,#0xb]
00077c  2a00              CMP      r2,#0
00077e  d104              BNE      |L1.1930|
;;;1143           pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
000780  7a8a              LDRB     r2,[r1,#0xa]
000782  f890f890          LDRB     r0,[r0,#0x36]
000786  4382              BICS     r2,r2,r0
000788  728a              STRB     r2,[r1,#0xa]
                  |L1.1930|
;;;1144       }
;;;1145   }
00078a  bd10              POP      {r4,pc}
;;;1146   #endif
                          ENDP

                  OS_EventTaskRdy PROC
;;;985    INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
;;;986    {
00078c  b5f0              PUSH     {r4-r7,lr}
00078e  4605              MOV      r5,r0
;;;987        OS_TCB  *ptcb;
;;;988        INT8U    y;
;;;989        INT8U    x;
;;;990        INT8U    prio;
;;;991    #if OS_LOWEST_PRIO > 63
;;;992        INT16U  *ptbl;
;;;993    #endif
;;;994    
;;;995    
;;;996    #if OS_LOWEST_PRIO <= 63
;;;997        y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
000790  7aa8              LDRB     r0,[r5,#0xa]
000792  4c33              LDR      r4,|L1.2144|
000794  5c20              LDRB     r0,[r4,r0]
;;;998        x    = OSUnMapTbl[pevent->OSEventTbl[y]];
000796  182e              ADDS     r6,r5,r0
000798  7af6              LDRB     r6,[r6,#0xb]
00079a  5da4              LDRB     r4,[r4,r6]
;;;999        prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
00079c  eb04eb04          ADD      r4,r4,r0,LSL #3
0007a0  b2e6              UXTB     r6,r4
;;;1000   #else
;;;1001       if ((pevent->OSEventGrp & 0xFF) != 0) {             /* Find HPT waiting for message                */
;;;1002           y = OSUnMapTbl[ pevent->OSEventGrp & 0xFF];
;;;1003       } else {
;;;1004           y = OSUnMapTbl[(pevent->OSEventGrp >> 8) & 0xFF] + 8;
;;;1005       }
;;;1006       ptbl = &pevent->OSEventTbl[y];
;;;1007       if ((*ptbl & 0xFF) != 0) {
;;;1008           x = OSUnMapTbl[*ptbl & 0xFF];
;;;1009       } else {
;;;1010           x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
;;;1011       }
;;;1012       prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
;;;1013   #endif
;;;1014   
;;;1015       ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
0007a2  4c2e              LDR      r4,|L1.2140|
0007a4  3c80              SUBS     r4,r4,#0x80
0007a6  f854f854          LDR      r4,[r4,r6,LSL #2]
;;;1016       ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
0007aa  2700              MOVS     r7,#0
0007ac  3424              ADDS     r4,r4,#0x24
0007ae  8167              STRH     r7,[r4,#0xa]
;;;1017   #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
;;;1018       ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
0007b0  6021              STR      r1,[r4,#0]
;;;1019   #else
;;;1020       pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
;;;1021   #endif
;;;1022       ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
0007b2  7b21              LDRB     r1,[r4,#0xc]
0007b4  4391              BICS     r1,r1,r2
0007b6  7321              STRB     r1,[r4,#0xc]
;;;1023       ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
0007b8  7363              STRB     r3,[r4,#0xd]
;;;1024                                                           /* See if task is ready (could be susp'd)      */
;;;1025       if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
0007ba  7b21              LDRB     r1,[r4,#0xc]
0007bc  3c24              SUBS     r4,r4,#0x24
0007be  0709              LSLS     r1,r1,#28
0007c0  d40c              BMI      |L1.2012|
;;;1026           OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
0007c2  4a1f              LDR      r2,|L1.2112|
0007c4  f894f894          LDRB     r1,[r4,#0x36]
0007c8  7993              LDRB     r3,[r2,#6]  ; OSRdyGrp
0007ca  4319              ORRS     r1,r1,r3
0007cc  7191              STRB     r1,[r2,#6]  ; OSRdyGrp
;;;1027           OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
0007ce  f102f102          ADD      r1,r2,#0x1c
0007d2  5c0a              LDRB     r2,[r1,r0]
0007d4  f894f894          LDRB     r3,[r4,#0x35]
0007d8  431a              ORRS     r2,r2,r3
0007da  540a              STRB     r2,[r1,r0]
                  |L1.2012|
;;;1028       }
;;;1029   
;;;1030       OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
0007dc  4629              MOV      r1,r5
0007de  4620              MOV      r0,r4
0007e0  f7fff7ff          BL       OS_EventTaskRemove
;;;1031   #if (OS_EVENT_MULTI_EN > 0)
;;;1032       if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
0007e4  6a21              LDR      r1,[r4,#0x20]
0007e6  b119              CBZ      r1,|L1.2032|
;;;1033           OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
0007e8  4620              MOV      r0,r4
0007ea  f7fff7ff          BL       OS_EventTaskRemoveMulti
;;;1034           ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
0007ee  61e5              STR      r5,[r4,#0x1c]
                  |L1.2032|
;;;1035       }
;;;1036   #endif
;;;1037   
;;;1038       return (prio);
0007f0  4630              MOV      r0,r6
;;;1039   }
0007f2  bdf0              POP      {r4-r7,pc}
;;;1040   #endif
                          ENDP

                  OS_EventTaskWait PROC
;;;1057   void  OS_EventTaskWait (OS_EVENT *pevent)
;;;1058   {
0007f4  b530              PUSH     {r4,r5,lr}
;;;1059       INT8U  y;
;;;1060   
;;;1061   
;;;1062       OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
0007f6  4c12              LDR      r4,|L1.2112|
0007f8  6a61              LDR      r1,[r4,#0x24]  ; OSTCBCur
0007fa  f841f841          STR      r0,[r1,#0x1c]!
;;;1063   
;;;1064       pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
0007fe  7e0b              LDRB     r3,[r1,#0x18]
000800  f100f100          ADD      r2,r0,#0xb
000804  5c9d              LDRB     r5,[r3,r2]
000806  7e49              LDRB     r1,[r1,#0x19]
000808  430d              ORRS     r5,r5,r1
00080a  549d              STRB     r5,[r3,r2]
;;;1065       pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
00080c  6a61              LDR      r1,[r4,#0x24]  ; OSTCBCur
00080e  7a82              LDRB     r2,[r0,#0xa]
000810  3134              ADDS     r1,r1,#0x34
000812  788b              LDRB     r3,[r1,#2]
000814  431a              ORRS     r2,r2,r3
000816  7282              STRB     r2,[r0,#0xa]
;;;1066   
;;;1067       y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
000818  7808              LDRB     r0,[r1,#0]
;;;1068       OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
00081a  f104f104          ADD      r2,r4,#0x1c
00081e  5c13              LDRB     r3,[r2,r0]
000820  784d              LDRB     r5,[r1,#1]
000822  3934              SUBS     r1,r1,#0x34
000824  43ab              BICS     r3,r3,r5
000826  5413              STRB     r3,[r2,r0]
;;;1069       if (OSRdyTbl[y] == 0) {
000828  5c10              LDRB     r0,[r2,r0]
00082a  2800              CMP      r0,#0
00082c  d11f              BNE      |L1.2158|
;;;1070           OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
00082e  e019              B        |L1.2148|
                  |L1.2096|
000830  75432f4f          DCB      "uC/O"
000834  532d4949          DCB      "S-II"
000838  20537461          DCB      " Sta"
00083c  74000000          DCB      "t\0\0\0"
                  |L1.2112|
000840  00000000          DCD      ||.data||
                  |L1.2116|
000844  00000340          DCD      ||.bss||+0x340
                  |L1.2120|
000848  75432f4f          DCB      "uC/O"
00084c  532d4949          DCB      "S-II"
000850  2049646c          DCB      " Idl"
000854  65000000          DCB      "e\0\0\0"
                  |L1.2136|
000858  00000000          DCD      ||.bss||
                  |L1.2140|
00085c  000005c0          DCD      ||.bss||+0x5c0
                  |L1.2144|
000860  00000000          DCD      ||.constdata||
                  |L1.2148|
000864  f891f891          LDRB     r1,[r1,#0x36]
000868  79a0              LDRB     r0,[r4,#6]  ; OSRdyGrp
00086a  4388              BICS     r0,r0,r1
00086c  71a0              STRB     r0,[r4,#6]  ; OSRdyGrp
                  |L1.2158|
;;;1071       }
;;;1072   }
00086e  bd30              POP      {r4,r5,pc}
;;;1073   #endif
                          ENDP

                  OS_EventWaitListInit PROC
;;;1218   
;;;1219       pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
000870  2200              MOVS     r2,#0
000872  7282              STRB     r2,[r0,#0xa]
;;;1220       ptbl               = &pevent->OSEventTbl[0];
000874  300b              ADDS     r0,r0,#0xb
;;;1221   
;;;1222       for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
000876  2100              MOVS     r1,#0
                  |L1.2168|
;;;1223           *ptbl++ = 0;
000878  f800f800          STRB     r2,[r0],#1
00087c  1c49              ADDS     r1,r1,#1              ;1222
00087e  b2c9              UXTB     r1,r1                 ;1222
000880  2904              CMP      r1,#4                 ;1222
000882  d3f9              BCC      |L1.2168|
;;;1224       }
;;;1225   }
000884  4770              BX       lr
;;;1226   #endif
                          ENDP

                  OS_MemCopy PROC
;;;1581   void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
;;;1582   {
000886  e005              B        |L1.2196|
                  |L1.2184|
;;;1583       while (size > 0) {
;;;1584           *pdest++ = *psrc++;
000888  f811f811          LDRB     r3,[r1],#1
00088c  f800f800          STRB     r3,[r0],#1
;;;1585           size--;
000890  1e52              SUBS     r2,r2,#1
000892  b292              UXTH     r2,r2
                  |L1.2196|
000894  2a00              CMP      r2,#0                 ;1583
000896  d1f7              BNE      |L1.2184|
;;;1586       }
;;;1587   }
000898  4770              BX       lr
;;;1588   /*$PAGE*/
                          ENDP

                  OS_TCBInit PROC
;;;1922   INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
;;;1923   {
00089a  e92de92d          PUSH     {r0-r12,lr}
00089e  e9dde9dd          LDRD     r10,r11,[sp,#0x3c]
0008a2  4606              MOV      r6,r0
0008a4  460d              MOV      r5,r1
0008a6  4690              MOV      r8,r2
0008a8  f8ddf8dd          LDR      r9,[sp,#0x38]
;;;1924       OS_TCB    *ptcb;
;;;1925   #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;1926       OS_CPU_SR  cpu_sr = 0;
;;;1927   #endif
;;;1928   
;;;1929   
;;;1930   
;;;1931       OS_ENTER_CRITICAL();
0008ac  f7fff7ff          BL       OS_CPU_SR_Save
;;;1932       ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
0008b0  4f2f              LDR      r7,|L1.2416|
0008b2  6abc              LDR      r4,[r7,#0x28]  ; OSTCBFreeList
;;;1933       if (ptcb != (OS_TCB *)0) {
0008b4  2c00              CMP      r4,#0
0008b6  d057              BEQ      |L1.2408|
;;;1934           OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
0008b8  3418              ADDS     r4,r4,#0x18
0008ba  f854f854          LDR      r1,[r4,#-4]
0008be  62b9              STR      r1,[r7,#0x28]  ; OSTCBFreeList
;;;1935           OS_EXIT_CRITICAL();
0008c0  f7fff7ff          BL       OS_CPU_SR_Restore
;;;1936           ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
0008c4  f844f844          STR      r5,[r4,#-0x18]
;;;1937           ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
0008c8  76a6              STRB     r6,[r4,#0x1a]
;;;1938           ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
0008ca  2500              MOVS     r5,#0
0008cc  7625              STRB     r5,[r4,#0x18]
;;;1939           ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
0008ce  7665              STRB     r5,[r4,#0x19]
;;;1940           ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
0008d0  82e5              STRH     r5,[r4,#0x16]
;;;1941   
;;;1942   #if OS_TASK_CREATE_EXT_EN > 0
;;;1943           ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
0008d2  f844f844          STR      r10,[r4,#-0x14]
;;;1944           ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
0008d6  f844f844          STR      r9,[r4,#-0xc]
;;;1945           ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
0008da  f844f844          STR      r8,[r4,#-0x10]
;;;1946           ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
0008de  f824f824          STRH     r11,[r4,#-8]
;;;1947           ptcb->OSTCBId            = id;                     /* Store task ID                            */
0008e2  9803              LDR      r0,[sp,#0xc]
0008e4  f824f824          STRH     r0,[r4,#-6]
;;;1948   #else
;;;1949           pext                     = pext;                   /* Prevent compiler warning if not used     */
;;;1950           stk_size                 = stk_size;
;;;1951           pbos                     = pbos;
;;;1952           opt                      = opt;
;;;1953           id                       = id;
;;;1954   #endif
;;;1955   
;;;1956   #if OS_TASK_DEL_EN > 0
;;;1957           ptcb->OSTCBDelReq        = OS_ERR_NONE;
0008e8  77e5              STRB     r5,[r4,#0x1f]
;;;1958   #endif
;;;1959   
;;;1960   #if OS_LOWEST_PRIO <= 63
;;;1961           ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
0008ea  08f0              LSRS     r0,r6,#3
0008ec  7720              STRB     r0,[r4,#0x1c]
;;;1962           ptcb->OSTCBX             = (INT8U)(prio & 0x07);
0008ee  f006f006          AND      r0,r6,#7
0008f2  76e0              STRB     r0,[r4,#0x1b]
;;;1963           ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
0008f4  7f23              LDRB     r3,[r4,#0x1c]
0008f6  2201              MOVS     r2,#1
0008f8  fa02fa02          LSL      r1,r2,r3
0008fc  77a1              STRB     r1,[r4,#0x1e]
;;;1964           ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
0008fe  4082              LSLS     r2,r2,r0
000900  7762              STRB     r2,[r4,#0x1d]
;;;1965   #else
;;;1966           ptcb->OSTCBY             = (INT8U)((prio >> 4) & 0xFF); /* Pre-compute X, Y, BitX and BitY     */
;;;1967           ptcb->OSTCBX             = (INT8U) (prio & 0x0F);
;;;1968           ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
;;;1969           ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
;;;1970   #endif
;;;1971   
;;;1972   #if (OS_EVENT_EN)
;;;1973           ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
000902  6065              STR      r5,[r4,#4]
;;;1974   #if (OS_EVENT_MULTI_EN > 0)
;;;1975           ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
000904  60a5              STR      r5,[r4,#8]
;;;1976   #endif
;;;1977   #endif
;;;1978   
;;;1979   #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
;;;1980           ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
000906  6125              STR      r5,[r4,#0x10]
;;;1981   #endif
;;;1982   
;;;1983   #if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
;;;1984           ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
000908  60e5              STR      r5,[r4,#0xc]
;;;1985   #endif
;;;1986   
;;;1987   #if OS_TASK_PROFILE_EN > 0
;;;1988           ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
00090a  6225              STR      r5,[r4,#0x20]
;;;1989           ptcb->OSTCBCyclesStart = 0L;
00090c  62a5              STR      r5,[r4,#0x28]
;;;1990           ptcb->OSTCBCyclesTot   = 0L;
00090e  6265              STR      r5,[r4,#0x24]
;;;1991           ptcb->OSTCBStkBase     = (OS_STK *)0;
000910  62e5              STR      r5,[r4,#0x2c]
;;;1992           ptcb->OSTCBStkUsed     = 0L;
000912  6325              STR      r5,[r4,#0x30]
;;;1993   #endif
;;;1994   
;;;1995   #if OS_TASK_NAME_SIZE > 1
;;;1996           ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
000914  203f              MOVS     r0,#0x3f
000916  f884f884          STRB     r0,[r4,#0x34]
;;;1997           ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
00091a  f884f884          STRB     r5,[r4,#0x35]
00091e  3c18              SUBS     r4,r4,#0x18
;;;1998   #endif
;;;1999   
;;;2000           OSTCBInitHook(ptcb);
000920  4620              MOV      r0,r4
000922  f7fff7ff          BL       OSTCBInitHook
;;;2001   
;;;2002           OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
000926  4620              MOV      r0,r4
000928  f7fff7ff          BL       OSTaskCreateHook
;;;2003   
;;;2004           OS_ENTER_CRITICAL();
00092c  f7fff7ff          BL       OS_CPU_SR_Save
;;;2005           OSTCBPrioTbl[prio] = ptcb;
000930  4910              LDR      r1,|L1.2420|
000932  f841f841          STR      r4,[r1,r6,LSL #2]
;;;2006           ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
000936  6b39              LDR      r1,[r7,#0x30]  ; OSTCBList
000938  6161              STR      r1,[r4,#0x14]
;;;2007           ptcb->OSTCBPrev    = (OS_TCB *)0;
00093a  61a5              STR      r5,[r4,#0x18]
;;;2008           if (OSTCBList != (OS_TCB *)0) {
00093c  b101              CBZ      r1,|L1.2368|
;;;2009               OSTCBList->OSTCBPrev = ptcb;
00093e  618c              STR      r4,[r1,#0x18]
                  |L1.2368|
;;;2010           }
;;;2011           OSTCBList               = ptcb;
000940  633c              STR      r4,[r7,#0x30]  ; OSTCBList
;;;2012           OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
000942  3434              ADDS     r4,r4,#0x34
000944  78a1              LDRB     r1,[r4,#2]
000946  79ba              LDRB     r2,[r7,#6]  ; OSRdyGrp
000948  4311              ORRS     r1,r1,r2
00094a  71b9              STRB     r1,[r7,#6]  ; OSRdyGrp
;;;2013           OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00094c  4a08              LDR      r2,|L1.2416|
00094e  7821              LDRB     r1,[r4,#0]
000950  321c              ADDS     r2,r2,#0x1c
000952  5c53              LDRB     r3,[r2,r1]
000954  7864              LDRB     r4,[r4,#1]
000956  4323              ORRS     r3,r3,r4
000958  5453              STRB     r3,[r2,r1]
;;;2014           OSTaskCtr++;                                       /* Increment the #tasks counter             */
00095a  7a39              LDRB     r1,[r7,#8]  ; OSTaskCtr
00095c  1c49              ADDS     r1,r1,#1
00095e  7239              STRB     r1,[r7,#8]  ; OSTaskCtr
;;;2015           OS_EXIT_CRITICAL();
000960  f7fff7ff          BL       OS_CPU_SR_Restore
;;;2016           return (OS_ERR_NONE);
000964  2000              MOVS     r0,#0
;;;2017       }
;;;2018       OS_EXIT_CRITICAL();
;;;2019       return (OS_ERR_TASK_NO_MORE_TCB);
;;;2020   }
000966  e443              B        |L1.496|
                  |L1.2408|
000968  f7fff7ff          BL       OS_CPU_SR_Restore
00096c  2042              MOVS     r0,#0x42              ;2019
00096e  e43f              B        |L1.496|
                          ENDP

                  |L1.2416|
000970  00000000          DCD      ||.data||
                  |L1.2420|
000974  00000540          DCD      ||.bss||+0x540

                          AREA ||.data||, DATA, ALIGN=2

                  OSCPUUsage
000000  00                DCB      0x00
                  OSStatRdy
000001  00                DCB      0x00
                  OSIntNesting
000002  00                DCB      0x00
                  OSLockNesting
000003  00                DCB      0x00
                  OSPrioCur
000004  00                DCB      0x00
                  OSPrioHighRdy
000005  00                DCB      0x00
                  OSRdyGrp
000006  00                DCB      0x00
                  OSRunning
000007  00                DCB      0x00
                  OSTaskCtr
000008  00                DCB      0x00
                  OSTickStepState
000009  000000            DCB      0x00,0x00,0x00
                  OSCtxSwCtr
00000c  00000000          DCD      0x00000000
                  OSEventFreeList
000010  00000000          DCD      0x00000000
                  OSIdleCtrMax
000014  00000000          DCD      0x00000000
                  OSIdleCtrRun
000018  00000000          DCD      0x00000000
                  OSRdyTbl
00001c  00000000          DCD      0x00000000
                  OSIdleCtr
000020  00000000          DCD      0x00000000
                  OSTCBCur
000024  00000000          DCD      0x00000000
                  OSTCBFreeList
000028  00000000          DCD      0x00000000
                  OSTCBHighRdy
00002c  00000000          DCD      0x00000000
                  OSTCBList
000030  00000000          DCD      0x00000000
                  OSTime
000034  00000000          DCD      0x00000000

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  OSUnMapTbl
000000  00000100          DCB      0x00,0x00,0x01,0x00
000004  02000100          DCB      0x02,0x00,0x01,0x00
000008  03000100          DCB      0x03,0x00,0x01,0x00
00000c  02000100          DCB      0x02,0x00,0x01,0x00
000010  04000100          DCB      0x04,0x00,0x01,0x00
000014  02000100          DCB      0x02,0x00,0x01,0x00
000018  03000100          DCB      0x03,0x00,0x01,0x00
00001c  02000100          DCB      0x02,0x00,0x01,0x00
000020  05000100          DCB      0x05,0x00,0x01,0x00
000024  02000100          DCB      0x02,0x00,0x01,0x00
000028  03000100          DCB      0x03,0x00,0x01,0x00
00002c  02000100          DCB      0x02,0x00,0x01,0x00
000030  04000100          DCB      0x04,0x00,0x01,0x00
000034  02000100          DCB      0x02,0x00,0x01,0x00
000038  03000100          DCB      0x03,0x00,0x01,0x00
00003c  02000100          DCB      0x02,0x00,0x01,0x00
000040  06000100          DCB      0x06,0x00,0x01,0x00
000044  02000100          DCB      0x02,0x00,0x01,0x00
000048  03000100          DCB      0x03,0x00,0x01,0x00
00004c  02000100          DCB      0x02,0x00,0x01,0x00
000050  04000100          DCB      0x04,0x00,0x01,0x00
000054  02000100          DCB      0x02,0x00,0x01,0x00
000058  03000100          DCB      0x03,0x00,0x01,0x00
00005c  02000100          DCB      0x02,0x00,0x01,0x00
000060  05000100          DCB      0x05,0x00,0x01,0x00
000064  02000100          DCB      0x02,0x00,0x01,0x00
000068  03000100          DCB      0x03,0x00,0x01,0x00
00006c  02000100          DCB      0x02,0x00,0x01,0x00
000070  04000100          DCB      0x04,0x00,0x01,0x00
000074  02000100          DCB      0x02,0x00,0x01,0x00
000078  03000100          DCB      0x03,0x00,0x01,0x00
00007c  02000100          DCB      0x02,0x00,0x01,0x00
000080  07000100          DCB      0x07,0x00,0x01,0x00
000084  02000100          DCB      0x02,0x00,0x01,0x00
000088  03000100          DCB      0x03,0x00,0x01,0x00
00008c  02000100          DCB      0x02,0x00,0x01,0x00
000090  04000100          DCB      0x04,0x00,0x01,0x00
000094  02000100          DCB      0x02,0x00,0x01,0x00
000098  03000100          DCB      0x03,0x00,0x01,0x00
00009c  02000100          DCB      0x02,0x00,0x01,0x00
0000a0  05000100          DCB      0x05,0x00,0x01,0x00
0000a4  02000100          DCB      0x02,0x00,0x01,0x00
0000a8  03000100          DCB      0x03,0x00,0x01,0x00
0000ac  02000100          DCB      0x02,0x00,0x01,0x00
0000b0  04000100          DCB      0x04,0x00,0x01,0x00
0000b4  02000100          DCB      0x02,0x00,0x01,0x00
0000b8  03000100          DCB      0x03,0x00,0x01,0x00
0000bc  02000100          DCB      0x02,0x00,0x01,0x00
0000c0  06000100          DCB      0x06,0x00,0x01,0x00
0000c4  02000100          DCB      0x02,0x00,0x01,0x00
0000c8  03000100          DCB      0x03,0x00,0x01,0x00
0000cc  02000100          DCB      0x02,0x00,0x01,0x00
0000d0  04000100          DCB      0x04,0x00,0x01,0x00
0000d4  02000100          DCB      0x02,0x00,0x01,0x00
0000d8  03000100          DCB      0x03,0x00,0x01,0x00
0000dc  02000100          DCB      0x02,0x00,0x01,0x00
0000e0  05000100          DCB      0x05,0x00,0x01,0x00
0000e4  02000100          DCB      0x02,0x00,0x01,0x00
0000e8  03000100          DCB      0x03,0x00,0x01,0x00
0000ec  02000100          DCB      0x02,0x00,0x01,0x00
0000f0  04000100          DCB      0x04,0x00,0x01,0x00
0000f4  02000100          DCB      0x02,0x00,0x01,0x00
0000f8  03000100          DCB      0x03,0x00,0x01,0x00
0000fc  02000100          DCB      0x02,0x00,0x01,0x00

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  OSEventTbl
                          %        320
                  OSTaskStatStk
                          %        512
                  OSTaskIdleStk
                          %        512
                  OSTCBPrioTbl
                          %        128
                  OSTCBTbl
                          %        2024

                          AREA |area_number.5|, DATA, NOINIT, ALIGN=2

                          EXPORTAS |area_number.5|, ||.bss||
                  OSFlagTbl
                          %        140

                          AREA |area_number.6|, DATA, ALIGN=2

                          EXPORTAS |area_number.6|, ||.data||
                  OSFlagFreeList
000000  00000000          DCD      0x00000000
