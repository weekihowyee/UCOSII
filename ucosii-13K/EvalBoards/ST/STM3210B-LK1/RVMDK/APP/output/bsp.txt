; generated by ARM/Thumb C/C++ Compiler with , RVCT3.1 [Build 919] for uVision
; commandline ArmCC [--debug -c --asm --interleave -o.\output\bsp.o --depend=.\output\bsp.d --device=DARMSTM --apcs=interwork -O1 -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -IC:\Keil\ARM\INC\ST\STM32F10x --omf_browse=.\output\bsp.crf ..\BSP\bsp.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;114    PUTCHAR_PROTOTYPE
;;;115    {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;116      /* Write a character to the USART */
;;;117      USART_SendData(USART1, (u8) ch);
000004  4dea              LDR      r5,|L1.944|
000006  b2e1              UXTB     r1,r4
000008  4628              MOV      r0,r5
00000a  f7fff7ff          BL       USART_SendData
                  |L1.14|
;;;118    
;;;119      /* Loop until the end of transmission */
;;;120      while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET)
00000e  2180              MOVS     r1,#0x80
000010  4628              MOV      r0,r5
000012  f7fff7ff          BL       USART_GetFlagStatus
000016  2800              CMP      r0,#0
000018  d0f9              BEQ      |L1.14|
;;;121      {
;;;122      }
;;;123        return ch;
00001a  4620              MOV      r0,r4
;;;124    }
00001c  bd70              POP      {r4-r6,pc}
;;;125    
                          ENDP

                  NVIC_Configuration PROC
;;;126    void NVIC_Configuration(void)
;;;127    {
00001e  b538              PUSH     {r3-r5,lr}
;;;128     NVIC_InitTypeDef NVIC_InitStructure; 
;;;129    
;;;130      NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);   
000020  2100              MOVS     r1,#0
000022  f04ff04f          MOV      r0,#0x8000000
000026  f7fff7ff          BL       NVIC_SetVectorTable
;;;131    
;;;132      /* Enable the USART1 Interrupt */
;;;133      NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQChannel;
00002a  2026              MOVS     r0,#0x26
00002c  f88df88d          STRB     r0,[sp,#0]
;;;134      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
000030  2001              MOVS     r0,#1
000032  f88df88d          STRB     r0,[sp,#1]
;;;135      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 5;
000036  2105              MOVS     r1,#5
000038  f88df88d          STRB     r1,[sp,#2]
;;;136      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00003c  f88df88d          STRB     r0,[sp,#3]
;;;137    
;;;138      NVIC_Init(&NVIC_InitStructure); 
000040  4668              MOV      r0,sp
000042  f7fff7ff          BL       NVIC_Init
;;;139    
;;;140      USART_ITConfig(USART2,USART_IT_RXNE,ENABLE);
000046  4ddb              LDR      r5,|L1.948|
000048  f240f240          MOV      r4,#0x525
00004c  2201              MOVS     r2,#1
00004e  4621              MOV      r1,r4
000050  4628              MOV      r0,r5
000052  f7fff7ff          BL       USART_ITConfig
;;;141      USART_ClearITPendingBit(USART2,USART_IT_RXNE); 
000056  4621              MOV      r1,r4
000058  4628              MOV      r0,r5
00005a  f7fff7ff          BL       USART_ClearITPendingBit
;;;142    }
00005e  bd38              POP      {r3-r5,pc}
;;;143    
                          ENDP

                  UART2_int PROC
;;;146    void UART2_int(void)
;;;147    {
000060  b530              PUSH     {r4,r5,lr}
000062  b085              SUB      sp,sp,#0x14
;;;148    	  USART_InitTypeDef USART_InitStructure;
;;;149    	  GPIO_InitTypeDef GPIO_InitStructure;
;;;150    
;;;151      USART_InitStructure.USART_BaudRate = 9600;
000064  f44ff44f          MOV      r0,#0x2580
000068  9001              STR      r0,[sp,#4]
;;;152      USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00006a  2000              MOVS     r0,#0
00006c  f8adf8ad          STRH     r0,[sp,#8]
;;;153      USART_InitStructure.USART_StopBits = USART_StopBits_1;
000070  f8adf8ad          STRH     r0,[sp,#0xa]
;;;154      USART_InitStructure.USART_Parity = USART_Parity_No ;
000074  f8adf8ad          STRH     r0,[sp,#0xc]
;;;155      USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000078  f8adf8ad          STRH     r0,[sp,#0x10]
;;;156      USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00007c  200c              MOVS     r0,#0xc
00007e  f8adf8ad          STRH     r0,[sp,#0xe]
;;;157    
;;;158    
;;;159    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
000082  2101              MOVS     r1,#1
000084  0448              LSLS     r0,r1,#17
000086  f7fff7ff          BL       RCC_APB1PeriphClockCmd
;;;160    
;;;161      /* Configure USARTx_Tx as alternate function push-pull */
;;;162      GPIO_StructInit(&GPIO_InitStructure);
00008a  4668              MOV      r0,sp
00008c  f7fff7ff          BL       GPIO_StructInit
;;;163      GPIO_InitStructure.GPIO_Pin = GPIO_UART2TxPin;
000090  2404              MOVS     r4,#4
000092  f8adf8ad          STRH     r4,[sp,#0]
;;;164      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000096  2003              MOVS     r0,#3
000098  f88df88d          STRB     r0,[sp,#2]
;;;165      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00009c  2018              MOVS     r0,#0x18
00009e  f88df88d          STRB     r0,[sp,#3]
;;;166      GPIO_Init(GPIOA, &GPIO_InitStructure);
0000a2  4dc5              LDR      r5,|L1.952|
0000a4  4669              MOV      r1,sp
0000a6  4628              MOV      r0,r5
0000a8  f7fff7ff          BL       GPIO_Init
;;;167    
;;;168      /* Configure USARTx_Rx as input floating */
;;;169      GPIO_StructInit(&GPIO_InitStructure);
0000ac  4668              MOV      r0,sp
0000ae  f7fff7ff          BL       GPIO_StructInit
;;;170      GPIO_InitStructure.GPIO_Pin = GPIO_UART2RxPin; 
0000b2  2008              MOVS     r0,#8
0000b4  f8adf8ad          STRH     r0,[sp,#0]
;;;171      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
0000b8  f88df88d          STRB     r4,[sp,#3]
;;;172      GPIO_Init(GPIOA, &GPIO_InitStructure);  
0000bc  4669              MOV      r1,sp
0000be  4628              MOV      r0,r5
0000c0  f7fff7ff          BL       GPIO_Init
;;;173      
;;;174    	USART_Init(USART2,&USART_InitStructure); 
0000c4  4cbb              LDR      r4,|L1.948|
0000c6  a901              ADD      r1,sp,#4
0000c8  4620              MOV      r0,r4
0000ca  f7fff7ff          BL       USART_Init
;;;175    	USART_Cmd(USART2, ENABLE);  
0000ce  2101              MOVS     r1,#1
0000d0  4620              MOV      r0,r4
0000d2  f7fff7ff          BL       USART_Cmd
;;;176    	NVIC_Configuration();	
0000d6  f7fff7ff          BL       NVIC_Configuration
;;;177    	//USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);	
;;;178    
;;;179    	
;;;180    }
0000da  b005              ADD      sp,sp,#0x14
0000dc  bd30              POP      {r4,r5,pc}
;;;181    /*
                          ENDP

                  GPIO_Configuration PROC
;;;271    void GPIO_Configuration(void)
;;;272    {
0000de  b538              PUSH     {r3-r5,lr}
;;;273      GPIO_InitTypeDef GPIO_InitStructure;
;;;274    
;;;275      /* Configure USARTx_Tx as alternate function push-pull */
;;;276      GPIO_InitStructure.GPIO_Pin = GPIO_TxPin;
0000e0  f44ff44f          MOV      r0,#0x200
0000e4  f8adf8ad          STRH     r0,[sp,#0]
;;;277      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000e8  2003              MOVS     r0,#3
0000ea  f88df88d          STRB     r0,[sp,#2]
;;;278      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
0000ee  2018              MOVS     r0,#0x18
0000f0  f88df88d          STRB     r0,[sp,#3]
;;;279      GPIO_Init(GPIOA, &GPIO_InitStructure);
0000f4  4cb0              LDR      r4,|L1.952|
0000f6  4669              MOV      r1,sp
0000f8  4620              MOV      r0,r4
0000fa  f7fff7ff          BL       GPIO_Init
;;;280    
;;;281      /* Configure USARTx_Rx as input floating */
;;;282      GPIO_InitStructure.GPIO_Pin = GPIO_RxPin;
0000fe  1520              ASRS     r0,r4,#20
000100  f8adf8ad          STRH     r0,[sp,#0]
;;;283      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000104  2004              MOVS     r0,#4
000106  f88df88d          STRB     r0,[sp,#3]
;;;284      GPIO_Init(GPIOA, &GPIO_InitStructure);  
00010a  4669              MOV      r1,sp
00010c  4620              MOV      r0,r4
00010e  f7fff7ff          BL       GPIO_Init
;;;285    
;;;286    }
000112  bd38              POP      {r3-r5,pc}
;;;287    
                          ENDP

                  BSP_PB_Init PROC
;;;454    static  void  BSP_PB_Init (void)
;;;455    {
000114  b538              PUSH     {r3-r5,lr}
;;;456        GPIO_InitTypeDef  gpio_init;
;;;457    
;;;458    
;;;459        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
000116  2101              MOVS     r1,#1
000118  2004              MOVS     r0,#4
00011a  f7fff7ff          BL       RCC_APB2PeriphClockCmd
;;;460        GPIO_StructInit(&gpio_init);
00011e  4668              MOV      r0,sp
000120  f7fff7ff          BL       GPIO_StructInit
;;;461        gpio_init.GPIO_Pin  = BSP_GPIOA_PB_KEY1;
000124  2001              MOVS     r0,#1
000126  f8adf8ad          STRH     r0,[sp,#0]
;;;462        gpio_init.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00012a  2404              MOVS     r4,#4
00012c  f88df88d          STRB     r4,[sp,#3]
;;;463        GPIO_Init(GPIOD, &gpio_init);
000130  4da2              LDR      r5,|L1.956|
000132  4669              MOV      r1,sp
000134  4628              MOV      r0,r5
000136  f7fff7ff          BL       GPIO_Init
;;;464    
;;;465        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
00013a  2101              MOVS     r1,#1
00013c  2008              MOVS     r0,#8
00013e  f7fff7ff          BL       RCC_APB2PeriphClockCmd
;;;466        GPIO_StructInit(&gpio_init);
000142  4668              MOV      r0,sp
000144  f7fff7ff          BL       GPIO_StructInit
;;;467        gpio_init.GPIO_Pin  = BSP_GPIOB_PB_KEY2;
000148  01e0              LSLS     r0,r4,#7
00014a  f8adf8ad          STRH     r0,[sp,#0]
;;;468        gpio_init.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00014e  f88df88d          STRB     r4,[sp,#3]
;;;469        GPIO_Init(GPIOD, &gpio_init);
000152  4669              MOV      r1,sp
000154  4628              MOV      r0,r5
000156  f7fff7ff          BL       GPIO_Init
;;;470    
;;;471    }
00015a  bd38              POP      {r3-r5,pc}
;;;472    
                          ENDP

                  BSP_LED_Init PROC
;;;548    static  void  BSP_LED_Init (void)
;;;549    {
00015c  b508              PUSH     {r3,lr}
;;;550        GPIO_InitTypeDef  gpio_init;
;;;551    
;;;552    
;;;553        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
00015e  2101              MOVS     r1,#1
000160  2008              MOVS     r0,#8
000162  f7fff7ff          BL       RCC_APB2PeriphClockCmd
;;;554    
;;;555        gpio_init.GPIO_Pin   = BSP_GPIOC_LED1 | BSP_GPIOC_LED2 ;
000166  f44ff44f          MOV      r0,#0x300
00016a  f8adf8ad          STRH     r0,[sp,#0]
;;;556        gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
00016e  2003              MOVS     r0,#3
000170  f88df88d          STRB     r0,[sp,#2]
;;;557        gpio_init.GPIO_Mode  = GPIO_Mode_Out_PP;
000174  2010              MOVS     r0,#0x10
000176  f88df88d          STRB     r0,[sp,#3]
;;;558        GPIO_Init(GPIOB, &gpio_init);
00017a  4669              MOV      r1,sp
00017c  4890              LDR      r0,|L1.960|
00017e  f7fff7ff          BL       GPIO_Init
;;;559    }
000182  bd08              POP      {r3,pc}
;;;560    
                          ENDP

                  BSP_ADC_Init PROC
;;;372    static  void  BSP_ADC_Init (void)
;;;373    {
000184  b530              PUSH     {r4,r5,lr}
000186  b087              SUB      sp,sp,#0x1c
;;;374        ADC_InitTypeDef   adc_init;
;;;375        GPIO_InitTypeDef  gpio_init;
;;;376    
;;;377    
;;;378        RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
000188  2101              MOVS     r1,#1
00018a  0248              LSLS     r0,r1,#9
00018c  f7fff7ff          BL       RCC_APB2PeriphClockCmd
;;;379        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
000190  2101              MOVS     r1,#1
000192  2008              MOVS     r0,#8
000194  f7fff7ff          BL       RCC_APB2PeriphClockCmd
;;;380    
;;;381        GPIO_StructInit(&gpio_init);
000198  a801              ADD      r0,sp,#4
00019a  f7fff7ff          BL       GPIO_StructInit
;;;382        gpio_init.GPIO_Pin  = GPIO_Pin_0;
00019e  2501              MOVS     r5,#1
0001a0  f8adf8ad          STRH     r5,[sp,#4]
;;;383        gpio_init.GPIO_Mode = GPIO_Mode_AIN;
0001a4  2400              MOVS     r4,#0
0001a6  f88df88d          STRB     r4,[sp,#7]
;;;384        GPIO_Init(GPIOB, &gpio_init);
0001aa  a901              ADD      r1,sp,#4
0001ac  4884              LDR      r0,|L1.960|
0001ae  f7fff7ff          BL       GPIO_Init
;;;385    
;;;386        adc_init.ADC_Mode               = ADC_Mode_Independent;
0001b2  9402              STR      r4,[sp,#8]
;;;387        adc_init.ADC_ScanConvMode       = DISABLE;
0001b4  f88df88d          STRB     r4,[sp,#0xc]
;;;388        adc_init.ADC_ContinuousConvMode = ENABLE;
0001b8  f88df88d          STRB     r5,[sp,#0xd]
;;;389        adc_init.ADC_ExternalTrigConv   = ADC_ExternalTrigConv_None;
0001bc  f44ff44f          MOV      r0,#0xe0000
0001c0  9004              STR      r0,[sp,#0x10]
;;;390        adc_init.ADC_DataAlign          = ADC_DataAlign_Right;
0001c2  9405              STR      r4,[sp,#0x14]
;;;391        adc_init.ADC_NbrOfChannel       = 1;
0001c4  f88df88d          STRB     r5,[sp,#0x18]
;;;392        ADC_Init(ADC1, &adc_init);
0001c8  4c7e              LDR      r4,|L1.964|
0001ca  a902              ADD      r1,sp,#8
0001cc  4620              MOV      r0,r4
0001ce  f7fff7ff          BL       ADC_Init
;;;393    
;;;394        ADC_RegularChannelConfig(ADC1, ADC_Channel_8, 1, ADC_SampleTime_13Cycles5);
0001d2  2302              MOVS     r3,#2
0001d4  2201              MOVS     r2,#1
0001d6  2108              MOVS     r1,#8
0001d8  4620              MOV      r0,r4
0001da  f7fff7ff          BL       ADC_RegularChannelConfig
;;;395        ADC_Cmd(ADC1, ENABLE);
0001de  2101              MOVS     r1,#1
0001e0  4620              MOV      r0,r4
0001e2  f7fff7ff          BL       ADC_Cmd
;;;396        ADC_SoftwareStartConvCmd(ADC1, ENABLE);
0001e6  2101              MOVS     r1,#1
0001e8  4620              MOV      r0,r4
0001ea  f7fff7ff          BL       ADC_SoftwareStartConvCmd
;;;397    }
0001ee  b007              ADD      sp,sp,#0x1c
0001f0  bd30              POP      {r4,r5,pc}
;;;398    
                          ENDP

                  BSP_Init PROC
;;;197    void  BSP_Init (void)
;;;198    {
0001f2  b51f              PUSH     {r0-r4,lr}
;;;199      USART_InitTypeDef USART_InitStructure;
;;;200      /* USARTx configuration ------------------------------------------------------*/
;;;201      /* USARTx configured as follow:
;;;202            - BaudRate = 115200 baud  
;;;203            - Word Length = 8 Bits
;;;204            - One Stop Bit
;;;205            - No parity
;;;206            - Hardware flow control disabled (RTS and CTS signals)
;;;207            - Receive and transmit enabled
;;;208      */
;;;209      USART_InitStructure.USART_BaudRate = 9600;
0001f4  f44ff44f          MOV      r0,#0x2580
0001f8  9000              STR      r0,[sp,#0]
;;;210      USART_InitStructure.USART_WordLength = USART_WordLength_8b;
0001fa  2000              MOVS     r0,#0
0001fc  f8adf8ad          STRH     r0,[sp,#4]
;;;211      USART_InitStructure.USART_StopBits = USART_StopBits_1;
000200  f8adf8ad          STRH     r0,[sp,#6]
;;;212      USART_InitStructure.USART_Parity = USART_Parity_No ;
000204  f8adf8ad          STRH     r0,[sp,#8]
;;;213      USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000208  f8adf8ad          STRH     r0,[sp,#0xc]
;;;214      USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00020c  200c              MOVS     r0,#0xc
00020e  f8adf8ad          STRH     r0,[sp,#0xa]
;;;215    
;;;216        RCC_DeInit();
000212  f7fff7ff          BL       RCC_DeInit
;;;217        RCC_HSEConfig(RCC_HSE_ON);
000216  f44ff44f          MOV      r4,#0x10000
00021a  4620              MOV      r0,r4
00021c  f7fff7ff          BL       RCC_HSEConfig
;;;218        RCC_WaitForHSEStartUp();
000220  f7fff7ff          BL       RCC_WaitForHSEStartUp
;;;219    
;;;220        RCC_HCLKConfig(RCC_SYSCLK_Div1);
000224  2000              MOVS     r0,#0
000226  f7fff7ff          BL       RCC_HCLKConfig
;;;221        RCC_PCLK2Config(RCC_HCLK_Div1);
00022a  2000              MOVS     r0,#0
00022c  f7fff7ff          BL       RCC_PCLK2Config
;;;222        RCC_PCLK1Config(RCC_HCLK_Div2);
000230  11a0              ASRS     r0,r4,#6
000232  f7fff7ff          BL       RCC_PCLK1Config
;;;223        RCC_ADCCLKConfig(RCC_PCLK2_Div6);
000236  1060              ASRS     r0,r4,#1
000238  f7fff7ff          BL       RCC_ADCCLKConfig
;;;224    
;;;225    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
00023c  2101              MOVS     r1,#1
00023e  0388              LSLS     r0,r1,#14
000240  f7fff7ff          BL       RCC_APB2PeriphClockCmd
;;;226    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
000244  2101              MOVS     r1,#1
000246  2004              MOVS     r0,#4
000248  f7fff7ff          BL       RCC_APB2PeriphClockCmd
;;;227    
;;;228        FLASH_SetLatency(FLASH_Latency_2);
00024c  2002              MOVS     r0,#2
00024e  f7fff7ff          BL       FLASH_SetLatency
;;;229        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
000252  2010              MOVS     r0,#0x10
000254  f7fff7ff          BL       FLASH_PrefetchBufferCmd
;;;230    
;;;231        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
000258  f44ff44f          MOV      r1,#0x1c0000
00025c  4620              MOV      r0,r4
00025e  f7fff7ff          BL       RCC_PLLConfig
;;;232        RCC_PLLCmd(ENABLE);
000262  2001              MOVS     r0,#1
000264  f7fff7ff          BL       RCC_PLLCmd
                  |L1.616|
;;;233    
;;;234        while (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET) {
000268  2039              MOVS     r0,#0x39
00026a  f7fff7ff          BL       RCC_GetFlagStatus
00026e  2800              CMP      r0,#0
000270  d0fa              BEQ      |L1.616|
;;;235            ;
;;;236        }
;;;237    
;;;238        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
000272  2002              MOVS     r0,#2
000274  f7fff7ff          BL       RCC_SYSCLKConfig
                  |L1.632|
;;;239    
;;;240        while (RCC_GetSYSCLKSource() != 0x08) {
000278  f7fff7ff          BL       RCC_GetSYSCLKSource
00027c  2808              CMP      r0,#8
00027e  d1fb              BNE      |L1.632|
;;;241            ;
;;;242        }
;;;243    
;;;244    
;;;245    /*
;;;246    SCU_AHBPeriphClockConfig(__VIC,ENABLE);
;;;247    
;;;248    //VIC_DeInit();
;;;249    VIC_Config(UART1_ITLine, VIC_IRQ, 15);
;;;250    VIC_ITCmd(UART1_ITLine, ENABLE);
;;;251    */
;;;252    
;;;253    
;;;254        BSP_ADC_Init();                                             /* Initialize the I/Os for the ADC      controls.       */
000280  f7fff7ff          BL       BSP_ADC_Init
;;;255        BSP_LED_Init();                                             /* Initialize the I/Os for the LED      controls.       */
000284  f7fff7ff          BL       BSP_LED_Init
;;;256    	BSP_PB_Init();                                              		/* Initialize the I/Os for the PB       control.        */
000288  f7fff7ff          BL       BSP_PB_Init
;;;257       // BSP_Joystick_Init();                                        /* Initialize the I/Os for the Joystick control. 		 */
;;;258    	GPIO_Configuration();
00028c  f7fff7ff          BL       GPIO_Configuration
;;;259    	USART_Init(USART1,&USART_InitStructure); 
000290  4c47              LDR      r4,|L1.944|
000292  4669              MOV      r1,sp
000294  4620              MOV      r0,r4
000296  f7fff7ff          BL       USART_Init
;;;260    	USART_Cmd(USART1, ENABLE);   
00029a  2101              MOVS     r1,#1
00029c  4620              MOV      r0,r4
00029e  f7fff7ff          BL       USART_Cmd
;;;261    	UART2_int();
0002a2  f7fff7ff          BL       UART2_int
;;;262    }
0002a6  bd1f              POP      {r0-r4,pc}
;;;263    
                          ENDP

                  BSP_CPU_ClkFreq PROC
;;;305    CPU_INT32U  BSP_CPU_ClkFreq (void)
;;;306    {
0002a8  b500              PUSH     {lr}
0002aa  b085              SUB      sp,sp,#0x14
;;;307        RCC_ClocksTypeDef  rcc_clocks;
;;;308    
;;;309    
;;;310        RCC_GetClocksFreq(&rcc_clocks);
0002ac  4668              MOV      r0,sp
0002ae  f7fff7ff          BL       RCC_GetClocksFreq
;;;311    
;;;312        return ((CPU_INT32U)rcc_clocks.HCLK_Frequency);
0002b2  9801              LDR      r0,[sp,#4]
;;;313    }
0002b4  b005              ADD      sp,sp,#0x14
0002b6  bd00              POP      {pc}
;;;314    
                          ENDP

                  OS_CPU_SysTickClkFreq PROC
;;;343    
;;;344        freq = BSP_CPU_ClkFreq();
0002b8  e7fe              B        BSP_CPU_ClkFreq
;;;345        return (freq);
;;;346    }
;;;347    
                          ENDP

                  BSP_ADC_GetStatus PROC
;;;417    CPU_INT16U  BSP_ADC_GetStatus (CPU_INT08U  adc)
;;;418    {
0002ba  4601              MOV      r1,r0
;;;419        CPU_INT16U  result;
;;;420    
;;;421    
;;;422        result = 0;
0002bc  2000              MOVS     r0,#0
;;;423    
;;;424        if (adc == 1) {
0002be  2901              CMP      r1,#1
0002c0  d102              BNE      |L1.712|
;;;425            result = ADC_GetConversionValue(ADC1);
0002c2  4840              LDR      r0,|L1.964|
0002c4  f7fff7ff          B.W      ADC_GetConversionValue
                  |L1.712|
;;;426        }
;;;427    
;;;428        return (result);
;;;429    }
0002c8  4770              BX       lr
;;;430    /*
                          ENDP

                  BSP_PB_GetStatus PROC
;;;492    CPU_BOOLEAN  BSP_PB_GetStatus (CPU_INT08U pb)
;;;493    {
0002ca  b510              PUSH     {r4,lr}
;;;494        CPU_BOOLEAN  status;
;;;495        CPU_INT32U   pin;
;;;496    
;;;497        status = DEF_FALSE;
0002cc  2400              MOVS     r4,#0
;;;498    
;;;499        switch (pb) {
0002ce  2801              CMP      r0,#1
0002d0  d00a              BEQ      |L1.744|
0002d2  2802              CMP      r0,#2
0002d4  d106              BNE      |L1.740|
;;;500            case BSP_PB_ID_KEY1:
;;;501                 pin = GPIO_ReadInputDataBit(GPIOA, BSP_GPIOA_PB_KEY1);
;;;502                 if (pin == 0) {
;;;503                     status = 1;
;;;504                 }
;;;505                 break;
;;;506    
;;;507            case BSP_PB_ID_KEY2:
;;;508                 pin = GPIO_ReadInputDataBit(GPIOB, BSP_GPIOB_PB_KEY2);
0002d6  f44ff44f          MOV      r1,#0x200
0002da  4839              LDR      r0,|L1.960|
0002dc  f7fff7ff          BL       GPIO_ReadInputDataBit
;;;509                 if (pin == 0) {
0002e0  b900              CBNZ     r0,|L1.740|
;;;510                     status = 2;
0002e2  2402              MOVS     r4,#2
                  |L1.740|
;;;511                 }
;;;512                 break;
;;;513    
;;;514            default:
;;;515                 break;
;;;516        }
;;;517    
;;;518        return (status);
0002e4  4620              MOV      r0,r4
;;;519    }
0002e6  bd10              POP      {r4,pc}
                  |L1.744|
0002e8  2101              MOVS     r1,#1                 ;501
0002ea  4833              LDR      r0,|L1.952|
0002ec  f7fff7ff          BL       GPIO_ReadInputDataBit
0002f0  2800              CMP      r0,#0                 ;502
0002f2  d1f7              BNE      |L1.740|
0002f4  2401              MOVS     r4,#1                 ;503
0002f6  e7f5              B        |L1.740|
;;;520    
                          ENDP

                  BSP_LED_On PROC
;;;584    {
;;;585        switch (led) {
0002f8  4a31              LDR      r2,|L1.960|
0002fa  b140              CBZ      r0,|L1.782|
0002fc  2801              CMP      r0,#1
0002fe  d00b              BEQ      |L1.792|
000300  2802              CMP      r0,#2
000302  d10e              BNE      |L1.802|
;;;586            case 0:
;;;587                 GPIO_SetBits(GPIOB, BSP_GPIOC_LED1 | BSP_GPIOC_LED2 );
;;;588                 break;
;;;589    
;;;590            case 1:
;;;591                 GPIO_SetBits(GPIOB, BSP_GPIOC_LED1);
;;;592                 break;
;;;593    
;;;594            case 2:
;;;595                 GPIO_SetBits(GPIOB, BSP_GPIOC_LED2);
000304  f44ff44f          MOV      r1,#0x200
000308  4610              MOV      r0,r2
00030a  f7fff7ff          B.W      GPIO_SetBits
                  |L1.782|
00030e  f44ff44f          MOV      r1,#0x300             ;587
000312  4610              MOV      r0,r2                 ;587
000314  f7fff7ff          B.W      GPIO_SetBits
                  |L1.792|
000318  f44ff44f          MOV      r1,#0x100             ;591
00031c  4610              MOV      r0,r2                 ;591
00031e  f7fff7ff          B.W      GPIO_SetBits
                  |L1.802|
;;;596                 break;
;;;597    
;;;598            default:
;;;599                 break;
;;;600        }
;;;601    }
000322  4770              BX       lr
;;;602    
                          ENDP

                  BSP_LED_Off PROC
;;;626    {
;;;627        switch (led) {
000324  4a26              LDR      r2,|L1.960|
000326  b140              CBZ      r0,|L1.826|
000328  2801              CMP      r0,#1
00032a  d00b              BEQ      |L1.836|
00032c  2802              CMP      r0,#2
00032e  d10e              BNE      |L1.846|
;;;628            case 0:
;;;629                 GPIO_ResetBits(GPIOB, BSP_GPIOC_LED1 | BSP_GPIOC_LED2 );
;;;630                 break;
;;;631    
;;;632            case 1:
;;;633                 GPIO_ResetBits(GPIOB, BSP_GPIOC_LED1);
;;;634                 break;
;;;635    
;;;636            case 2:
;;;637                 GPIO_ResetBits(GPIOB, BSP_GPIOC_LED2);
000330  f44ff44f          MOV      r1,#0x200
000334  4610              MOV      r0,r2
000336  f7fff7ff          B.W      GPIO_ResetBits
                  |L1.826|
00033a  f44ff44f          MOV      r1,#0x300             ;629
00033e  4610              MOV      r0,r2                 ;629
000340  f7fff7ff          B.W      GPIO_ResetBits
                  |L1.836|
000344  f44ff44f          MOV      r1,#0x100             ;633
000348  4610              MOV      r0,r2                 ;633
00034a  f7fff7ff          B.W      GPIO_ResetBits
                  |L1.846|
;;;638                 break;
;;;639            default:
;;;640                 break;
;;;641        }
;;;642    }
00034e  4770              BX       lr
;;;643    
                          ENDP

                  BSP_LED_Toggle PROC
;;;666    void  BSP_LED_Toggle (CPU_INT08U led)
;;;667    {
000350  b570              PUSH     {r4-r6,lr}
000352  4604              MOV      r4,r0
;;;668        CPU_INT32U  pins;
;;;669    
;;;670    
;;;671        pins = GPIO_ReadOutputData(GPIOB);
000354  4d1a              LDR      r5,|L1.960|
000356  4628              MOV      r0,r5
000358  f7fff7ff          BL       GPIO_ReadOutputData
;;;672    
;;;673        switch (led) {
00035c  b164              CBZ      r4,|L1.888|
00035e  2c01              CMP      r4,#1
000360  d011              BEQ      |L1.902|
000362  2c02              CMP      r4,#2
000364  d122              BNE      |L1.940|
;;;674            case 0:
;;;675                 BSP_LED_Toggle(1);
;;;676                 BSP_LED_Toggle(2);       
;;;677                 break;
;;;678    
;;;679            case 1:
;;;680                 if ((pins & BSP_GPIOC_LED1) == 0) {
;;;681                     GPIO_SetBits(  GPIOB, BSP_GPIOC_LED1);
;;;682                 } else {
;;;683                     GPIO_ResetBits(GPIOB, BSP_GPIOC_LED1);
;;;684                 }
;;;685                break;
;;;686    
;;;687            case 2:
;;;688                 if ((pins & BSP_GPIOC_LED2) == 0) {
000366  0580              LSLS     r0,r0,#22
000368  f44ff44f          MOV      r1,#0x200
00036c  d419              BMI      |L1.930|
;;;689                     GPIO_SetBits(  GPIOB, BSP_GPIOC_LED2);
00036e  4628              MOV      r0,r5
000370  e8bde8bd          POP      {r4-r6,lr}
000374  f7fff7ff          B.W      GPIO_SetBits
                  |L1.888|
000378  2001              MOVS     r0,#1                 ;675
00037a  f7fff7ff          BL       BSP_LED_Toggle
00037e  e8bde8bd          POP      {r4-r6,lr}            ;676
000382  2002              MOVS     r0,#2                 ;676
000384  e7fe              B        BSP_LED_Toggle
                  |L1.902|
000386  05c0              LSLS     r0,r0,#23             ;680
000388  f44ff44f          MOV      r1,#0x100             ;680
00038c  d404              BMI      |L1.920|
00038e  4628              MOV      r0,r5                 ;681
000390  e8bde8bd          POP      {r4-r6,lr}            ;681
000394  f7fff7ff          B.W      GPIO_SetBits
                  |L1.920|
000398  4628              MOV      r0,r5                 ;683
00039a  e8bde8bd          POP      {r4-r6,lr}            ;683
00039e  f7fff7ff          B.W      GPIO_ResetBits
                  |L1.930|
;;;690                 } else {
;;;691                     GPIO_ResetBits(GPIOB, BSP_GPIOC_LED2);
0003a2  4628              MOV      r0,r5
0003a4  e8bde8bd          POP      {r4-r6,lr}
0003a8  f7fff7ff          B.W      GPIO_ResetBits
                  |L1.940|
;;;692                 }
;;;693                break;
;;;694            default:
;;;695                 break;
;;;696        }
;;;697    }
0003ac  bd70              POP      {r4-r6,pc}
;;;698    
                          ENDP

0003ae  0000              DCW      0x0000
                  |L1.944|
0003b0  40013800          DCD      0x40013800
                  |L1.948|
0003b4  40004400          DCD      0x40004400
                  |L1.952|
0003b8  40010800          DCD      0x40010800
                  |L1.956|
0003bc  40011400          DCD      0x40011400
                  |L1.960|
0003c0  40010c00          DCD      0x40010c00
                  |L1.964|
0003c4  40012400          DCD      0x40012400
