; generated by ARM/Thumb C/C++ Compiler with , RVCT3.1 [Build 919] for uVision
; commandline ArmCC [--debug -c --asm --interleave -o.\output\stm32f10x_adc.o --depend=.\output\stm32f10x_adc.d --device=DARMSTM --apcs=interwork -O1 -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -IC:\Keil\ARM\INC\ST\STM32F10x --omf_browse=.\output\stm32f10x_adc.crf ..\..\..\..\..\CPU\ST\STM32\src\stm32f10x_adc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ADC_DeInit PROC
;;;132    void ADC_DeInit(ADC_TypeDef* ADCx)
;;;133    {
000000  b510              PUSH     {r4,lr}
;;;134      /* Check the parameters */
;;;135      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;136    
;;;137      switch (*(u32*)&ADCx)
000002  49d1              LDR      r1,|L1.840|
000004  1840              ADDS     r0,r0,r1
000006  d011              BEQ      |L1.44|
000008  f44ff44f          MOV      r4,#0x400
00000c  42a0              CMP      r0,r4
00000e  d018              BEQ      |L1.66|
000010  f5b0f5b0          CMP      r0,#0x1800
000014  d11f              BNE      |L1.86|
;;;138      {
;;;139        case ADC1_BASE:
;;;140          /* Enable ADC1 reset state */
;;;141          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
;;;142          /* Release ADC1 from reset state */
;;;143          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
;;;144          break;
;;;145        
;;;146        case ADC2_BASE:
;;;147          /* Enable ADC2 reset state */
;;;148          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, ENABLE);
;;;149          /* Release ADC2 from reset state */
;;;150          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, DISABLE);
;;;151          break;
;;;152          
;;;153        case ADC3_BASE:
;;;154          /* Enable ADC3 reset state */
;;;155          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);
000016  2101              MOVS     r1,#1
000018  03cc              LSLS     r4,r1,#15
00001a  4620              MOV      r0,r4
00001c  f7fff7ff          BL       RCC_APB2PeriphResetCmd
;;;156          /* Release ADC3 from reset state */
;;;157          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);
000020  4620              MOV      r0,r4
000022  e8bde8bd          POP      {r4,lr}
000026  2100              MOVS     r1,#0
000028  f7fff7ff          B.W      RCC_APB2PeriphResetCmd
                  |L1.44|
00002c  2101              MOVS     r1,#1                 ;141
00002e  024c              LSLS     r4,r1,#9              ;141
000030  4620              MOV      r0,r4                 ;141
000032  f7fff7ff          BL       RCC_APB2PeriphResetCmd
000036  4620              MOV      r0,r4                 ;143
000038  e8bde8bd          POP      {r4,lr}               ;143
00003c  2100              MOVS     r1,#0                 ;143
00003e  f7fff7ff          B.W      RCC_APB2PeriphResetCmd
                  |L1.66|
000042  2101              MOVS     r1,#1                 ;148
000044  4620              MOV      r0,r4                 ;148
000046  f7fff7ff          BL       RCC_APB2PeriphResetCmd
00004a  4620              MOV      r0,r4                 ;150
00004c  e8bde8bd          POP      {r4,lr}               ;150
000050  2100              MOVS     r1,#0                 ;150
000052  f7fff7ff          B.W      RCC_APB2PeriphResetCmd
                  |L1.86|
;;;158          break; 
;;;159    
;;;160        default:
;;;161          break;
;;;162      }
;;;163    }
000056  bd10              POP      {r4,pc}
;;;164    
                          ENDP

                  ADC_Init PROC
;;;176    void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
;;;177    {
000058  b510              PUSH     {r4,lr}
;;;178      u32 tmpreg1 = 0;
;;;179      u8 tmpreg2 = 0;
;;;180    
;;;181      /* Check the parameters */
;;;182      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;183      assert_param(IS_ADC_MODE(ADC_InitStruct->ADC_Mode));
;;;184      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
;;;185      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode));  		    
;;;186      assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));   
;;;187      assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
;;;188      assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));
;;;189    
;;;190      /*---------------------------- ADCx CR1 Configuration -----------------*/
;;;191      /* Get the ADCx CR1 value */
;;;192      tmpreg1 = ADCx->CR1;
00005a  6842              LDR      r2,[r0,#4]
;;;193      /* Clear DUALMOD and SCAN bits */
;;;194      tmpreg1 &= CR1_CLEAR_Mask;
00005c  4bbb              LDR      r3,|L1.844|
00005e  401a              ANDS     r2,r2,r3
;;;195      /* Configure ADCx: Dual mode and scan conversion mode */
;;;196      /* Set DUALMOD bits according to ADC_Mode value */
;;;197      /* Set SCAN bit according to ADC_ScanConvMode value */
;;;198      tmpreg1 |= (u32)(ADC_InitStruct->ADC_Mode | ((u32)ADC_InitStruct->ADC_ScanConvMode << 8));
000060  790c              LDRB     r4,[r1,#4]
000062  680b              LDR      r3,[r1,#0]
000064  ea42ea42          ORR      r2,r2,r4,LSL #8
000068  4313              ORRS     r3,r3,r2
;;;199      /* Write to ADCx CR1 */
;;;200      ADCx->CR1 = tmpreg1;
00006a  6043              STR      r3,[r0,#4]
;;;201    
;;;202      /*---------------------------- ADCx CR2 Configuration -----------------*/
;;;203      /* Get the ADCx CR2 value */
;;;204      tmpreg1 = ADCx->CR2;
00006c  6882              LDR      r2,[r0,#8]
;;;205      /* Clear CONT, ALIGN and EXTSEL bits */
;;;206      tmpreg1 &= CR2_CLEAR_Mask;
00006e  4bb8              LDR      r3,|L1.848|
000070  401a              ANDS     r2,r2,r3
;;;207      /* Configure ADCx: external trigger event and continuous conversion mode */
;;;208      /* Set ALIGN bit according to ADC_DataAlign value */
;;;209      /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
;;;210      /* Set CONT bit according to ADC_ContinuousConvMode value */
;;;211      tmpreg1 |= (u32)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
000072  e9d1e9d1          LDRD     r4,r3,[r1,#8]
000076  4323              ORRS     r3,r3,r4
000078  794c              LDRB     r4,[r1,#5]
00007a  ea42ea42          ORR      r2,r2,r4,LSL #1
00007e  4313              ORRS     r3,r3,r2
;;;212                ((u32)ADC_InitStruct->ADC_ContinuousConvMode << 1));
;;;213      /* Write to ADCx CR2 */
;;;214      ADCx->CR2 = tmpreg1;
000080  6083              STR      r3,[r0,#8]
;;;215    
;;;216      /*---------------------------- ADCx SQR1 Configuration -----------------*/
;;;217      /* Get the ADCx SQR1 value */
;;;218      tmpreg1 = ADCx->SQR1;
000082  6ac2              LDR      r2,[r0,#0x2c]
;;;219      /* Clear L bits */
;;;220      tmpreg1 &= SQR1_CLEAR_Mask;
000084  f422f422          BIC      r2,r2,#0xf00000
;;;221      /* Configure ADCx: regular channel sequence length */
;;;222      /* Set L bits according to ADC_NbrOfChannel value */
;;;223      tmpreg2 |= (ADC_InitStruct->ADC_NbrOfChannel - 1);
000088  7c09              LDRB     r1,[r1,#0x10]
00008a  1e49              SUBS     r1,r1,#1
00008c  b2c9              UXTB     r1,r1
;;;224      tmpreg1 |= ((u32)tmpreg2 << 20);
00008e  ea42ea42          ORR      r1,r2,r1,LSL #20
;;;225      /* Write to ADCx SQR1 */
;;;226      ADCx->SQR1 = tmpreg1;
000092  62c1              STR      r1,[r0,#0x2c]
;;;227    }
000094  bd10              POP      {r4,pc}
;;;228    
                          ENDP

                  ADC_StructInit PROC
;;;240      /* Initialize the ADC_Mode member */
;;;241      ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;
000096  2100              MOVS     r1,#0
000098  6001              STR      r1,[r0,#0]
;;;242    
;;;243      /* initialize the ADC_ScanConvMode member */
;;;244      ADC_InitStruct->ADC_ScanConvMode = DISABLE;
00009a  7101              STRB     r1,[r0,#4]
;;;245    
;;;246      /* Initialize the ADC_ContinuousConvMode member */
;;;247      ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
00009c  7141              STRB     r1,[r0,#5]
;;;248    
;;;249      /* Initialize the ADC_ExternalTrigConv member */
;;;250      ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
00009e  6081              STR      r1,[r0,#8]
;;;251    
;;;252      /* Initialize the ADC_DataAlign member */
;;;253      ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
0000a0  60c1              STR      r1,[r0,#0xc]
;;;254    
;;;255      /* Initialize the ADC_NbrOfChannel member */
;;;256      ADC_InitStruct->ADC_NbrOfChannel = 1;
0000a2  2101              MOVS     r1,#1
0000a4  7401              STRB     r1,[r0,#0x10]
;;;257    }
0000a6  4770              BX       lr
;;;258    
                          ENDP

                  ADC_Cmd PROC
;;;273    
;;;274      if (NewState != DISABLE)
0000a8  b121              CBZ      r1,|L1.180|
;;;275      {
;;;276        /* Set the ADON bit to wake up the ADC from power down mode */
;;;277        ADCx->CR2 |= CR2_ADON_Set;
0000aa  6881              LDR      r1,[r0,#8]
0000ac  f041f041          ORR      r1,r1,#1
0000b0  6081              STR      r1,[r0,#8]
;;;278      }
;;;279      else
;;;280      {
;;;281        /* Disable the selected ADC peripheral */
;;;282        ADCx->CR2 &= CR2_ADON_Reset;
;;;283      }
;;;284    }
0000b2  4770              BX       lr
                  |L1.180|
0000b4  6881              LDR      r1,[r0,#8]            ;282
0000b6  f021f021          BIC      r1,r1,#1              ;282
0000ba  6081              STR      r1,[r0,#8]            ;282
0000bc  4770              BX       lr
;;;285    
                          ENDP

                  ADC_DMACmd PROC
;;;301    
;;;302      if (NewState != DISABLE)
0000be  b121              CBZ      r1,|L1.202|
;;;303      {
;;;304        /* Enable the selected ADC DMA request */
;;;305        ADCx->CR2 |= CR2_DMA_Set;
0000c0  6881              LDR      r1,[r0,#8]
0000c2  f441f441          ORR      r1,r1,#0x100
0000c6  6081              STR      r1,[r0,#8]
;;;306      }
;;;307      else
;;;308      {
;;;309        /* Disable the selected ADC DMA request */
;;;310        ADCx->CR2 &= CR2_DMA_Reset;
;;;311      }
;;;312    }
0000c8  4770              BX       lr
                  |L1.202|
0000ca  6881              LDR      r1,[r0,#8]            ;310
0000cc  f421f421          BIC      r1,r1,#0x100          ;310
0000d0  6081              STR      r1,[r0,#8]            ;310
0000d2  4770              BX       lr
;;;313    
                          ENDP

                  ADC_ITConfig PROC
;;;338      /* Get the ADC IT index */
;;;339      itmask = (u8)ADC_IT;
0000d4  b2c9              UXTB     r1,r1
;;;340    
;;;341      if (NewState != DISABLE)
0000d6  b11a              CBZ      r2,|L1.224|
;;;342      {
;;;343        /* Enable the selected ADC interrupts */
;;;344        ADCx->CR1 |= itmask;
0000d8  6842              LDR      r2,[r0,#4]
0000da  430a              ORRS     r2,r2,r1
0000dc  6042              STR      r2,[r0,#4]
;;;345      }
;;;346      else
;;;347      {
;;;348        /* Disable the selected ADC interrupts */
;;;349        ADCx->CR1 &= (~(u32)itmask);
;;;350      }
;;;351    }
0000de  4770              BX       lr
                  |L1.224|
0000e0  6842              LDR      r2,[r0,#4]            ;349
0000e2  438a              BICS     r2,r2,r1              ;349
0000e4  6042              STR      r2,[r0,#4]            ;349
0000e6  4770              BX       lr
;;;352    
                          ENDP

                  ADC_ResetCalibration PROC
;;;365      /* Resets the selected ADC calibartion registers */  
;;;366      ADCx->CR2 |= CR2_RSTCAL_Set;
0000e8  6881              LDR      r1,[r0,#8]
0000ea  f041f041          ORR      r1,r1,#8
0000ee  6081              STR      r1,[r0,#8]
;;;367    }
0000f0  4770              BX       lr
;;;368    
                          ENDP

                  ADC_GetResetCalibrationStatus PROC
;;;376    FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx)
;;;377    {
0000f2  4601              MOV      r1,r0
;;;378      FlagStatus bitstatus = RESET;
0000f4  2000              MOVS     r0,#0
;;;379    
;;;380      /* Check the parameters */
;;;381      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;382    
;;;383      /* Check the status of RSTCAL bit */
;;;384      if ((ADCx->CR2 & CR2_RSTCAL_Set) != (u32)RESET)
0000f6  6889              LDR      r1,[r1,#8]
0000f8  0709              LSLS     r1,r1,#28
0000fa  d500              BPL      |L1.254|
;;;385      {
;;;386        /* RSTCAL bit is set */
;;;387        bitstatus = SET;
0000fc  2001              MOVS     r0,#1
                  |L1.254|
;;;388      }
;;;389      else
;;;390      {
;;;391        /* RSTCAL bit is reset */
;;;392        bitstatus = RESET;
;;;393      }
;;;394    
;;;395      /* Return the RSTCAL bit status */
;;;396      return  bitstatus;
;;;397    }
0000fe  4770              BX       lr
;;;398    
                          ENDP

                  ADC_StartCalibration PROC
;;;411      /* Enable the selected ADC calibration process */  
;;;412      ADCx->CR2 |= CR2_CAL_Set;
000100  6881              LDR      r1,[r0,#8]
000102  f041f041          ORR      r1,r1,#4
000106  6081              STR      r1,[r0,#8]
;;;413    }
000108  4770              BX       lr
;;;414    
                          ENDP

                  ADC_GetCalibrationStatus PROC
;;;422    FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx)
;;;423    {
00010a  4601              MOV      r1,r0
;;;424      FlagStatus bitstatus = RESET;
00010c  2000              MOVS     r0,#0
;;;425    
;;;426      /* Check the parameters */
;;;427      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;428    
;;;429      /* Check the status of CAL bit */
;;;430      if ((ADCx->CR2 & CR2_CAL_Set) != (u32)RESET)
00010e  6889              LDR      r1,[r1,#8]
000110  0749              LSLS     r1,r1,#29
000112  d500              BPL      |L1.278|
;;;431      {
;;;432        /* CAL bit is set: calibration on going */
;;;433        bitstatus = SET;
000114  2001              MOVS     r0,#1
                  |L1.278|
;;;434      }
;;;435      else
;;;436      {
;;;437        /* CAL bit is reset: end of calibration */
;;;438        bitstatus = RESET;
;;;439      }
;;;440    
;;;441      /* Return the CAL bit status */
;;;442      return  bitstatus;
;;;443    }
000116  4770              BX       lr
;;;444    
                          ENDP

                  ADC_SoftwareStartConvCmd PROC
;;;459    
;;;460      if (NewState != DISABLE)
000118  b121              CBZ      r1,|L1.292|
;;;461      {
;;;462        /* Enable the selected ADC conversion on external event and start the selected
;;;463           ADC conversion */
;;;464        ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;
00011a  6881              LDR      r1,[r0,#8]
00011c  f441f441          ORR      r1,r1,#0x500000
000120  6081              STR      r1,[r0,#8]
;;;465      }
;;;466      else
;;;467      {
;;;468        /* Disable the selected ADC conversion on external event and stop the selected
;;;469           ADC conversion */
;;;470        ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;
;;;471      }
;;;472    }
000122  4770              BX       lr
                  |L1.292|
000124  6881              LDR      r1,[r0,#8]            ;470
000126  f421f421          BIC      r1,r1,#0x500000       ;470
00012a  6081              STR      r1,[r0,#8]            ;470
00012c  4770              BX       lr
;;;473    
                          ENDP

                  ADC_GetSoftwareStartConvStatus PROC
;;;481    FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
;;;482    {
00012e  4601              MOV      r1,r0
;;;483      FlagStatus bitstatus = RESET;
000130  2000              MOVS     r0,#0
;;;484    
;;;485      /* Check the parameters */
;;;486      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;487    
;;;488      /* Check the status of SWSTART bit */
;;;489      if ((ADCx->CR2 & CR2_SWSTART_Set) != (u32)RESET)
000132  6889              LDR      r1,[r1,#8]
000134  0249              LSLS     r1,r1,#9
000136  d500              BPL      |L1.314|
;;;490      {
;;;491        /* SWSTART bit is set */
;;;492        bitstatus = SET;
000138  2001              MOVS     r0,#1
                  |L1.314|
;;;493      }
;;;494      else
;;;495      {
;;;496        /* SWSTART bit is reset */
;;;497        bitstatus = RESET;
;;;498      }
;;;499    
;;;500      /* Return the SWSTART bit status */
;;;501      return  bitstatus;
;;;502    }
00013a  4770              BX       lr
;;;503    
                          ENDP

                  ADC_DiscModeChannelCountConfig PROC
;;;523      /* Get the old register value */
;;;524      tmpreg1 = ADCx->CR1;
00013c  6842              LDR      r2,[r0,#4]
;;;525      /* Clear the old discontinuous mode channel count */
;;;526      tmpreg1 &= CR1_DISCNUM_Reset;
00013e  f422f422          BIC      r2,r2,#0xe000
;;;527      /* Set the discontinuous mode channel count */
;;;528      tmpreg2 = Number - 1;
000142  1e49              SUBS     r1,r1,#1
;;;529      tmpreg1 |= tmpreg2 << 13;
000144  ea42ea42          ORR      r1,r2,r1,LSL #13
;;;530      /* Store the new register value */
;;;531      ADCx->CR1 = tmpreg1;
000148  6041              STR      r1,[r0,#4]
;;;532    }
00014a  4770              BX       lr
;;;533    
                          ENDP

                  ADC_DiscModeCmd PROC
;;;550    
;;;551      if (NewState != DISABLE)
00014c  b121              CBZ      r1,|L1.344|
;;;552      {
;;;553        /* Enable the selected ADC regular discontinuous mode */
;;;554        ADCx->CR1 |= CR1_DISCEN_Set;
00014e  6841              LDR      r1,[r0,#4]
000150  f441f441          ORR      r1,r1,#0x800
000154  6041              STR      r1,[r0,#4]
;;;555      }
;;;556      else
;;;557      {
;;;558        /* Disable the selected ADC regular discontinuous mode */
;;;559        ADCx->CR1 &= CR1_DISCEN_Reset;
;;;560      }
;;;561    }
000156  4770              BX       lr
                  |L1.344|
000158  6841              LDR      r1,[r0,#4]            ;559
00015a  f421f421          BIC      r1,r1,#0x800          ;559
00015e  6041              STR      r1,[r0,#4]            ;559
000160  4770              BX       lr
;;;562    
                          ENDP

                  ADC_RegularChannelConfig PROC
;;;604    void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime)
;;;605    {
000162  b570              PUSH     {r4-r6,lr}
;;;606      u32 tmpreg1 = 0, tmpreg2 = 0;
;;;607    
;;;608      /* Check the parameters */
;;;609      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;610      assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;611      assert_param(IS_ADC_REGULAR_RANK(Rank));
;;;612      assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;613    
;;;614      /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
;;;615      if (ADC_Channel > ADC_Channel_9)
000164  2607              MOVS     r6,#7
000166  2909              CMP      r1,#9
000168  d90a              BLS      |L1.384|
;;;616      {
;;;617        /* Get the old register value */
;;;618        tmpreg1 = ADCx->SMPR1;
00016a  68c5              LDR      r5,[r0,#0xc]
;;;619        /* Calculate the mask to clear */
;;;620        tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
00016c  f1a1f1a1          SUB      r4,r1,#0xa
000170  eb04eb04          ADD      r4,r4,r4,LSL #1
000174  40a6              LSLS     r6,r6,r4
;;;621        /* Clear the old discontinuous mode channel count */
;;;622        tmpreg1 &= ~tmpreg2;
000176  43b5              BICS     r5,r5,r6
;;;623        /* Calculate the mask to set */
;;;624        tmpreg2 = (u32)ADC_SampleTime << (3 * (ADC_Channel - 10));
000178  40a3              LSLS     r3,r3,r4
;;;625        /* Set the discontinuous mode channel count */
;;;626        tmpreg1 |= tmpreg2;
00017a  431d              ORRS     r5,r5,r3
;;;627        /* Store the new register value */
;;;628        ADCx->SMPR1 = tmpreg1;
00017c  60c5              STR      r5,[r0,#0xc]
00017e  e007              B        |L1.400|
                  |L1.384|
;;;629      }
;;;630      else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;631      {
;;;632        /* Get the old register value */
;;;633        tmpreg1 = ADCx->SMPR2;
000180  6905              LDR      r5,[r0,#0x10]
;;;634        /* Calculate the mask to clear */
;;;635        tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
000182  eb01eb01          ADD      r4,r1,r1,LSL #1
000186  40a6              LSLS     r6,r6,r4
;;;636        /* Clear the old discontinuous mode channel count */
;;;637        tmpreg1 &= ~tmpreg2;
000188  43b5              BICS     r5,r5,r6
;;;638        /* Calculate the mask to set */
;;;639        tmpreg2 = (u32)ADC_SampleTime << (3 * ADC_Channel);
00018a  40a3              LSLS     r3,r3,r4
;;;640        /* Set the discontinuous mode channel count */
;;;641        tmpreg1 |= tmpreg2;
00018c  431d              ORRS     r5,r5,r3
;;;642        /* Store the new register value */
;;;643        ADCx->SMPR2 = tmpreg1;
00018e  6105              STR      r5,[r0,#0x10]
                  |L1.400|
;;;644      }
;;;645      /* For Rank 1 to 6 */
;;;646      if (Rank < 7)
000190  231f              MOVS     r3,#0x1f
000192  2a07              CMP      r2,#7
000194  d209              BCS      |L1.426|
;;;647      {
;;;648        /* Get the old register value */
;;;649        tmpreg1 = ADCx->SQR3;
000196  6b44              LDR      r4,[r0,#0x34]
;;;650        /* Calculate the mask to clear */
;;;651        tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
000198  1e52              SUBS     r2,r2,#1
00019a  eb02eb02          ADD      r2,r2,r2,LSL #2
00019e  4093              LSLS     r3,r3,r2
;;;652        /* Clear the old SQx bits for the selected rank */
;;;653        tmpreg1 &= ~tmpreg2;
0001a0  439c              BICS     r4,r4,r3
;;;654        /* Calculate the mask to set */
;;;655        tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 1));
0001a2  4091              LSLS     r1,r1,r2
;;;656        /* Set the SQx bits for the selected rank */
;;;657        tmpreg1 |= tmpreg2;
0001a4  430c              ORRS     r4,r4,r1
;;;658        /* Store the new register value */
;;;659        ADCx->SQR3 = tmpreg1;
0001a6  6344              STR      r4,[r0,#0x34]
;;;660      }
;;;661      /* For Rank 7 to 12 */
;;;662      else if (Rank < 13)
;;;663      {
;;;664        /* Get the old register value */
;;;665        tmpreg1 = ADCx->SQR2;
;;;666        /* Calculate the mask to clear */
;;;667        tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
;;;668        /* Clear the old SQx bits for the selected rank */
;;;669        tmpreg1 &= ~tmpreg2;
;;;670        /* Calculate the mask to set */
;;;671        tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 7));
;;;672        /* Set the SQx bits for the selected rank */
;;;673        tmpreg1 |= tmpreg2;
;;;674        /* Store the new register value */
;;;675        ADCx->SQR2 = tmpreg1;
;;;676      }
;;;677      /* For Rank 13 to 16 */
;;;678      else
;;;679      {
;;;680        /* Get the old register value */
;;;681        tmpreg1 = ADCx->SQR1;
;;;682        /* Calculate the mask to clear */
;;;683        tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
;;;684        /* Clear the old SQx bits for the selected rank */
;;;685        tmpreg1 &= ~tmpreg2;
;;;686        /* Calculate the mask to set */
;;;687        tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 13));
;;;688        /* Set the SQx bits for the selected rank */
;;;689        tmpreg1 |= tmpreg2;
;;;690        /* Store the new register value */
;;;691        ADCx->SQR1 = tmpreg1;
;;;692      }
;;;693    }
0001a8  bd70              POP      {r4-r6,pc}
                  |L1.426|
0001aa  2a0d              CMP      r2,#0xd               ;662
0001ac  d209              BCS      |L1.450|
0001ae  6b04              LDR      r4,[r0,#0x30]         ;665
0001b0  1fd2              SUBS     r2,r2,#7              ;667
0001b2  eb02eb02          ADD      r2,r2,r2,LSL #2       ;667
0001b6  4093              LSLS     r3,r3,r2              ;667
0001b8  439c              BICS     r4,r4,r3              ;669
0001ba  4091              LSLS     r1,r1,r2              ;671
0001bc  430c              ORRS     r4,r4,r1              ;673
0001be  6304              STR      r4,[r0,#0x30]         ;675
0001c0  bd70              POP      {r4-r6,pc}
                  |L1.450|
0001c2  6ac4              LDR      r4,[r0,#0x2c]         ;681
0001c4  3a0d              SUBS     r2,r2,#0xd            ;683
0001c6  eb02eb02          ADD      r2,r2,r2,LSL #2       ;683
0001ca  4093              LSLS     r3,r3,r2              ;683
0001cc  439c              BICS     r4,r4,r3              ;685
0001ce  4091              LSLS     r1,r1,r2              ;687
0001d0  430c              ORRS     r4,r4,r1              ;689
0001d2  62c4              STR      r4,[r0,#0x2c]         ;691
0001d4  bd70              POP      {r4-r6,pc}
;;;694    
                          ENDP

                  ADC_ExternalTrigConvCmd PROC
;;;710    
;;;711      if (NewState != DISABLE)
0001d6  b121              CBZ      r1,|L1.482|
;;;712      {
;;;713        /* Enable the selected ADC conversion on external event */
;;;714        ADCx->CR2 |= CR2_EXTTRIG_Set;
0001d8  6881              LDR      r1,[r0,#8]
0001da  f441f441          ORR      r1,r1,#0x100000
0001de  6081              STR      r1,[r0,#8]
;;;715      }
;;;716      else
;;;717      {
;;;718        /* Disable the selected ADC conversion on external event */
;;;719        ADCx->CR2 &= CR2_EXTTRIG_Reset;
;;;720      }
;;;721    }
0001e0  4770              BX       lr
                  |L1.482|
0001e2  6881              LDR      r1,[r0,#8]            ;719
0001e4  f421f421          BIC      r1,r1,#0x100000       ;719
0001e8  6081              STR      r1,[r0,#8]            ;719
0001ea  4770              BX       lr
;;;722    
                          ENDP

                  ADC_GetConversionValue PROC
;;;735      /* Return the selected ADC conversion value */
;;;736      return (u16) ADCx->DR;
0001ec  6cc0              LDR      r0,[r0,#0x4c]
0001ee  b280              UXTH     r0,r0
;;;737    }
0001f0  4770              BX       lr
;;;738    
                          ENDP

                  ADC_GetDualModeConversionValue PROC
;;;747      /* Return the dual mode conversion value */
;;;748      return (*(vu32 *) DR_ADDRESS);
0001f2  4858              LDR      r0,|L1.852|
0001f4  6800              LDR      r0,[r0,#0]
;;;749    }
0001f6  4770              BX       lr
;;;750    
                          ENDP

                  ADC_AutoInjectedConvCmd PROC
;;;767    
;;;768      if (NewState != DISABLE)
0001f8  b121              CBZ      r1,|L1.516|
;;;769      {
;;;770        /* Enable the selected ADC automatic injected group conversion */
;;;771        ADCx->CR1 |= CR1_JAUTO_Set;
0001fa  6841              LDR      r1,[r0,#4]
0001fc  f441f441          ORR      r1,r1,#0x400
000200  6041              STR      r1,[r0,#4]
;;;772      }
;;;773      else
;;;774      {
;;;775        /* Disable the selected ADC automatic injected group conversion */
;;;776        ADCx->CR1 &= CR1_JAUTO_Reset;
;;;777      }
;;;778    }
000202  4770              BX       lr
                  |L1.516|
000204  6841              LDR      r1,[r0,#4]            ;776
000206  f421f421          BIC      r1,r1,#0x400          ;776
00020a  6041              STR      r1,[r0,#4]            ;776
00020c  4770              BX       lr
;;;779    
                          ENDP

                  ADC_InjectedDiscModeCmd PROC
;;;796    
;;;797      if (NewState != DISABLE)
00020e  b121              CBZ      r1,|L1.538|
;;;798      {
;;;799        /* Enable the selected ADC injected discontinuous mode */
;;;800        ADCx->CR1 |= CR1_JDISCEN_Set;
000210  6841              LDR      r1,[r0,#4]
000212  f441f441          ORR      r1,r1,#0x1000
000216  6041              STR      r1,[r0,#4]
;;;801      }
;;;802      else
;;;803      {
;;;804        /* Disable the selected ADC injected discontinuous mode */
;;;805        ADCx->CR1 &= CR1_JDISCEN_Reset;
;;;806      }
;;;807    }
000218  4770              BX       lr
                  |L1.538|
00021a  6841              LDR      r1,[r0,#4]            ;805
00021c  f421f421          BIC      r1,r1,#0x1000         ;805
000220  6041              STR      r1,[r0,#4]            ;805
000222  4770              BX       lr
;;;808    
                          ENDP

                  ADC_ExternalTrigInjectedConvConfig PROC
;;;855      /* Get the old register value */
;;;856      tmpreg = ADCx->CR2;
000224  6882              LDR      r2,[r0,#8]
;;;857      /* Clear the old external event selection for injected group */
;;;858      tmpreg &= CR2_JEXTSEL_Reset;
000226  f422f422          BIC      r2,r2,#0x7000
;;;859      /* Set the external event selection for injected group */
;;;860      tmpreg |= ADC_ExternalTrigInjecConv;
00022a  430a              ORRS     r2,r2,r1
;;;861      /* Store the new register value */
;;;862      ADCx->CR2 = tmpreg;
00022c  6082              STR      r2,[r0,#8]
;;;863    }
00022e  4770              BX       lr
;;;864    
                          ENDP

                  ADC_ExternalTrigInjectedConvCmd PROC
;;;881    
;;;882      if (NewState != DISABLE)
000230  b121              CBZ      r1,|L1.572|
;;;883      {
;;;884        /* Enable the selected ADC external event selection for injected group */
;;;885        ADCx->CR2 |= CR2_JEXTTRIG_Set;
000232  6881              LDR      r1,[r0,#8]
000234  f441f441          ORR      r1,r1,#0x8000
000238  6081              STR      r1,[r0,#8]
;;;886      }
;;;887      else
;;;888      {
;;;889        /* Disable the selected ADC external event selection for injected group */
;;;890        ADCx->CR2 &= CR2_JEXTTRIG_Reset;
;;;891      }
;;;892    }
00023a  4770              BX       lr
                  |L1.572|
00023c  6881              LDR      r1,[r0,#8]            ;890
00023e  f421f421          BIC      r1,r1,#0x8000         ;890
000242  6081              STR      r1,[r0,#8]            ;890
000244  4770              BX       lr
;;;893    
                          ENDP

                  ADC_SoftwareStartInjectedConvCmd PROC
;;;910    
;;;911      if (NewState != DISABLE)
000246  b121              CBZ      r1,|L1.594|
;;;912      {
;;;913        /* Enable the selected ADC conversion for injected group on external event and start the selected
;;;914           ADC injected conversion */
;;;915        ADCx->CR2 |= CR2_JEXTTRIG_JSWSTART_Set;
000248  6881              LDR      r1,[r0,#8]
00024a  f441f441          ORR      r1,r1,#0x208000
00024e  6081              STR      r1,[r0,#8]
;;;916      }
;;;917      else
;;;918      {
;;;919        /* Disable the selected ADC conversion on external event for injected group and stop the selected
;;;920           ADC injected conversion */
;;;921        ADCx->CR2 &= CR2_JEXTTRIG_JSWSTART_Reset;
;;;922      }
;;;923    }
000250  4770              BX       lr
                  |L1.594|
000252  6881              LDR      r1,[r0,#8]            ;921
000254  f421f421          BIC      r1,r1,#0x208000       ;921
000258  6081              STR      r1,[r0,#8]            ;921
00025a  4770              BX       lr
;;;924    
                          ENDP

                  ADC_GetSoftwareStartInjectedConvCmdStatus PROC
;;;932    FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
;;;933    {
00025c  4601              MOV      r1,r0
;;;934      FlagStatus bitstatus = RESET;
00025e  2000              MOVS     r0,#0
;;;935    
;;;936      /* Check the parameters */
;;;937      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;938    
;;;939      /* Check the status of JSWSTART bit */
;;;940      if ((ADCx->CR2 & CR2_JSWSTART_Set) != (u32)RESET)
000260  6889              LDR      r1,[r1,#8]
000262  0289              LSLS     r1,r1,#10
000264  d500              BPL      |L1.616|
;;;941      {
;;;942        /* JSWSTART bit is set */
;;;943        bitstatus = SET;
000266  2001              MOVS     r0,#1
                  |L1.616|
;;;944      }
;;;945      else
;;;946      {
;;;947        /* JSWSTART bit is reset */
;;;948        bitstatus = RESET;
;;;949      }
;;;950    
;;;951      /* Return the JSWSTART bit status */
;;;952      return  bitstatus;
;;;953    }
000268  4770              BX       lr
;;;954    
                          ENDP

                  ADC_InjectedChannelConfig PROC
;;;996    void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime)
;;;997    {
00026a  b570              PUSH     {r4-r6,lr}
;;;998      u32 tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
;;;999    
;;;1000     /* Check the parameters */
;;;1001     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1002     assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;1003     assert_param(IS_ADC_INJECTED_RANK(Rank));
;;;1004     assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;1005   
;;;1006     /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
;;;1007     if (ADC_Channel > ADC_Channel_9)
00026c  2607              MOVS     r6,#7
00026e  2909              CMP      r1,#9
000270  d90a              BLS      |L1.648|
;;;1008     {
;;;1009       /* Get the old register value */
;;;1010       tmpreg1 = ADCx->SMPR1;
000272  68c5              LDR      r5,[r0,#0xc]
;;;1011       /* Calculate the mask to clear */
;;;1012       tmpreg2 = SMPR1_SMP_Set << (3*(ADC_Channel - 10));
000274  f1a1f1a1          SUB      r4,r1,#0xa
000278  eb04eb04          ADD      r4,r4,r4,LSL #1
00027c  40a6              LSLS     r6,r6,r4
;;;1013       /* Clear the old discontinuous mode channel count */
;;;1014       tmpreg1 &= ~tmpreg2;
00027e  43b5              BICS     r5,r5,r6
;;;1015       /* Calculate the mask to set */
;;;1016       tmpreg2 = (u32)ADC_SampleTime << (3*(ADC_Channel - 10));
000280  40a3              LSLS     r3,r3,r4
;;;1017       /* Set the discontinuous mode channel count */
;;;1018       tmpreg1 |= tmpreg2;
000282  431d              ORRS     r5,r5,r3
;;;1019       /* Store the new register value */
;;;1020       ADCx->SMPR1 = tmpreg1;
000284  60c5              STR      r5,[r0,#0xc]
000286  e007              B        |L1.664|
                  |L1.648|
;;;1021     }
;;;1022     else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;1023     {
;;;1024       /* Get the old register value */
;;;1025       tmpreg1 = ADCx->SMPR2;
000288  6905              LDR      r5,[r0,#0x10]
;;;1026       /* Calculate the mask to clear */
;;;1027       tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
00028a  eb01eb01          ADD      r4,r1,r1,LSL #1
00028e  40a6              LSLS     r6,r6,r4
;;;1028       /* Clear the old discontinuous mode channel count */
;;;1029       tmpreg1 &= ~tmpreg2;
000290  43b5              BICS     r5,r5,r6
;;;1030       /* Calculate the mask to set */
;;;1031       tmpreg2 = (u32)ADC_SampleTime << (3 * ADC_Channel);
000292  40a3              LSLS     r3,r3,r4
;;;1032       /* Set the discontinuous mode channel count */
;;;1033       tmpreg1 |= tmpreg2;
000294  431d              ORRS     r5,r5,r3
;;;1034       /* Store the new register value */
;;;1035       ADCx->SMPR2 = tmpreg1;
000296  6105              STR      r5,[r0,#0x10]
                  |L1.664|
;;;1036     }
;;;1037   
;;;1038     /* Rank configuration */
;;;1039     /* Get the old register value */
;;;1040     tmpreg1 = ADCx->JSQR;
000298  6b83              LDR      r3,[r0,#0x38]
;;;1041     /* Get JL value: Number = JL+1 */
;;;1042     tmpreg3 =  (tmpreg1 & JSQR_JL_Set)>> 20;
00029a  f3c3f3c3          UBFX     r4,r3,#20,#2
;;;1043     /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
;;;1044     tmpreg2 = JSQR_JSQ_Set << (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
00029e  1b12              SUBS     r2,r2,r4
0002a0  1c92              ADDS     r2,r2,#2
0002a2  eb02eb02          ADD      r2,r2,r2,LSL #2
0002a6  241f              MOVS     r4,#0x1f
0002a8  4094              LSLS     r4,r4,r2
;;;1045     /* Clear the old JSQx bits for the selected rank */
;;;1046     tmpreg1 &= ~tmpreg2;
0002aa  43a3              BICS     r3,r3,r4
;;;1047     /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
;;;1048     tmpreg2 = (u32)ADC_Channel << (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
0002ac  4091              LSLS     r1,r1,r2
;;;1049     /* Set the JSQx bits for the selected rank */
;;;1050     tmpreg1 |= tmpreg2;
0002ae  430b              ORRS     r3,r3,r1
;;;1051     /* Store the new register value */
;;;1052     ADCx->JSQR = tmpreg1;
0002b0  6383              STR      r3,[r0,#0x38]
;;;1053   }
0002b2  bd70              POP      {r4-r6,pc}
;;;1054   
                          ENDP

                  ADC_InjectedSequencerLengthConfig PROC
;;;1073     /* Get the old register value */
;;;1074     tmpreg1 = ADCx->JSQR;
0002b4  6b82              LDR      r2,[r0,#0x38]
;;;1075     /* Clear the old injected sequnence lenght JL bits */
;;;1076     tmpreg1 &= JSQR_JL_Reset;
0002b6  f422f422          BIC      r2,r2,#0x300000
;;;1077     /* Set the injected sequnence lenght JL bits */
;;;1078     tmpreg2 = Length - 1; 
0002ba  1e49              SUBS     r1,r1,#1
;;;1079     tmpreg1 |= tmpreg2 << 20;
0002bc  ea42ea42          ORR      r1,r2,r1,LSL #20
;;;1080     /* Store the new register value */
;;;1081     ADCx->JSQR = tmpreg1;
0002c0  6381              STR      r1,[r0,#0x38]
;;;1082   }
0002c2  4770              BX       lr
;;;1083   
                          ENDP

                  ADC_SetInjectedOffset PROC
;;;1107     /* Set the selected injected channel data offset */
;;;1108     *((vu32 *)((*(u32*)&ADCx) + ADC_InjectedChannel)) = (u32)Offset;
0002c4  5042              STR      r2,[r0,r1]
;;;1109   }
0002c6  4770              BX       lr
;;;1110   
                          ENDP

                  ADC_GetInjectedConversionValue PROC
;;;1130     /* Returns the selected injected channel conversion data value */
;;;1131     return (u16) (*(vu32*) (((*(u32*)&ADCx) + ADC_InjectedChannel + JDR_Offset)));
0002c8  4408              ADD      r0,r0,r1
0002ca  6a80              LDR      r0,[r0,#0x28]
0002cc  b280              UXTH     r0,r0
;;;1132   }
0002ce  4770              BX       lr
;;;1133   
                          ENDP

                  ADC_AnalogWatchdogCmd PROC
;;;1166     /* Get the old register value */
;;;1167     tmpreg = ADCx->CR1;
0002d0  6842              LDR      r2,[r0,#4]
;;;1168     /* Clear AWDEN, AWDENJ and AWDSGL bits */
;;;1169     tmpreg &= CR1_AWDMode_Reset;
0002d2  4b21              LDR      r3,|L1.856|
0002d4  401a              ANDS     r2,r2,r3
;;;1170     /* Set the analog watchdog enable mode */
;;;1171     tmpreg |= ADC_AnalogWatchdog;
0002d6  430a              ORRS     r2,r2,r1
;;;1172     /* Store the new register value */
;;;1173     ADCx->CR1 = tmpreg;
0002d8  6042              STR      r2,[r0,#4]
;;;1174   }
0002da  4770              BX       lr
;;;1175   
                          ENDP

                  ADC_AnalogWatchdogThresholdsConfig PROC
;;;1195     /* Set the ADCx high threshold */
;;;1196     ADCx->HTR = HighThreshold;
0002dc  6241              STR      r1,[r0,#0x24]
;;;1197     /* Set the ADCx low threshold */
;;;1198     ADCx->LTR = LowThreshold;
0002de  6282              STR      r2,[r0,#0x28]
;;;1199   }
0002e0  4770              BX       lr
;;;1200   
                          ENDP

                  ADC_AnalogWatchdogSingleChannelConfig PROC
;;;1237     /* Get the old register value */
;;;1238     tmpreg = ADCx->CR1;
0002e2  6842              LDR      r2,[r0,#4]
;;;1239     /* Clear the Analog watchdog channel select bits */
;;;1240     tmpreg &= CR1_AWDCH_Reset;
0002e4  f022f022          BIC      r2,r2,#0x1f
;;;1241     /* Set the Analog watchdog channel */
;;;1242     tmpreg |= ADC_Channel;
0002e8  430a              ORRS     r2,r2,r1
;;;1243     /* Store the new register value */
;;;1244     ADCx->CR1 = tmpreg;
0002ea  6042              STR      r2,[r0,#4]
;;;1245   }
0002ec  4770              BX       lr
;;;1246   
                          ENDP

                  ADC_TempSensorVrefintCmd PROC
;;;1259   
;;;1260     if (NewState != DISABLE)
0002ee  491b              LDR      r1,|L1.860|
0002f0  b130              CBZ      r0,|L1.768|
;;;1261     {
;;;1262       /* Enable the temperature sensor and Vrefint channel*/
;;;1263       ADC1->CR2 |= CR2_TSVREFE_Set;
0002f2  f8d1f8d1          LDR      r0,[r1,#0x408]
0002f6  f440f440          ORR      r0,r0,#0x800000
0002fa  f8c1f8c1          STR      r0,[r1,#0x408]
;;;1264     }
;;;1265     else
;;;1266     {
;;;1267       /* Disable the temperature sensor and Vrefint channel*/
;;;1268       ADC1->CR2 &= CR2_TSVREFE_Reset;
;;;1269     }
;;;1270   }
0002fe  4770              BX       lr
                  |L1.768|
000300  f8d1f8d1          LDR      r0,[r1,#0x408]        ;1268
000304  f420f420          BIC      r0,r0,#0x800000       ;1268
000308  f8c1f8c1          STR      r0,[r1,#0x408]        ;1268
00030c  4770              BX       lr
;;;1271   
                          ENDP

                  ADC_GetFlagStatus PROC
;;;1286   FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, u8 ADC_FLAG)
;;;1287   {
00030e  4602              MOV      r2,r0
;;;1288     FlagStatus bitstatus = RESET;
000310  2000              MOVS     r0,#0
;;;1289   
;;;1290     /* Check the parameters */
;;;1291     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1292     assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
;;;1293   
;;;1294     /* Check the status of the specified ADC flag */
;;;1295     if ((ADCx->SR & ADC_FLAG) != (u8)RESET)
000312  6812              LDR      r2,[r2,#0]
000314  420a              TST      r2,r1
000316  d000              BEQ      |L1.794|
;;;1296     {
;;;1297       /* ADC_FLAG is set */
;;;1298       bitstatus = SET;
000318  2001              MOVS     r0,#1
                  |L1.794|
;;;1299     }
;;;1300     else
;;;1301     {
;;;1302       /* ADC_FLAG is reset */
;;;1303       bitstatus = RESET;
;;;1304     }
;;;1305   
;;;1306     /* Return the ADC_FLAG status */
;;;1307     return  bitstatus;
;;;1308   }
00031a  4770              BX       lr
;;;1309   
                          ENDP

                  ADC_ClearFlag PROC
;;;1330     /* Clear the selected ADC flags */
;;;1331     ADCx->SR = ~(u32)ADC_FLAG;
00031c  43c9              MVNS     r1,r1
00031e  6001              STR      r1,[r0,#0]
;;;1332   }
000320  4770              BX       lr
;;;1333   
                          ENDP

                  ADC_GetITStatus PROC
;;;1346   ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, u16 ADC_IT)
;;;1347   {
000322  b510              PUSH     {r4,lr}
000324  4602              MOV      r2,r0
;;;1348     ITStatus bitstatus = RESET;
000326  2000              MOVS     r0,#0
;;;1349     u32 itmask = 0, enablestatus = 0;
;;;1350   
;;;1351     /* Check the parameters */
;;;1352     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1353     assert_param(IS_ADC_GET_IT(ADC_IT));
;;;1354   
;;;1355     /* Get the ADC IT index */
;;;1356     itmask = ADC_IT >> 8;
000328  0a0b              LSRS     r3,r1,#8
;;;1357   
;;;1358     /* Get the ADC_IT enable bit status */
;;;1359     enablestatus = (ADCx->CR1 & (u8)ADC_IT) ;
00032a  6854              LDR      r4,[r2,#4]
00032c  b2c9              UXTB     r1,r1
00032e  400c              ANDS     r4,r4,r1
;;;1360   
;;;1361     /* Check the status of the specified ADC interrupt */
;;;1362     if (((ADCx->SR & itmask) != (u32)RESET) && enablestatus)
000330  6811              LDR      r1,[r2,#0]
000332  4219              TST      r1,r3
000334  d002              BEQ      |L1.828|
000336  2c00              CMP      r4,#0
000338  d000              BEQ      |L1.828|
;;;1363     {
;;;1364       /* ADC_IT is set */
;;;1365       bitstatus = SET;
00033a  2001              MOVS     r0,#1
                  |L1.828|
;;;1366     }
;;;1367     else
;;;1368     {
;;;1369       /* ADC_IT is reset */
;;;1370       bitstatus = RESET;
;;;1371     }
;;;1372   
;;;1373     /* Return the ADC_IT status */
;;;1374     return  bitstatus;
;;;1375   }
00033c  bd10              POP      {r4,pc}
;;;1376   
                          ENDP

                  ADC_ClearITPendingBit PROC
;;;1397     /* Get the ADC IT index */
;;;1398     itmask = (u8)(ADC_IT >> 8);
00033e  0a09              LSRS     r1,r1,#8
;;;1399   
;;;1400     /* Clear the selected ADC interrupt pending bits */
;;;1401     ADCx->SR = ~(u32)itmask;
000340  43c9              MVNS     r1,r1
000342  6001              STR      r1,[r0,#0]
;;;1402   }
000344  4770              BX       lr
;;;1403   
                          ENDP

000346  0000              DCW      0x0000
                  |L1.840|
000348  bffedc00          DCD      0xbffedc00
                  |L1.844|
00034c  fff0feff          DCD      0xfff0feff
                  |L1.848|
000350  fff1f7fd          DCD      0xfff1f7fd
                  |L1.852|
000354  4001244c          DCD      0x4001244c
                  |L1.856|
000358  ff3ffdff          DCD      0xff3ffdff
                  |L1.860|
00035c  40012000          DCD      0x40012000
